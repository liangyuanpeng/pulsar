// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PulsarApi.proto

#ifndef PROTOBUF_PulsarApi_2eproto__INCLUDED
#define PROTOBUF_PulsarApi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace pulsar {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PulsarApi_2eproto();
void protobuf_AssignDesc_PulsarApi_2eproto();
void protobuf_ShutdownFile_PulsarApi_2eproto();

class Schema;
class MessageIdData;
class KeyValue;
class KeyLongValue;
class EncryptionKeys;
class MessageMetadata;
class SingleMessageMetadata;
class CommandConnect;
class CommandConnected;
class CommandAuthResponse;
class CommandAuthChallenge;
class AuthData;
class CommandSubscribe;
class CommandPartitionedTopicMetadata;
class CommandPartitionedTopicMetadataResponse;
class CommandLookupTopic;
class CommandLookupTopicResponse;
class CommandProducer;
class CommandSend;
class CommandSendReceipt;
class CommandSendError;
class CommandMessage;
class CommandAck;
class CommandActiveConsumerChange;
class CommandFlow;
class CommandUnsubscribe;
class CommandSeek;
class CommandReachedEndOfTopic;
class CommandCloseProducer;
class CommandCloseConsumer;
class CommandRedeliverUnacknowledgedMessages;
class CommandSuccess;
class CommandProducerSuccess;
class CommandError;
class CommandPing;
class CommandPong;
class CommandConsumerStats;
class CommandConsumerStatsResponse;
class CommandGetLastMessageId;
class CommandGetLastMessageIdResponse;
class CommandGetTopicsOfNamespace;
class CommandGetTopicsOfNamespaceResponse;
class CommandGetSchema;
class CommandGetSchemaResponse;
class BaseCommand;

enum Schema_Type {
  Schema_Type_None = 0,
  Schema_Type_String = 1,
  Schema_Type_Json = 2,
  Schema_Type_Protobuf = 3,
  Schema_Type_Avro = 4,
  Schema_Type_Bool = 5,
  Schema_Type_Int8 = 6,
  Schema_Type_Int16 = 7,
  Schema_Type_Int32 = 8,
  Schema_Type_Int64 = 9,
  Schema_Type_Float = 10,
  Schema_Type_Double = 11,
  Schema_Type_Date = 12,
  Schema_Type_Time = 13,
  Schema_Type_Timestamp = 14,
  Schema_Type_KeyValue = 15
};
bool Schema_Type_IsValid(int value);
const Schema_Type Schema_Type_Type_MIN = Schema_Type_None;
const Schema_Type Schema_Type_Type_MAX = Schema_Type_KeyValue;
const int Schema_Type_Type_ARRAYSIZE = Schema_Type_Type_MAX + 1;

enum CommandSubscribe_SubType {
  CommandSubscribe_SubType_Exclusive = 0,
  CommandSubscribe_SubType_Shared = 1,
  CommandSubscribe_SubType_Failover = 2,
  CommandSubscribe_SubType_Key_Shared = 3
};
bool CommandSubscribe_SubType_IsValid(int value);
const CommandSubscribe_SubType CommandSubscribe_SubType_SubType_MIN = CommandSubscribe_SubType_Exclusive;
const CommandSubscribe_SubType CommandSubscribe_SubType_SubType_MAX = CommandSubscribe_SubType_Key_Shared;
const int CommandSubscribe_SubType_SubType_ARRAYSIZE = CommandSubscribe_SubType_SubType_MAX + 1;

enum CommandSubscribe_InitialPosition {
  CommandSubscribe_InitialPosition_Latest = 0,
  CommandSubscribe_InitialPosition_Earliest = 1
};
bool CommandSubscribe_InitialPosition_IsValid(int value);
const CommandSubscribe_InitialPosition CommandSubscribe_InitialPosition_InitialPosition_MIN = CommandSubscribe_InitialPosition_Latest;
const CommandSubscribe_InitialPosition CommandSubscribe_InitialPosition_InitialPosition_MAX = CommandSubscribe_InitialPosition_Earliest;
const int CommandSubscribe_InitialPosition_InitialPosition_ARRAYSIZE = CommandSubscribe_InitialPosition_InitialPosition_MAX + 1;

enum CommandPartitionedTopicMetadataResponse_LookupType {
  CommandPartitionedTopicMetadataResponse_LookupType_Success = 0,
  CommandPartitionedTopicMetadataResponse_LookupType_Failed = 1
};
bool CommandPartitionedTopicMetadataResponse_LookupType_IsValid(int value);
const CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MIN = CommandPartitionedTopicMetadataResponse_LookupType_Success;
const CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MAX = CommandPartitionedTopicMetadataResponse_LookupType_Failed;
const int CommandPartitionedTopicMetadataResponse_LookupType_LookupType_ARRAYSIZE = CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MAX + 1;

enum CommandLookupTopicResponse_LookupType {
  CommandLookupTopicResponse_LookupType_Redirect = 0,
  CommandLookupTopicResponse_LookupType_Connect = 1,
  CommandLookupTopicResponse_LookupType_Failed = 2
};
bool CommandLookupTopicResponse_LookupType_IsValid(int value);
const CommandLookupTopicResponse_LookupType CommandLookupTopicResponse_LookupType_LookupType_MIN = CommandLookupTopicResponse_LookupType_Redirect;
const CommandLookupTopicResponse_LookupType CommandLookupTopicResponse_LookupType_LookupType_MAX = CommandLookupTopicResponse_LookupType_Failed;
const int CommandLookupTopicResponse_LookupType_LookupType_ARRAYSIZE = CommandLookupTopicResponse_LookupType_LookupType_MAX + 1;

enum CommandAck_AckType {
  CommandAck_AckType_Individual = 0,
  CommandAck_AckType_Cumulative = 1
};
bool CommandAck_AckType_IsValid(int value);
const CommandAck_AckType CommandAck_AckType_AckType_MIN = CommandAck_AckType_Individual;
const CommandAck_AckType CommandAck_AckType_AckType_MAX = CommandAck_AckType_Cumulative;
const int CommandAck_AckType_AckType_ARRAYSIZE = CommandAck_AckType_AckType_MAX + 1;

enum CommandAck_ValidationError {
  CommandAck_ValidationError_UncompressedSizeCorruption = 0,
  CommandAck_ValidationError_DecompressionError = 1,
  CommandAck_ValidationError_ChecksumMismatch = 2,
  CommandAck_ValidationError_BatchDeSerializeError = 3,
  CommandAck_ValidationError_DecryptionError = 4
};
bool CommandAck_ValidationError_IsValid(int value);
const CommandAck_ValidationError CommandAck_ValidationError_ValidationError_MIN = CommandAck_ValidationError_UncompressedSizeCorruption;
const CommandAck_ValidationError CommandAck_ValidationError_ValidationError_MAX = CommandAck_ValidationError_DecryptionError;
const int CommandAck_ValidationError_ValidationError_ARRAYSIZE = CommandAck_ValidationError_ValidationError_MAX + 1;

enum CommandGetTopicsOfNamespace_Mode {
  CommandGetTopicsOfNamespace_Mode_PERSISTENT = 0,
  CommandGetTopicsOfNamespace_Mode_NON_PERSISTENT = 1,
  CommandGetTopicsOfNamespace_Mode_ALL = 2
};
bool CommandGetTopicsOfNamespace_Mode_IsValid(int value);
const CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace_Mode_Mode_MIN = CommandGetTopicsOfNamespace_Mode_PERSISTENT;
const CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace_Mode_Mode_MAX = CommandGetTopicsOfNamespace_Mode_ALL;
const int CommandGetTopicsOfNamespace_Mode_Mode_ARRAYSIZE = CommandGetTopicsOfNamespace_Mode_Mode_MAX + 1;

enum BaseCommand_Type {
  BaseCommand_Type_CONNECT = 2,
  BaseCommand_Type_CONNECTED = 3,
  BaseCommand_Type_SUBSCRIBE = 4,
  BaseCommand_Type_PRODUCER = 5,
  BaseCommand_Type_SEND = 6,
  BaseCommand_Type_SEND_RECEIPT = 7,
  BaseCommand_Type_SEND_ERROR = 8,
  BaseCommand_Type_MESSAGE = 9,
  BaseCommand_Type_ACK = 10,
  BaseCommand_Type_FLOW = 11,
  BaseCommand_Type_UNSUBSCRIBE = 12,
  BaseCommand_Type_SUCCESS = 13,
  BaseCommand_Type_ERROR = 14,
  BaseCommand_Type_CLOSE_PRODUCER = 15,
  BaseCommand_Type_CLOSE_CONSUMER = 16,
  BaseCommand_Type_PRODUCER_SUCCESS = 17,
  BaseCommand_Type_PING = 18,
  BaseCommand_Type_PONG = 19,
  BaseCommand_Type_REDELIVER_UNACKNOWLEDGED_MESSAGES = 20,
  BaseCommand_Type_PARTITIONED_METADATA = 21,
  BaseCommand_Type_PARTITIONED_METADATA_RESPONSE = 22,
  BaseCommand_Type_LOOKUP = 23,
  BaseCommand_Type_LOOKUP_RESPONSE = 24,
  BaseCommand_Type_CONSUMER_STATS = 25,
  BaseCommand_Type_CONSUMER_STATS_RESPONSE = 26,
  BaseCommand_Type_REACHED_END_OF_TOPIC = 27,
  BaseCommand_Type_SEEK = 28,
  BaseCommand_Type_GET_LAST_MESSAGE_ID = 29,
  BaseCommand_Type_GET_LAST_MESSAGE_ID_RESPONSE = 30,
  BaseCommand_Type_ACTIVE_CONSUMER_CHANGE = 31,
  BaseCommand_Type_GET_TOPICS_OF_NAMESPACE = 32,
  BaseCommand_Type_GET_TOPICS_OF_NAMESPACE_RESPONSE = 33,
  BaseCommand_Type_GET_SCHEMA = 34,
  BaseCommand_Type_GET_SCHEMA_RESPONSE = 35,
  BaseCommand_Type_AUTH_CHALLENGE = 36,
  BaseCommand_Type_AUTH_RESPONSE = 37
};
bool BaseCommand_Type_IsValid(int value);
const BaseCommand_Type BaseCommand_Type_Type_MIN = BaseCommand_Type_CONNECT;
const BaseCommand_Type BaseCommand_Type_Type_MAX = BaseCommand_Type_AUTH_RESPONSE;
const int BaseCommand_Type_Type_ARRAYSIZE = BaseCommand_Type_Type_MAX + 1;

enum CompressionType {
  NONE = 0,
  LZ4 = 1,
  ZLIB = 2,
  ZSTD = 3,
  SNAPPY = 4
};
bool CompressionType_IsValid(int value);
const CompressionType CompressionType_MIN = NONE;
const CompressionType CompressionType_MAX = SNAPPY;
const int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

enum ServerError {
  UnknownError = 0,
  MetadataError = 1,
  PersistenceError = 2,
  AuthenticationError = 3,
  AuthorizationError = 4,
  ConsumerBusy = 5,
  ServiceNotReady = 6,
  ProducerBlockedQuotaExceededError = 7,
  ProducerBlockedQuotaExceededException = 8,
  ChecksumError = 9,
  UnsupportedVersionError = 10,
  TopicNotFound = 11,
  SubscriptionNotFound = 12,
  ConsumerNotFound = 13,
  TooManyRequests = 14,
  TopicTerminatedError = 15,
  ProducerBusy = 16,
  InvalidTopicName = 17,
  IncompatibleSchema = 18,
  ConsumerAssignError = 19
};
bool ServerError_IsValid(int value);
const ServerError ServerError_MIN = UnknownError;
const ServerError ServerError_MAX = ConsumerAssignError;
const int ServerError_ARRAYSIZE = ServerError_MAX + 1;

enum AuthMethod {
  AuthMethodNone = 0,
  AuthMethodYcaV1 = 1,
  AuthMethodAthens = 2
};
bool AuthMethod_IsValid(int value);
const AuthMethod AuthMethod_MIN = AuthMethodNone;
const AuthMethod AuthMethod_MAX = AuthMethodAthens;
const int AuthMethod_ARRAYSIZE = AuthMethod_MAX + 1;

enum ProtocolVersion {
  v0 = 0,
  v1 = 1,
  v2 = 2,
  v3 = 3,
  v4 = 4,
  v5 = 5,
  v6 = 6,
  v7 = 7,
  v8 = 8,
  v9 = 9,
  v10 = 10,
  v11 = 11,
  v12 = 12,
  v13 = 13,
  v14 = 14
};
bool ProtocolVersion_IsValid(int value);
const ProtocolVersion ProtocolVersion_MIN = v0;
const ProtocolVersion ProtocolVersion_MAX = v14;
const int ProtocolVersion_ARRAYSIZE = ProtocolVersion_MAX + 1;

// ===================================================================

class Schema : public ::google::protobuf::MessageLite {
 public:
  Schema();
  virtual ~Schema();

  Schema(const Schema& from);

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Schema& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Schema* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Schema* other);

  // implements Message ----------------------------------------------

  Schema* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Schema_Type Type;
  static const Type None = Schema_Type_None;
  static const Type String = Schema_Type_String;
  static const Type Json = Schema_Type_Json;
  static const Type Protobuf = Schema_Type_Protobuf;
  static const Type Avro = Schema_Type_Avro;
  static const Type Bool = Schema_Type_Bool;
  static const Type Int8 = Schema_Type_Int8;
  static const Type Int16 = Schema_Type_Int16;
  static const Type Int32 = Schema_Type_Int32;
  static const Type Int64 = Schema_Type_Int64;
  static const Type Float = Schema_Type_Float;
  static const Type Double = Schema_Type_Double;
  static const Type Date = Schema_Type_Date;
  static const Type Time = Schema_Type_Time;
  static const Type Timestamp = Schema_Type_Timestamp;
  static const Type KeyValue = Schema_Type_KeyValue;
  static inline bool Type_IsValid(int value) {
    return Schema_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Schema_Type_Type_MIN;
  static const Type Type_MAX =
    Schema_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Schema_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bytes schema_data = 3;
  inline bool has_schema_data() const;
  inline void clear_schema_data();
  static const int kSchemaDataFieldNumber = 3;
  inline const ::std::string& schema_data() const;
  inline void set_schema_data(const ::std::string& value);
  inline void set_schema_data(const char* value);
  inline void set_schema_data(const void* value, size_t size);
  inline ::std::string* mutable_schema_data();
  inline ::std::string* release_schema_data();
  inline void set_allocated_schema_data(::std::string* schema_data);

  // required .pulsar.proto.Schema.Type type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::pulsar::proto::Schema_Type type() const;
  inline void set_type(::pulsar::proto::Schema_Type value);

  // repeated .pulsar.proto.KeyValue properties = 5;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 5;
  inline const ::pulsar::proto::KeyValue& properties(int index) const;
  inline ::pulsar::proto::KeyValue* mutable_properties(int index);
  inline ::pulsar::proto::KeyValue* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_properties();

  // @@protoc_insertion_point(class_scope:pulsar.proto.Schema)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_schema_data();
  inline void clear_has_schema_data();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* schema_data_;
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > properties_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static Schema* default_instance_;
};
// -------------------------------------------------------------------

class MessageIdData : public ::google::protobuf::MessageLite {
 public:
  MessageIdData();
  virtual ~MessageIdData();

  MessageIdData(const MessageIdData& from);

  inline MessageIdData& operator=(const MessageIdData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MessageIdData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MessageIdData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MessageIdData* other);

  // implements Message ----------------------------------------------

  MessageIdData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MessageIdData& from);
  void MergeFrom(const MessageIdData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 ledgerId = 1;
  inline bool has_ledgerid() const;
  inline void clear_ledgerid();
  static const int kLedgerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 ledgerid() const;
  inline void set_ledgerid(::google::protobuf::uint64 value);

  // required uint64 entryId = 2;
  inline bool has_entryid() const;
  inline void clear_entryid();
  static const int kEntryIdFieldNumber = 2;
  inline ::google::protobuf::uint64 entryid() const;
  inline void set_entryid(::google::protobuf::uint64 value);

  // optional int32 partition = 3 [default = -1];
  inline bool has_partition() const;
  inline void clear_partition();
  static const int kPartitionFieldNumber = 3;
  inline ::google::protobuf::int32 partition() const;
  inline void set_partition(::google::protobuf::int32 value);

  // optional int32 batch_index = 4 [default = -1];
  inline bool has_batch_index() const;
  inline void clear_batch_index();
  static const int kBatchIndexFieldNumber = 4;
  inline ::google::protobuf::int32 batch_index() const;
  inline void set_batch_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.MessageIdData)
 private:
  inline void set_has_ledgerid();
  inline void clear_has_ledgerid();
  inline void set_has_entryid();
  inline void clear_has_entryid();
  inline void set_has_partition();
  inline void clear_has_partition();
  inline void set_has_batch_index();
  inline void clear_has_batch_index();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 ledgerid_;
  ::google::protobuf::uint64 entryid_;
  ::google::protobuf::int32 partition_;
  ::google::protobuf::int32 batch_index_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static MessageIdData* default_instance_;
};
// -------------------------------------------------------------------

class KeyValue : public ::google::protobuf::MessageLite {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KeyValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KeyValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KeyValue* other);

  // implements Message ----------------------------------------------

  KeyValue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.KeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class KeyLongValue : public ::google::protobuf::MessageLite {
 public:
  KeyLongValue();
  virtual ~KeyLongValue();

  KeyLongValue(const KeyLongValue& from);

  inline KeyLongValue& operator=(const KeyLongValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KeyLongValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KeyLongValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KeyLongValue* other);

  // implements Message ----------------------------------------------

  KeyLongValue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KeyLongValue& from);
  void MergeFrom(const KeyLongValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required uint64 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint64 value() const;
  inline void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.KeyLongValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::google::protobuf::uint64 value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static KeyLongValue* default_instance_;
};
// -------------------------------------------------------------------

class EncryptionKeys : public ::google::protobuf::MessageLite {
 public:
  EncryptionKeys();
  virtual ~EncryptionKeys();

  EncryptionKeys(const EncryptionKeys& from);

  inline EncryptionKeys& operator=(const EncryptionKeys& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EncryptionKeys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EncryptionKeys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EncryptionKeys* other);

  // implements Message ----------------------------------------------

  EncryptionKeys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EncryptionKeys& from);
  void MergeFrom(const EncryptionKeys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // repeated .pulsar.proto.KeyValue metadata = 3;
  inline int metadata_size() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  inline const ::pulsar::proto::KeyValue& metadata(int index) const;
  inline ::pulsar::proto::KeyValue* mutable_metadata(int index);
  inline ::pulsar::proto::KeyValue* add_metadata();
  inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      metadata() const;
  inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_metadata();

  // @@protoc_insertion_point(class_scope:pulsar.proto.EncryptionKeys)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > metadata_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static EncryptionKeys* default_instance_;
};
// -------------------------------------------------------------------

class MessageMetadata : public ::google::protobuf::MessageLite {
 public:
  MessageMetadata();
  virtual ~MessageMetadata();

  MessageMetadata(const MessageMetadata& from);

  inline MessageMetadata& operator=(const MessageMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MessageMetadata& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MessageMetadata* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MessageMetadata* other);

  // implements Message ----------------------------------------------

  MessageMetadata* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MessageMetadata& from);
  void MergeFrom(const MessageMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string producer_name = 1;
  inline bool has_producer_name() const;
  inline void clear_producer_name();
  static const int kProducerNameFieldNumber = 1;
  inline const ::std::string& producer_name() const;
  inline void set_producer_name(const ::std::string& value);
  inline void set_producer_name(const char* value);
  inline void set_producer_name(const char* value, size_t size);
  inline ::std::string* mutable_producer_name();
  inline ::std::string* release_producer_name();
  inline void set_allocated_producer_name(::std::string* producer_name);

  // required uint64 sequence_id = 2;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::uint64 value);

  // required uint64 publish_time = 3;
  inline bool has_publish_time() const;
  inline void clear_publish_time();
  static const int kPublishTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 publish_time() const;
  inline void set_publish_time(::google::protobuf::uint64 value);

  // repeated .pulsar.proto.KeyValue properties = 4;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 4;
  inline const ::pulsar::proto::KeyValue& properties(int index) const;
  inline ::pulsar::proto::KeyValue* mutable_properties(int index);
  inline ::pulsar::proto::KeyValue* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_properties();

  // optional string replicated_from = 5;
  inline bool has_replicated_from() const;
  inline void clear_replicated_from();
  static const int kReplicatedFromFieldNumber = 5;
  inline const ::std::string& replicated_from() const;
  inline void set_replicated_from(const ::std::string& value);
  inline void set_replicated_from(const char* value);
  inline void set_replicated_from(const char* value, size_t size);
  inline ::std::string* mutable_replicated_from();
  inline ::std::string* release_replicated_from();
  inline void set_allocated_replicated_from(::std::string* replicated_from);

  // optional string partition_key = 6;
  inline bool has_partition_key() const;
  inline void clear_partition_key();
  static const int kPartitionKeyFieldNumber = 6;
  inline const ::std::string& partition_key() const;
  inline void set_partition_key(const ::std::string& value);
  inline void set_partition_key(const char* value);
  inline void set_partition_key(const char* value, size_t size);
  inline ::std::string* mutable_partition_key();
  inline ::std::string* release_partition_key();
  inline void set_allocated_partition_key(::std::string* partition_key);

  // repeated string replicate_to = 7;
  inline int replicate_to_size() const;
  inline void clear_replicate_to();
  static const int kReplicateToFieldNumber = 7;
  inline const ::std::string& replicate_to(int index) const;
  inline ::std::string* mutable_replicate_to(int index);
  inline void set_replicate_to(int index, const ::std::string& value);
  inline void set_replicate_to(int index, const char* value);
  inline void set_replicate_to(int index, const char* value, size_t size);
  inline ::std::string* add_replicate_to();
  inline void add_replicate_to(const ::std::string& value);
  inline void add_replicate_to(const char* value);
  inline void add_replicate_to(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& replicate_to() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_replicate_to();

  // optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
  inline bool has_compression() const;
  inline void clear_compression();
  static const int kCompressionFieldNumber = 8;
  inline ::pulsar::proto::CompressionType compression() const;
  inline void set_compression(::pulsar::proto::CompressionType value);

  // optional uint32 uncompressed_size = 9 [default = 0];
  inline bool has_uncompressed_size() const;
  inline void clear_uncompressed_size();
  static const int kUncompressedSizeFieldNumber = 9;
  inline ::google::protobuf::uint32 uncompressed_size() const;
  inline void set_uncompressed_size(::google::protobuf::uint32 value);

  // optional int32 num_messages_in_batch = 11 [default = 1];
  inline bool has_num_messages_in_batch() const;
  inline void clear_num_messages_in_batch();
  static const int kNumMessagesInBatchFieldNumber = 11;
  inline ::google::protobuf::int32 num_messages_in_batch() const;
  inline void set_num_messages_in_batch(::google::protobuf::int32 value);

  // optional uint64 event_time = 12 [default = 0];
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 12;
  inline ::google::protobuf::uint64 event_time() const;
  inline void set_event_time(::google::protobuf::uint64 value);

  // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
  inline int encryption_keys_size() const;
  inline void clear_encryption_keys();
  static const int kEncryptionKeysFieldNumber = 13;
  inline const ::pulsar::proto::EncryptionKeys& encryption_keys(int index) const;
  inline ::pulsar::proto::EncryptionKeys* mutable_encryption_keys(int index);
  inline ::pulsar::proto::EncryptionKeys* add_encryption_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::EncryptionKeys >&
      encryption_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::EncryptionKeys >*
      mutable_encryption_keys();

  // optional string encryption_algo = 14;
  inline bool has_encryption_algo() const;
  inline void clear_encryption_algo();
  static const int kEncryptionAlgoFieldNumber = 14;
  inline const ::std::string& encryption_algo() const;
  inline void set_encryption_algo(const ::std::string& value);
  inline void set_encryption_algo(const char* value);
  inline void set_encryption_algo(const char* value, size_t size);
  inline ::std::string* mutable_encryption_algo();
  inline ::std::string* release_encryption_algo();
  inline void set_allocated_encryption_algo(::std::string* encryption_algo);

  // optional bytes encryption_param = 15;
  inline bool has_encryption_param() const;
  inline void clear_encryption_param();
  static const int kEncryptionParamFieldNumber = 15;
  inline const ::std::string& encryption_param() const;
  inline void set_encryption_param(const ::std::string& value);
  inline void set_encryption_param(const char* value);
  inline void set_encryption_param(const void* value, size_t size);
  inline ::std::string* mutable_encryption_param();
  inline ::std::string* release_encryption_param();
  inline void set_allocated_encryption_param(::std::string* encryption_param);

  // optional bytes schema_version = 16;
  inline bool has_schema_version() const;
  inline void clear_schema_version();
  static const int kSchemaVersionFieldNumber = 16;
  inline const ::std::string& schema_version() const;
  inline void set_schema_version(const ::std::string& value);
  inline void set_schema_version(const char* value);
  inline void set_schema_version(const void* value, size_t size);
  inline ::std::string* mutable_schema_version();
  inline ::std::string* release_schema_version();
  inline void set_allocated_schema_version(::std::string* schema_version);

  // optional bool partition_key_b64_encoded = 17 [default = false];
  inline bool has_partition_key_b64_encoded() const;
  inline void clear_partition_key_b64_encoded();
  static const int kPartitionKeyB64EncodedFieldNumber = 17;
  inline bool partition_key_b64_encoded() const;
  inline void set_partition_key_b64_encoded(bool value);

  // optional bytes ordering_key = 18;
  inline bool has_ordering_key() const;
  inline void clear_ordering_key();
  static const int kOrderingKeyFieldNumber = 18;
  inline const ::std::string& ordering_key() const;
  inline void set_ordering_key(const ::std::string& value);
  inline void set_ordering_key(const char* value);
  inline void set_ordering_key(const void* value, size_t size);
  inline ::std::string* mutable_ordering_key();
  inline ::std::string* release_ordering_key();
  inline void set_allocated_ordering_key(::std::string* ordering_key);

  // optional int64 deliver_at_time = 19;
  inline bool has_deliver_at_time() const;
  inline void clear_deliver_at_time();
  static const int kDeliverAtTimeFieldNumber = 19;
  inline ::google::protobuf::int64 deliver_at_time() const;
  inline void set_deliver_at_time(::google::protobuf::int64 value);

  // optional int32 marker_type = 20;
  inline bool has_marker_type() const;
  inline void clear_marker_type();
  static const int kMarkerTypeFieldNumber = 20;
  inline ::google::protobuf::int32 marker_type() const;
  inline void set_marker_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.MessageMetadata)
 private:
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_publish_time();
  inline void clear_has_publish_time();
  inline void set_has_replicated_from();
  inline void clear_has_replicated_from();
  inline void set_has_partition_key();
  inline void clear_has_partition_key();
  inline void set_has_compression();
  inline void clear_has_compression();
  inline void set_has_uncompressed_size();
  inline void clear_has_uncompressed_size();
  inline void set_has_num_messages_in_batch();
  inline void clear_has_num_messages_in_batch();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_encryption_algo();
  inline void clear_has_encryption_algo();
  inline void set_has_encryption_param();
  inline void clear_has_encryption_param();
  inline void set_has_schema_version();
  inline void clear_has_schema_version();
  inline void set_has_partition_key_b64_encoded();
  inline void clear_has_partition_key_b64_encoded();
  inline void set_has_ordering_key();
  inline void clear_has_ordering_key();
  inline void set_has_deliver_at_time();
  inline void clear_has_deliver_at_time();
  inline void set_has_marker_type();
  inline void clear_has_marker_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* producer_name_;
  ::google::protobuf::uint64 sequence_id_;
  ::google::protobuf::uint64 publish_time_;
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > properties_;
  ::std::string* replicated_from_;
  ::std::string* partition_key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> replicate_to_;
  int compression_;
  ::google::protobuf::uint32 uncompressed_size_;
  ::google::protobuf::uint64 event_time_;
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::EncryptionKeys > encryption_keys_;
  ::std::string* encryption_algo_;
  ::google::protobuf::int32 num_messages_in_batch_;
  bool partition_key_b64_encoded_;
  ::std::string* encryption_param_;
  ::std::string* schema_version_;
  ::std::string* ordering_key_;
  ::google::protobuf::int64 deliver_at_time_;
  ::google::protobuf::int32 marker_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static MessageMetadata* default_instance_;
};
// -------------------------------------------------------------------

class SingleMessageMetadata : public ::google::protobuf::MessageLite {
 public:
  SingleMessageMetadata();
  virtual ~SingleMessageMetadata();

  SingleMessageMetadata(const SingleMessageMetadata& from);

  inline SingleMessageMetadata& operator=(const SingleMessageMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SingleMessageMetadata& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SingleMessageMetadata* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SingleMessageMetadata* other);

  // implements Message ----------------------------------------------

  SingleMessageMetadata* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SingleMessageMetadata& from);
  void MergeFrom(const SingleMessageMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pulsar.proto.KeyValue properties = 1;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 1;
  inline const ::pulsar::proto::KeyValue& properties(int index) const;
  inline ::pulsar::proto::KeyValue* mutable_properties(int index);
  inline ::pulsar::proto::KeyValue* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_properties();

  // optional string partition_key = 2;
  inline bool has_partition_key() const;
  inline void clear_partition_key();
  static const int kPartitionKeyFieldNumber = 2;
  inline const ::std::string& partition_key() const;
  inline void set_partition_key(const ::std::string& value);
  inline void set_partition_key(const char* value);
  inline void set_partition_key(const char* value, size_t size);
  inline ::std::string* mutable_partition_key();
  inline ::std::string* release_partition_key();
  inline void set_allocated_partition_key(::std::string* partition_key);

  // required int32 payload_size = 3;
  inline bool has_payload_size() const;
  inline void clear_payload_size();
  static const int kPayloadSizeFieldNumber = 3;
  inline ::google::protobuf::int32 payload_size() const;
  inline void set_payload_size(::google::protobuf::int32 value);

  // optional bool compacted_out = 4 [default = false];
  inline bool has_compacted_out() const;
  inline void clear_compacted_out();
  static const int kCompactedOutFieldNumber = 4;
  inline bool compacted_out() const;
  inline void set_compacted_out(bool value);

  // optional uint64 event_time = 5 [default = 0];
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 event_time() const;
  inline void set_event_time(::google::protobuf::uint64 value);

  // optional bool partition_key_b64_encoded = 6 [default = false];
  inline bool has_partition_key_b64_encoded() const;
  inline void clear_partition_key_b64_encoded();
  static const int kPartitionKeyB64EncodedFieldNumber = 6;
  inline bool partition_key_b64_encoded() const;
  inline void set_partition_key_b64_encoded(bool value);

  // optional bytes ordering_key = 7;
  inline bool has_ordering_key() const;
  inline void clear_ordering_key();
  static const int kOrderingKeyFieldNumber = 7;
  inline const ::std::string& ordering_key() const;
  inline void set_ordering_key(const ::std::string& value);
  inline void set_ordering_key(const char* value);
  inline void set_ordering_key(const void* value, size_t size);
  inline ::std::string* mutable_ordering_key();
  inline ::std::string* release_ordering_key();
  inline void set_allocated_ordering_key(::std::string* ordering_key);

  // @@protoc_insertion_point(class_scope:pulsar.proto.SingleMessageMetadata)
 private:
  inline void set_has_partition_key();
  inline void clear_has_partition_key();
  inline void set_has_payload_size();
  inline void clear_has_payload_size();
  inline void set_has_compacted_out();
  inline void clear_has_compacted_out();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_partition_key_b64_encoded();
  inline void clear_has_partition_key_b64_encoded();
  inline void set_has_ordering_key();
  inline void clear_has_ordering_key();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > properties_;
  ::std::string* partition_key_;
  ::google::protobuf::int32 payload_size_;
  bool compacted_out_;
  bool partition_key_b64_encoded_;
  ::google::protobuf::uint64 event_time_;
  ::std::string* ordering_key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static SingleMessageMetadata* default_instance_;
};
// -------------------------------------------------------------------

class CommandConnect : public ::google::protobuf::MessageLite {
 public:
  CommandConnect();
  virtual ~CommandConnect();

  CommandConnect(const CommandConnect& from);

  inline CommandConnect& operator=(const CommandConnect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandConnect& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandConnect* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandConnect* other);

  // implements Message ----------------------------------------------

  CommandConnect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandConnect& from);
  void MergeFrom(const CommandConnect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_version = 1;
  inline bool has_client_version() const;
  inline void clear_client_version();
  static const int kClientVersionFieldNumber = 1;
  inline const ::std::string& client_version() const;
  inline void set_client_version(const ::std::string& value);
  inline void set_client_version(const char* value);
  inline void set_client_version(const char* value, size_t size);
  inline ::std::string* mutable_client_version();
  inline ::std::string* release_client_version();
  inline void set_allocated_client_version(::std::string* client_version);

  // optional .pulsar.proto.AuthMethod auth_method = 2;
  inline bool has_auth_method() const;
  inline void clear_auth_method();
  static const int kAuthMethodFieldNumber = 2;
  inline ::pulsar::proto::AuthMethod auth_method() const;
  inline void set_auth_method(::pulsar::proto::AuthMethod value);

  // optional string auth_method_name = 5;
  inline bool has_auth_method_name() const;
  inline void clear_auth_method_name();
  static const int kAuthMethodNameFieldNumber = 5;
  inline const ::std::string& auth_method_name() const;
  inline void set_auth_method_name(const ::std::string& value);
  inline void set_auth_method_name(const char* value);
  inline void set_auth_method_name(const char* value, size_t size);
  inline ::std::string* mutable_auth_method_name();
  inline ::std::string* release_auth_method_name();
  inline void set_allocated_auth_method_name(::std::string* auth_method_name);

  // optional bytes auth_data = 3;
  inline bool has_auth_data() const;
  inline void clear_auth_data();
  static const int kAuthDataFieldNumber = 3;
  inline const ::std::string& auth_data() const;
  inline void set_auth_data(const ::std::string& value);
  inline void set_auth_data(const char* value);
  inline void set_auth_data(const void* value, size_t size);
  inline ::std::string* mutable_auth_data();
  inline ::std::string* release_auth_data();
  inline void set_allocated_auth_data(::std::string* auth_data);

  // optional int32 protocol_version = 4 [default = 0];
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 4;
  inline ::google::protobuf::int32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::int32 value);

  // optional string proxy_to_broker_url = 6;
  inline bool has_proxy_to_broker_url() const;
  inline void clear_proxy_to_broker_url();
  static const int kProxyToBrokerUrlFieldNumber = 6;
  inline const ::std::string& proxy_to_broker_url() const;
  inline void set_proxy_to_broker_url(const ::std::string& value);
  inline void set_proxy_to_broker_url(const char* value);
  inline void set_proxy_to_broker_url(const char* value, size_t size);
  inline ::std::string* mutable_proxy_to_broker_url();
  inline ::std::string* release_proxy_to_broker_url();
  inline void set_allocated_proxy_to_broker_url(::std::string* proxy_to_broker_url);

  // optional string original_principal = 7;
  inline bool has_original_principal() const;
  inline void clear_original_principal();
  static const int kOriginalPrincipalFieldNumber = 7;
  inline const ::std::string& original_principal() const;
  inline void set_original_principal(const ::std::string& value);
  inline void set_original_principal(const char* value);
  inline void set_original_principal(const char* value, size_t size);
  inline ::std::string* mutable_original_principal();
  inline ::std::string* release_original_principal();
  inline void set_allocated_original_principal(::std::string* original_principal);

  // optional string original_auth_data = 8;
  inline bool has_original_auth_data() const;
  inline void clear_original_auth_data();
  static const int kOriginalAuthDataFieldNumber = 8;
  inline const ::std::string& original_auth_data() const;
  inline void set_original_auth_data(const ::std::string& value);
  inline void set_original_auth_data(const char* value);
  inline void set_original_auth_data(const char* value, size_t size);
  inline ::std::string* mutable_original_auth_data();
  inline ::std::string* release_original_auth_data();
  inline void set_allocated_original_auth_data(::std::string* original_auth_data);

  // optional string original_auth_method = 9;
  inline bool has_original_auth_method() const;
  inline void clear_original_auth_method();
  static const int kOriginalAuthMethodFieldNumber = 9;
  inline const ::std::string& original_auth_method() const;
  inline void set_original_auth_method(const ::std::string& value);
  inline void set_original_auth_method(const char* value);
  inline void set_original_auth_method(const char* value, size_t size);
  inline ::std::string* mutable_original_auth_method();
  inline ::std::string* release_original_auth_method();
  inline void set_allocated_original_auth_method(::std::string* original_auth_method);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConnect)
 private:
  inline void set_has_client_version();
  inline void clear_has_client_version();
  inline void set_has_auth_method();
  inline void clear_has_auth_method();
  inline void set_has_auth_method_name();
  inline void clear_has_auth_method_name();
  inline void set_has_auth_data();
  inline void clear_has_auth_data();
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_proxy_to_broker_url();
  inline void clear_has_proxy_to_broker_url();
  inline void set_has_original_principal();
  inline void clear_has_original_principal();
  inline void set_has_original_auth_data();
  inline void clear_has_original_auth_data();
  inline void set_has_original_auth_method();
  inline void clear_has_original_auth_method();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_version_;
  ::std::string* auth_method_name_;
  int auth_method_;
  ::google::protobuf::int32 protocol_version_;
  ::std::string* auth_data_;
  ::std::string* proxy_to_broker_url_;
  ::std::string* original_principal_;
  ::std::string* original_auth_data_;
  ::std::string* original_auth_method_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandConnect* default_instance_;
};
// -------------------------------------------------------------------

class CommandConnected : public ::google::protobuf::MessageLite {
 public:
  CommandConnected();
  virtual ~CommandConnected();

  CommandConnected(const CommandConnected& from);

  inline CommandConnected& operator=(const CommandConnected& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandConnected& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandConnected* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandConnected* other);

  // implements Message ----------------------------------------------

  CommandConnected* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandConnected& from);
  void MergeFrom(const CommandConnected& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string server_version = 1;
  inline bool has_server_version() const;
  inline void clear_server_version();
  static const int kServerVersionFieldNumber = 1;
  inline const ::std::string& server_version() const;
  inline void set_server_version(const ::std::string& value);
  inline void set_server_version(const char* value);
  inline void set_server_version(const char* value, size_t size);
  inline ::std::string* mutable_server_version();
  inline ::std::string* release_server_version();
  inline void set_allocated_server_version(::std::string* server_version);

  // optional int32 protocol_version = 2 [default = 0];
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 2;
  inline ::google::protobuf::int32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::int32 value);

  // optional int32 max_message_size = 3;
  inline bool has_max_message_size() const;
  inline void clear_max_message_size();
  static const int kMaxMessageSizeFieldNumber = 3;
  inline ::google::protobuf::int32 max_message_size() const;
  inline void set_max_message_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConnected)
 private:
  inline void set_has_server_version();
  inline void clear_has_server_version();
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_max_message_size();
  inline void clear_has_max_message_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* server_version_;
  ::google::protobuf::int32 protocol_version_;
  ::google::protobuf::int32 max_message_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandConnected* default_instance_;
};
// -------------------------------------------------------------------

class CommandAuthResponse : public ::google::protobuf::MessageLite {
 public:
  CommandAuthResponse();
  virtual ~CommandAuthResponse();

  CommandAuthResponse(const CommandAuthResponse& from);

  inline CommandAuthResponse& operator=(const CommandAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandAuthResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandAuthResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandAuthResponse* other);

  // implements Message ----------------------------------------------

  CommandAuthResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandAuthResponse& from);
  void MergeFrom(const CommandAuthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string client_version = 1;
  inline bool has_client_version() const;
  inline void clear_client_version();
  static const int kClientVersionFieldNumber = 1;
  inline const ::std::string& client_version() const;
  inline void set_client_version(const ::std::string& value);
  inline void set_client_version(const char* value);
  inline void set_client_version(const char* value, size_t size);
  inline ::std::string* mutable_client_version();
  inline ::std::string* release_client_version();
  inline void set_allocated_client_version(::std::string* client_version);

  // optional .pulsar.proto.AuthData response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::pulsar::proto::AuthData& response() const;
  inline ::pulsar::proto::AuthData* mutable_response();
  inline ::pulsar::proto::AuthData* release_response();
  inline void set_allocated_response(::pulsar::proto::AuthData* response);

  // optional int32 protocol_version = 3 [default = 0];
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 3;
  inline ::google::protobuf::int32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAuthResponse)
 private:
  inline void set_has_client_version();
  inline void clear_has_client_version();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_version_;
  ::pulsar::proto::AuthData* response_;
  ::google::protobuf::int32 protocol_version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandAuthResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommandAuthChallenge : public ::google::protobuf::MessageLite {
 public:
  CommandAuthChallenge();
  virtual ~CommandAuthChallenge();

  CommandAuthChallenge(const CommandAuthChallenge& from);

  inline CommandAuthChallenge& operator=(const CommandAuthChallenge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandAuthChallenge& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandAuthChallenge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandAuthChallenge* other);

  // implements Message ----------------------------------------------

  CommandAuthChallenge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandAuthChallenge& from);
  void MergeFrom(const CommandAuthChallenge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string server_version = 1;
  inline bool has_server_version() const;
  inline void clear_server_version();
  static const int kServerVersionFieldNumber = 1;
  inline const ::std::string& server_version() const;
  inline void set_server_version(const ::std::string& value);
  inline void set_server_version(const char* value);
  inline void set_server_version(const char* value, size_t size);
  inline ::std::string* mutable_server_version();
  inline ::std::string* release_server_version();
  inline void set_allocated_server_version(::std::string* server_version);

  // optional .pulsar.proto.AuthData challenge = 2;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 2;
  inline const ::pulsar::proto::AuthData& challenge() const;
  inline ::pulsar::proto::AuthData* mutable_challenge();
  inline ::pulsar::proto::AuthData* release_challenge();
  inline void set_allocated_challenge(::pulsar::proto::AuthData* challenge);

  // optional int32 protocol_version = 3 [default = 0];
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 3;
  inline ::google::protobuf::int32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAuthChallenge)
 private:
  inline void set_has_server_version();
  inline void clear_has_server_version();
  inline void set_has_challenge();
  inline void clear_has_challenge();
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* server_version_;
  ::pulsar::proto::AuthData* challenge_;
  ::google::protobuf::int32 protocol_version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandAuthChallenge* default_instance_;
};
// -------------------------------------------------------------------

class AuthData : public ::google::protobuf::MessageLite {
 public:
  AuthData();
  virtual ~AuthData();

  AuthData(const AuthData& from);

  inline AuthData& operator=(const AuthData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthData* other);

  // implements Message ----------------------------------------------

  AuthData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthData& from);
  void MergeFrom(const AuthData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string auth_method_name = 1;
  inline bool has_auth_method_name() const;
  inline void clear_auth_method_name();
  static const int kAuthMethodNameFieldNumber = 1;
  inline const ::std::string& auth_method_name() const;
  inline void set_auth_method_name(const ::std::string& value);
  inline void set_auth_method_name(const char* value);
  inline void set_auth_method_name(const char* value, size_t size);
  inline ::std::string* mutable_auth_method_name();
  inline ::std::string* release_auth_method_name();
  inline void set_allocated_auth_method_name(::std::string* auth_method_name);

  // optional bytes auth_data = 2;
  inline bool has_auth_data() const;
  inline void clear_auth_data();
  static const int kAuthDataFieldNumber = 2;
  inline const ::std::string& auth_data() const;
  inline void set_auth_data(const ::std::string& value);
  inline void set_auth_data(const char* value);
  inline void set_auth_data(const void* value, size_t size);
  inline ::std::string* mutable_auth_data();
  inline ::std::string* release_auth_data();
  inline void set_allocated_auth_data(::std::string* auth_data);

  // @@protoc_insertion_point(class_scope:pulsar.proto.AuthData)
 private:
  inline void set_has_auth_method_name();
  inline void clear_has_auth_method_name();
  inline void set_has_auth_data();
  inline void clear_has_auth_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* auth_method_name_;
  ::std::string* auth_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static AuthData* default_instance_;
};
// -------------------------------------------------------------------

class CommandSubscribe : public ::google::protobuf::MessageLite {
 public:
  CommandSubscribe();
  virtual ~CommandSubscribe();

  CommandSubscribe(const CommandSubscribe& from);

  inline CommandSubscribe& operator=(const CommandSubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandSubscribe& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandSubscribe* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandSubscribe* other);

  // implements Message ----------------------------------------------

  CommandSubscribe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandSubscribe& from);
  void MergeFrom(const CommandSubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommandSubscribe_SubType SubType;
  static const SubType Exclusive = CommandSubscribe_SubType_Exclusive;
  static const SubType Shared = CommandSubscribe_SubType_Shared;
  static const SubType Failover = CommandSubscribe_SubType_Failover;
  static const SubType Key_Shared = CommandSubscribe_SubType_Key_Shared;
  static inline bool SubType_IsValid(int value) {
    return CommandSubscribe_SubType_IsValid(value);
  }
  static const SubType SubType_MIN =
    CommandSubscribe_SubType_SubType_MIN;
  static const SubType SubType_MAX =
    CommandSubscribe_SubType_SubType_MAX;
  static const int SubType_ARRAYSIZE =
    CommandSubscribe_SubType_SubType_ARRAYSIZE;

  typedef CommandSubscribe_InitialPosition InitialPosition;
  static const InitialPosition Latest = CommandSubscribe_InitialPosition_Latest;
  static const InitialPosition Earliest = CommandSubscribe_InitialPosition_Earliest;
  static inline bool InitialPosition_IsValid(int value) {
    return CommandSubscribe_InitialPosition_IsValid(value);
  }
  static const InitialPosition InitialPosition_MIN =
    CommandSubscribe_InitialPosition_InitialPosition_MIN;
  static const InitialPosition InitialPosition_MAX =
    CommandSubscribe_InitialPosition_InitialPosition_MAX;
  static const int InitialPosition_ARRAYSIZE =
    CommandSubscribe_InitialPosition_InitialPosition_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string topic = 1;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 1;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // required string subscription = 2;
  inline bool has_subscription() const;
  inline void clear_subscription();
  static const int kSubscriptionFieldNumber = 2;
  inline const ::std::string& subscription() const;
  inline void set_subscription(const ::std::string& value);
  inline void set_subscription(const char* value);
  inline void set_subscription(const char* value, size_t size);
  inline ::std::string* mutable_subscription();
  inline ::std::string* release_subscription();
  inline void set_allocated_subscription(::std::string* subscription);

  // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubTypeFieldNumber = 3;
  inline ::pulsar::proto::CommandSubscribe_SubType subtype() const;
  inline void set_subtype(::pulsar::proto::CommandSubscribe_SubType value);

  // required uint64 consumer_id = 4;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 4;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // required uint64 request_id = 5;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 5;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional string consumer_name = 6;
  inline bool has_consumer_name() const;
  inline void clear_consumer_name();
  static const int kConsumerNameFieldNumber = 6;
  inline const ::std::string& consumer_name() const;
  inline void set_consumer_name(const ::std::string& value);
  inline void set_consumer_name(const char* value);
  inline void set_consumer_name(const char* value, size_t size);
  inline ::std::string* mutable_consumer_name();
  inline ::std::string* release_consumer_name();
  inline void set_allocated_consumer_name(::std::string* consumer_name);

  // optional int32 priority_level = 7;
  inline bool has_priority_level() const;
  inline void clear_priority_level();
  static const int kPriorityLevelFieldNumber = 7;
  inline ::google::protobuf::int32 priority_level() const;
  inline void set_priority_level(::google::protobuf::int32 value);

  // optional bool durable = 8 [default = true];
  inline bool has_durable() const;
  inline void clear_durable();
  static const int kDurableFieldNumber = 8;
  inline bool durable() const;
  inline void set_durable(bool value);

  // optional .pulsar.proto.MessageIdData start_message_id = 9;
  inline bool has_start_message_id() const;
  inline void clear_start_message_id();
  static const int kStartMessageIdFieldNumber = 9;
  inline const ::pulsar::proto::MessageIdData& start_message_id() const;
  inline ::pulsar::proto::MessageIdData* mutable_start_message_id();
  inline ::pulsar::proto::MessageIdData* release_start_message_id();
  inline void set_allocated_start_message_id(::pulsar::proto::MessageIdData* start_message_id);

  // repeated .pulsar.proto.KeyValue metadata = 10;
  inline int metadata_size() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 10;
  inline const ::pulsar::proto::KeyValue& metadata(int index) const;
  inline ::pulsar::proto::KeyValue* mutable_metadata(int index);
  inline ::pulsar::proto::KeyValue* add_metadata();
  inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      metadata() const;
  inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_metadata();

  // optional bool read_compacted = 11;
  inline bool has_read_compacted() const;
  inline void clear_read_compacted();
  static const int kReadCompactedFieldNumber = 11;
  inline bool read_compacted() const;
  inline void set_read_compacted(bool value);

  // optional .pulsar.proto.Schema schema = 12;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 12;
  inline const ::pulsar::proto::Schema& schema() const;
  inline ::pulsar::proto::Schema* mutable_schema();
  inline ::pulsar::proto::Schema* release_schema();
  inline void set_allocated_schema(::pulsar::proto::Schema* schema);

  // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
  inline bool has_initialposition() const;
  inline void clear_initialposition();
  static const int kInitialPositionFieldNumber = 13;
  inline ::pulsar::proto::CommandSubscribe_InitialPosition initialposition() const;
  inline void set_initialposition(::pulsar::proto::CommandSubscribe_InitialPosition value);

  // optional bool replicate_subscription_state = 14;
  inline bool has_replicate_subscription_state() const;
  inline void clear_replicate_subscription_state();
  static const int kReplicateSubscriptionStateFieldNumber = 14;
  inline bool replicate_subscription_state() const;
  inline void set_replicate_subscription_state(bool value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSubscribe)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_subscription();
  inline void clear_has_subscription();
  inline void set_has_subtype();
  inline void clear_has_subtype();
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_consumer_name();
  inline void clear_has_consumer_name();
  inline void set_has_priority_level();
  inline void clear_has_priority_level();
  inline void set_has_durable();
  inline void clear_has_durable();
  inline void set_has_start_message_id();
  inline void clear_has_start_message_id();
  inline void set_has_read_compacted();
  inline void clear_has_read_compacted();
  inline void set_has_schema();
  inline void clear_has_schema();
  inline void set_has_initialposition();
  inline void clear_has_initialposition();
  inline void set_has_replicate_subscription_state();
  inline void clear_has_replicate_subscription_state();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* topic_;
  ::std::string* subscription_;
  ::google::protobuf::uint64 consumer_id_;
  ::google::protobuf::uint64 request_id_;
  int subtype_;
  ::google::protobuf::int32 priority_level_;
  ::std::string* consumer_name_;
  ::pulsar::proto::MessageIdData* start_message_id_;
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > metadata_;
  bool durable_;
  bool read_compacted_;
  bool replicate_subscription_state_;
  int initialposition_;
  ::pulsar::proto::Schema* schema_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandSubscribe* default_instance_;
};
// -------------------------------------------------------------------

class CommandPartitionedTopicMetadata : public ::google::protobuf::MessageLite {
 public:
  CommandPartitionedTopicMetadata();
  virtual ~CommandPartitionedTopicMetadata();

  CommandPartitionedTopicMetadata(const CommandPartitionedTopicMetadata& from);

  inline CommandPartitionedTopicMetadata& operator=(const CommandPartitionedTopicMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandPartitionedTopicMetadata& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandPartitionedTopicMetadata* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandPartitionedTopicMetadata* other);

  // implements Message ----------------------------------------------

  CommandPartitionedTopicMetadata* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandPartitionedTopicMetadata& from);
  void MergeFrom(const CommandPartitionedTopicMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic = 1;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 1;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // required uint64 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional string original_principal = 3;
  inline bool has_original_principal() const;
  inline void clear_original_principal();
  static const int kOriginalPrincipalFieldNumber = 3;
  inline const ::std::string& original_principal() const;
  inline void set_original_principal(const ::std::string& value);
  inline void set_original_principal(const char* value);
  inline void set_original_principal(const char* value, size_t size);
  inline ::std::string* mutable_original_principal();
  inline ::std::string* release_original_principal();
  inline void set_allocated_original_principal(::std::string* original_principal);

  // optional string original_auth_data = 4;
  inline bool has_original_auth_data() const;
  inline void clear_original_auth_data();
  static const int kOriginalAuthDataFieldNumber = 4;
  inline const ::std::string& original_auth_data() const;
  inline void set_original_auth_data(const ::std::string& value);
  inline void set_original_auth_data(const char* value);
  inline void set_original_auth_data(const char* value, size_t size);
  inline ::std::string* mutable_original_auth_data();
  inline ::std::string* release_original_auth_data();
  inline void set_allocated_original_auth_data(::std::string* original_auth_data);

  // optional string original_auth_method = 5;
  inline bool has_original_auth_method() const;
  inline void clear_original_auth_method();
  static const int kOriginalAuthMethodFieldNumber = 5;
  inline const ::std::string& original_auth_method() const;
  inline void set_original_auth_method(const ::std::string& value);
  inline void set_original_auth_method(const char* value);
  inline void set_original_auth_method(const char* value, size_t size);
  inline ::std::string* mutable_original_auth_method();
  inline ::std::string* release_original_auth_method();
  inline void set_allocated_original_auth_method(::std::string* original_auth_method);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPartitionedTopicMetadata)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_original_principal();
  inline void clear_has_original_principal();
  inline void set_has_original_auth_data();
  inline void clear_has_original_auth_data();
  inline void set_has_original_auth_method();
  inline void clear_has_original_auth_method();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* topic_;
  ::google::protobuf::uint64 request_id_;
  ::std::string* original_principal_;
  ::std::string* original_auth_data_;
  ::std::string* original_auth_method_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandPartitionedTopicMetadata* default_instance_;
};
// -------------------------------------------------------------------

class CommandPartitionedTopicMetadataResponse : public ::google::protobuf::MessageLite {
 public:
  CommandPartitionedTopicMetadataResponse();
  virtual ~CommandPartitionedTopicMetadataResponse();

  CommandPartitionedTopicMetadataResponse(const CommandPartitionedTopicMetadataResponse& from);

  inline CommandPartitionedTopicMetadataResponse& operator=(const CommandPartitionedTopicMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandPartitionedTopicMetadataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandPartitionedTopicMetadataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandPartitionedTopicMetadataResponse* other);

  // implements Message ----------------------------------------------

  CommandPartitionedTopicMetadataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandPartitionedTopicMetadataResponse& from);
  void MergeFrom(const CommandPartitionedTopicMetadataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommandPartitionedTopicMetadataResponse_LookupType LookupType;
  static const LookupType Success = CommandPartitionedTopicMetadataResponse_LookupType_Success;
  static const LookupType Failed = CommandPartitionedTopicMetadataResponse_LookupType_Failed;
  static inline bool LookupType_IsValid(int value) {
    return CommandPartitionedTopicMetadataResponse_LookupType_IsValid(value);
  }
  static const LookupType LookupType_MIN =
    CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MIN;
  static const LookupType LookupType_MAX =
    CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MAX;
  static const int LookupType_ARRAYSIZE =
    CommandPartitionedTopicMetadataResponse_LookupType_LookupType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 partitions = 1;
  inline bool has_partitions() const;
  inline void clear_partitions();
  static const int kPartitionsFieldNumber = 1;
  inline ::google::protobuf::uint32 partitions() const;
  inline void set_partitions(::google::protobuf::uint32 value);

  // required uint64 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 3;
  inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType response() const;
  inline void set_response(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType value);

  // optional .pulsar.proto.ServerError error = 4;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 4;
  inline ::pulsar::proto::ServerError error() const;
  inline void set_error(::pulsar::proto::ServerError value);

  // optional string message = 5;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 5;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPartitionedTopicMetadataResponse)
 private:
  inline void set_has_partitions();
  inline void clear_has_partitions();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::google::protobuf::uint32 partitions_;
  int response_;
  ::std::string* message_;
  int error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandPartitionedTopicMetadataResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommandLookupTopic : public ::google::protobuf::MessageLite {
 public:
  CommandLookupTopic();
  virtual ~CommandLookupTopic();

  CommandLookupTopic(const CommandLookupTopic& from);

  inline CommandLookupTopic& operator=(const CommandLookupTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandLookupTopic& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandLookupTopic* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandLookupTopic* other);

  // implements Message ----------------------------------------------

  CommandLookupTopic* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandLookupTopic& from);
  void MergeFrom(const CommandLookupTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic = 1;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 1;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // required uint64 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional bool authoritative = 3 [default = false];
  inline bool has_authoritative() const;
  inline void clear_authoritative();
  static const int kAuthoritativeFieldNumber = 3;
  inline bool authoritative() const;
  inline void set_authoritative(bool value);

  // optional string original_principal = 4;
  inline bool has_original_principal() const;
  inline void clear_original_principal();
  static const int kOriginalPrincipalFieldNumber = 4;
  inline const ::std::string& original_principal() const;
  inline void set_original_principal(const ::std::string& value);
  inline void set_original_principal(const char* value);
  inline void set_original_principal(const char* value, size_t size);
  inline ::std::string* mutable_original_principal();
  inline ::std::string* release_original_principal();
  inline void set_allocated_original_principal(::std::string* original_principal);

  // optional string original_auth_data = 5;
  inline bool has_original_auth_data() const;
  inline void clear_original_auth_data();
  static const int kOriginalAuthDataFieldNumber = 5;
  inline const ::std::string& original_auth_data() const;
  inline void set_original_auth_data(const ::std::string& value);
  inline void set_original_auth_data(const char* value);
  inline void set_original_auth_data(const char* value, size_t size);
  inline ::std::string* mutable_original_auth_data();
  inline ::std::string* release_original_auth_data();
  inline void set_allocated_original_auth_data(::std::string* original_auth_data);

  // optional string original_auth_method = 6;
  inline bool has_original_auth_method() const;
  inline void clear_original_auth_method();
  static const int kOriginalAuthMethodFieldNumber = 6;
  inline const ::std::string& original_auth_method() const;
  inline void set_original_auth_method(const ::std::string& value);
  inline void set_original_auth_method(const char* value);
  inline void set_original_auth_method(const char* value, size_t size);
  inline ::std::string* mutable_original_auth_method();
  inline ::std::string* release_original_auth_method();
  inline void set_allocated_original_auth_method(::std::string* original_auth_method);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandLookupTopic)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_authoritative();
  inline void clear_has_authoritative();
  inline void set_has_original_principal();
  inline void clear_has_original_principal();
  inline void set_has_original_auth_data();
  inline void clear_has_original_auth_data();
  inline void set_has_original_auth_method();
  inline void clear_has_original_auth_method();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* topic_;
  ::google::protobuf::uint64 request_id_;
  ::std::string* original_principal_;
  ::std::string* original_auth_data_;
  ::std::string* original_auth_method_;
  bool authoritative_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandLookupTopic* default_instance_;
};
// -------------------------------------------------------------------

class CommandLookupTopicResponse : public ::google::protobuf::MessageLite {
 public:
  CommandLookupTopicResponse();
  virtual ~CommandLookupTopicResponse();

  CommandLookupTopicResponse(const CommandLookupTopicResponse& from);

  inline CommandLookupTopicResponse& operator=(const CommandLookupTopicResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandLookupTopicResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandLookupTopicResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandLookupTopicResponse* other);

  // implements Message ----------------------------------------------

  CommandLookupTopicResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandLookupTopicResponse& from);
  void MergeFrom(const CommandLookupTopicResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommandLookupTopicResponse_LookupType LookupType;
  static const LookupType Redirect = CommandLookupTopicResponse_LookupType_Redirect;
  static const LookupType Connect = CommandLookupTopicResponse_LookupType_Connect;
  static const LookupType Failed = CommandLookupTopicResponse_LookupType_Failed;
  static inline bool LookupType_IsValid(int value) {
    return CommandLookupTopicResponse_LookupType_IsValid(value);
  }
  static const LookupType LookupType_MIN =
    CommandLookupTopicResponse_LookupType_LookupType_MIN;
  static const LookupType LookupType_MAX =
    CommandLookupTopicResponse_LookupType_LookupType_MAX;
  static const int LookupType_ARRAYSIZE =
    CommandLookupTopicResponse_LookupType_LookupType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string brokerServiceUrl = 1;
  inline bool has_brokerserviceurl() const;
  inline void clear_brokerserviceurl();
  static const int kBrokerServiceUrlFieldNumber = 1;
  inline const ::std::string& brokerserviceurl() const;
  inline void set_brokerserviceurl(const ::std::string& value);
  inline void set_brokerserviceurl(const char* value);
  inline void set_brokerserviceurl(const char* value, size_t size);
  inline ::std::string* mutable_brokerserviceurl();
  inline ::std::string* release_brokerserviceurl();
  inline void set_allocated_brokerserviceurl(::std::string* brokerserviceurl);

  // optional string brokerServiceUrlTls = 2;
  inline bool has_brokerserviceurltls() const;
  inline void clear_brokerserviceurltls();
  static const int kBrokerServiceUrlTlsFieldNumber = 2;
  inline const ::std::string& brokerserviceurltls() const;
  inline void set_brokerserviceurltls(const ::std::string& value);
  inline void set_brokerserviceurltls(const char* value);
  inline void set_brokerserviceurltls(const char* value, size_t size);
  inline ::std::string* mutable_brokerserviceurltls();
  inline ::std::string* release_brokerserviceurltls();
  inline void set_allocated_brokerserviceurltls(::std::string* brokerserviceurltls);

  // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 3;
  inline ::pulsar::proto::CommandLookupTopicResponse_LookupType response() const;
  inline void set_response(::pulsar::proto::CommandLookupTopicResponse_LookupType value);

  // required uint64 request_id = 4;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 4;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional bool authoritative = 5 [default = false];
  inline bool has_authoritative() const;
  inline void clear_authoritative();
  static const int kAuthoritativeFieldNumber = 5;
  inline bool authoritative() const;
  inline void set_authoritative(bool value);

  // optional .pulsar.proto.ServerError error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline ::pulsar::proto::ServerError error() const;
  inline void set_error(::pulsar::proto::ServerError value);

  // optional string message = 7;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 7;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional bool proxy_through_service_url = 8 [default = false];
  inline bool has_proxy_through_service_url() const;
  inline void clear_proxy_through_service_url();
  static const int kProxyThroughServiceUrlFieldNumber = 8;
  inline bool proxy_through_service_url() const;
  inline void set_proxy_through_service_url(bool value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandLookupTopicResponse)
 private:
  inline void set_has_brokerserviceurl();
  inline void clear_has_brokerserviceurl();
  inline void set_has_brokerserviceurltls();
  inline void clear_has_brokerserviceurltls();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_authoritative();
  inline void clear_has_authoritative();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_proxy_through_service_url();
  inline void clear_has_proxy_through_service_url();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* brokerserviceurl_;
  ::std::string* brokerserviceurltls_;
  ::google::protobuf::uint64 request_id_;
  int response_;
  int error_;
  ::std::string* message_;
  bool authoritative_;
  bool proxy_through_service_url_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandLookupTopicResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommandProducer : public ::google::protobuf::MessageLite {
 public:
  CommandProducer();
  virtual ~CommandProducer();

  CommandProducer(const CommandProducer& from);

  inline CommandProducer& operator=(const CommandProducer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandProducer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandProducer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandProducer* other);

  // implements Message ----------------------------------------------

  CommandProducer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandProducer& from);
  void MergeFrom(const CommandProducer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic = 1;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 1;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // required uint64 producer_id = 2;
  inline bool has_producer_id() const;
  inline void clear_producer_id();
  static const int kProducerIdFieldNumber = 2;
  inline ::google::protobuf::uint64 producer_id() const;
  inline void set_producer_id(::google::protobuf::uint64 value);

  // required uint64 request_id = 3;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 3;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional string producer_name = 4;
  inline bool has_producer_name() const;
  inline void clear_producer_name();
  static const int kProducerNameFieldNumber = 4;
  inline const ::std::string& producer_name() const;
  inline void set_producer_name(const ::std::string& value);
  inline void set_producer_name(const char* value);
  inline void set_producer_name(const char* value, size_t size);
  inline ::std::string* mutable_producer_name();
  inline ::std::string* release_producer_name();
  inline void set_allocated_producer_name(::std::string* producer_name);

  // optional bool encrypted = 5 [default = false];
  inline bool has_encrypted() const;
  inline void clear_encrypted();
  static const int kEncryptedFieldNumber = 5;
  inline bool encrypted() const;
  inline void set_encrypted(bool value);

  // repeated .pulsar.proto.KeyValue metadata = 6;
  inline int metadata_size() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  inline const ::pulsar::proto::KeyValue& metadata(int index) const;
  inline ::pulsar::proto::KeyValue* mutable_metadata(int index);
  inline ::pulsar::proto::KeyValue* add_metadata();
  inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      metadata() const;
  inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_metadata();

  // optional .pulsar.proto.Schema schema = 7;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 7;
  inline const ::pulsar::proto::Schema& schema() const;
  inline ::pulsar::proto::Schema* mutable_schema();
  inline ::pulsar::proto::Schema* release_schema();
  inline void set_allocated_schema(::pulsar::proto::Schema* schema);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandProducer)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_producer_id();
  inline void clear_has_producer_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_encrypted();
  inline void clear_has_encrypted();
  inline void set_has_schema();
  inline void clear_has_schema();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* topic_;
  ::google::protobuf::uint64 producer_id_;
  ::google::protobuf::uint64 request_id_;
  ::std::string* producer_name_;
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > metadata_;
  ::pulsar::proto::Schema* schema_;
  bool encrypted_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandProducer* default_instance_;
};
// -------------------------------------------------------------------

class CommandSend : public ::google::protobuf::MessageLite {
 public:
  CommandSend();
  virtual ~CommandSend();

  CommandSend(const CommandSend& from);

  inline CommandSend& operator=(const CommandSend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandSend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandSend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandSend* other);

  // implements Message ----------------------------------------------

  CommandSend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandSend& from);
  void MergeFrom(const CommandSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 producer_id = 1;
  inline bool has_producer_id() const;
  inline void clear_producer_id();
  static const int kProducerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 producer_id() const;
  inline void set_producer_id(::google::protobuf::uint64 value);

  // required uint64 sequence_id = 2;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::uint64 value);

  // optional int32 num_messages = 3 [default = 1];
  inline bool has_num_messages() const;
  inline void clear_num_messages();
  static const int kNumMessagesFieldNumber = 3;
  inline ::google::protobuf::int32 num_messages() const;
  inline void set_num_messages(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSend)
 private:
  inline void set_has_producer_id();
  inline void clear_has_producer_id();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_num_messages();
  inline void clear_has_num_messages();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 producer_id_;
  ::google::protobuf::uint64 sequence_id_;
  ::google::protobuf::int32 num_messages_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandSend* default_instance_;
};
// -------------------------------------------------------------------

class CommandSendReceipt : public ::google::protobuf::MessageLite {
 public:
  CommandSendReceipt();
  virtual ~CommandSendReceipt();

  CommandSendReceipt(const CommandSendReceipt& from);

  inline CommandSendReceipt& operator=(const CommandSendReceipt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandSendReceipt& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandSendReceipt* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandSendReceipt* other);

  // implements Message ----------------------------------------------

  CommandSendReceipt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandSendReceipt& from);
  void MergeFrom(const CommandSendReceipt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 producer_id = 1;
  inline bool has_producer_id() const;
  inline void clear_producer_id();
  static const int kProducerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 producer_id() const;
  inline void set_producer_id(::google::protobuf::uint64 value);

  // required uint64 sequence_id = 2;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::uint64 value);

  // optional .pulsar.proto.MessageIdData message_id = 3;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  inline const ::pulsar::proto::MessageIdData& message_id() const;
  inline ::pulsar::proto::MessageIdData* mutable_message_id();
  inline ::pulsar::proto::MessageIdData* release_message_id();
  inline void set_allocated_message_id(::pulsar::proto::MessageIdData* message_id);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSendReceipt)
 private:
  inline void set_has_producer_id();
  inline void clear_has_producer_id();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 producer_id_;
  ::google::protobuf::uint64 sequence_id_;
  ::pulsar::proto::MessageIdData* message_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandSendReceipt* default_instance_;
};
// -------------------------------------------------------------------

class CommandSendError : public ::google::protobuf::MessageLite {
 public:
  CommandSendError();
  virtual ~CommandSendError();

  CommandSendError(const CommandSendError& from);

  inline CommandSendError& operator=(const CommandSendError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandSendError& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandSendError* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandSendError* other);

  // implements Message ----------------------------------------------

  CommandSendError* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandSendError& from);
  void MergeFrom(const CommandSendError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 producer_id = 1;
  inline bool has_producer_id() const;
  inline void clear_producer_id();
  static const int kProducerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 producer_id() const;
  inline void set_producer_id(::google::protobuf::uint64 value);

  // required uint64 sequence_id = 2;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 2;
  inline ::google::protobuf::uint64 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::uint64 value);

  // required .pulsar.proto.ServerError error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline ::pulsar::proto::ServerError error() const;
  inline void set_error(::pulsar::proto::ServerError value);

  // required string message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSendError)
 private:
  inline void set_has_producer_id();
  inline void clear_has_producer_id();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 producer_id_;
  ::google::protobuf::uint64 sequence_id_;
  ::std::string* message_;
  int error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandSendError* default_instance_;
};
// -------------------------------------------------------------------

class CommandMessage : public ::google::protobuf::MessageLite {
 public:
  CommandMessage();
  virtual ~CommandMessage();

  CommandMessage(const CommandMessage& from);

  inline CommandMessage& operator=(const CommandMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandMessage* other);

  // implements Message ----------------------------------------------

  CommandMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandMessage& from);
  void MergeFrom(const CommandMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 consumer_id = 1;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // required .pulsar.proto.MessageIdData message_id = 2;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  inline const ::pulsar::proto::MessageIdData& message_id() const;
  inline ::pulsar::proto::MessageIdData* mutable_message_id();
  inline ::pulsar::proto::MessageIdData* release_message_id();
  inline void set_allocated_message_id(::pulsar::proto::MessageIdData* message_id);

  // optional uint32 redelivery_count = 3 [default = 0];
  inline bool has_redelivery_count() const;
  inline void clear_redelivery_count();
  static const int kRedeliveryCountFieldNumber = 3;
  inline ::google::protobuf::uint32 redelivery_count() const;
  inline void set_redelivery_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandMessage)
 private:
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_redelivery_count();
  inline void clear_has_redelivery_count();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 consumer_id_;
  ::pulsar::proto::MessageIdData* message_id_;
  ::google::protobuf::uint32 redelivery_count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandMessage* default_instance_;
};
// -------------------------------------------------------------------

class CommandAck : public ::google::protobuf::MessageLite {
 public:
  CommandAck();
  virtual ~CommandAck();

  CommandAck(const CommandAck& from);

  inline CommandAck& operator=(const CommandAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandAck* other);

  // implements Message ----------------------------------------------

  CommandAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandAck& from);
  void MergeFrom(const CommandAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommandAck_AckType AckType;
  static const AckType Individual = CommandAck_AckType_Individual;
  static const AckType Cumulative = CommandAck_AckType_Cumulative;
  static inline bool AckType_IsValid(int value) {
    return CommandAck_AckType_IsValid(value);
  }
  static const AckType AckType_MIN =
    CommandAck_AckType_AckType_MIN;
  static const AckType AckType_MAX =
    CommandAck_AckType_AckType_MAX;
  static const int AckType_ARRAYSIZE =
    CommandAck_AckType_AckType_ARRAYSIZE;

  typedef CommandAck_ValidationError ValidationError;
  static const ValidationError UncompressedSizeCorruption = CommandAck_ValidationError_UncompressedSizeCorruption;
  static const ValidationError DecompressionError = CommandAck_ValidationError_DecompressionError;
  static const ValidationError ChecksumMismatch = CommandAck_ValidationError_ChecksumMismatch;
  static const ValidationError BatchDeSerializeError = CommandAck_ValidationError_BatchDeSerializeError;
  static const ValidationError DecryptionError = CommandAck_ValidationError_DecryptionError;
  static inline bool ValidationError_IsValid(int value) {
    return CommandAck_ValidationError_IsValid(value);
  }
  static const ValidationError ValidationError_MIN =
    CommandAck_ValidationError_ValidationError_MIN;
  static const ValidationError ValidationError_MAX =
    CommandAck_ValidationError_ValidationError_MAX;
  static const int ValidationError_ARRAYSIZE =
    CommandAck_ValidationError_ValidationError_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint64 consumer_id = 1;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // required .pulsar.proto.CommandAck.AckType ack_type = 2;
  inline bool has_ack_type() const;
  inline void clear_ack_type();
  static const int kAckTypeFieldNumber = 2;
  inline ::pulsar::proto::CommandAck_AckType ack_type() const;
  inline void set_ack_type(::pulsar::proto::CommandAck_AckType value);

  // repeated .pulsar.proto.MessageIdData message_id = 3;
  inline int message_id_size() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  inline const ::pulsar::proto::MessageIdData& message_id(int index) const;
  inline ::pulsar::proto::MessageIdData* mutable_message_id(int index);
  inline ::pulsar::proto::MessageIdData* add_message_id();
  inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >&
      message_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >*
      mutable_message_id();

  // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
  inline bool has_validation_error() const;
  inline void clear_validation_error();
  static const int kValidationErrorFieldNumber = 4;
  inline ::pulsar::proto::CommandAck_ValidationError validation_error() const;
  inline void set_validation_error(::pulsar::proto::CommandAck_ValidationError value);

  // repeated .pulsar.proto.KeyLongValue properties = 5;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 5;
  inline const ::pulsar::proto::KeyLongValue& properties(int index) const;
  inline ::pulsar::proto::KeyLongValue* mutable_properties(int index);
  inline ::pulsar::proto::KeyLongValue* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyLongValue >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyLongValue >*
      mutable_properties();

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAck)
 private:
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();
  inline void set_has_ack_type();
  inline void clear_has_ack_type();
  inline void set_has_validation_error();
  inline void clear_has_validation_error();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 consumer_id_;
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData > message_id_;
  int ack_type_;
  int validation_error_;
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyLongValue > properties_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandAck* default_instance_;
};
// -------------------------------------------------------------------

class CommandActiveConsumerChange : public ::google::protobuf::MessageLite {
 public:
  CommandActiveConsumerChange();
  virtual ~CommandActiveConsumerChange();

  CommandActiveConsumerChange(const CommandActiveConsumerChange& from);

  inline CommandActiveConsumerChange& operator=(const CommandActiveConsumerChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandActiveConsumerChange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandActiveConsumerChange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandActiveConsumerChange* other);

  // implements Message ----------------------------------------------

  CommandActiveConsumerChange* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandActiveConsumerChange& from);
  void MergeFrom(const CommandActiveConsumerChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 consumer_id = 1;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // optional bool is_active = 2 [default = false];
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 2;
  inline bool is_active() const;
  inline void set_is_active(bool value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandActiveConsumerChange)
 private:
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();
  inline void set_has_is_active();
  inline void clear_has_is_active();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 consumer_id_;
  bool is_active_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandActiveConsumerChange* default_instance_;
};
// -------------------------------------------------------------------

class CommandFlow : public ::google::protobuf::MessageLite {
 public:
  CommandFlow();
  virtual ~CommandFlow();

  CommandFlow(const CommandFlow& from);

  inline CommandFlow& operator=(const CommandFlow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandFlow& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandFlow* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandFlow* other);

  // implements Message ----------------------------------------------

  CommandFlow* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandFlow& from);
  void MergeFrom(const CommandFlow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 consumer_id = 1;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // required uint32 messagePermits = 2;
  inline bool has_messagepermits() const;
  inline void clear_messagepermits();
  static const int kMessagePermitsFieldNumber = 2;
  inline ::google::protobuf::uint32 messagepermits() const;
  inline void set_messagepermits(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandFlow)
 private:
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();
  inline void set_has_messagepermits();
  inline void clear_has_messagepermits();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 consumer_id_;
  ::google::protobuf::uint32 messagepermits_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandFlow* default_instance_;
};
// -------------------------------------------------------------------

class CommandUnsubscribe : public ::google::protobuf::MessageLite {
 public:
  CommandUnsubscribe();
  virtual ~CommandUnsubscribe();

  CommandUnsubscribe(const CommandUnsubscribe& from);

  inline CommandUnsubscribe& operator=(const CommandUnsubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandUnsubscribe& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandUnsubscribe* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandUnsubscribe* other);

  // implements Message ----------------------------------------------

  CommandUnsubscribe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandUnsubscribe& from);
  void MergeFrom(const CommandUnsubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 consumer_id = 1;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // required uint64 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandUnsubscribe)
 private:
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 consumer_id_;
  ::google::protobuf::uint64 request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandUnsubscribe* default_instance_;
};
// -------------------------------------------------------------------

class CommandSeek : public ::google::protobuf::MessageLite {
 public:
  CommandSeek();
  virtual ~CommandSeek();

  CommandSeek(const CommandSeek& from);

  inline CommandSeek& operator=(const CommandSeek& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandSeek& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandSeek* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandSeek* other);

  // implements Message ----------------------------------------------

  CommandSeek* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandSeek& from);
  void MergeFrom(const CommandSeek& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 consumer_id = 1;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // required uint64 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional .pulsar.proto.MessageIdData message_id = 3;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  inline const ::pulsar::proto::MessageIdData& message_id() const;
  inline ::pulsar::proto::MessageIdData* mutable_message_id();
  inline ::pulsar::proto::MessageIdData* release_message_id();
  inline void set_allocated_message_id(::pulsar::proto::MessageIdData* message_id);

  // optional uint64 message_publish_time = 4;
  inline bool has_message_publish_time() const;
  inline void clear_message_publish_time();
  static const int kMessagePublishTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 message_publish_time() const;
  inline void set_message_publish_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSeek)
 private:
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_message_publish_time();
  inline void clear_has_message_publish_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 consumer_id_;
  ::google::protobuf::uint64 request_id_;
  ::pulsar::proto::MessageIdData* message_id_;
  ::google::protobuf::uint64 message_publish_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandSeek* default_instance_;
};
// -------------------------------------------------------------------

class CommandReachedEndOfTopic : public ::google::protobuf::MessageLite {
 public:
  CommandReachedEndOfTopic();
  virtual ~CommandReachedEndOfTopic();

  CommandReachedEndOfTopic(const CommandReachedEndOfTopic& from);

  inline CommandReachedEndOfTopic& operator=(const CommandReachedEndOfTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandReachedEndOfTopic& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandReachedEndOfTopic* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandReachedEndOfTopic* other);

  // implements Message ----------------------------------------------

  CommandReachedEndOfTopic* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandReachedEndOfTopic& from);
  void MergeFrom(const CommandReachedEndOfTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 consumer_id = 1;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandReachedEndOfTopic)
 private:
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 consumer_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandReachedEndOfTopic* default_instance_;
};
// -------------------------------------------------------------------

class CommandCloseProducer : public ::google::protobuf::MessageLite {
 public:
  CommandCloseProducer();
  virtual ~CommandCloseProducer();

  CommandCloseProducer(const CommandCloseProducer& from);

  inline CommandCloseProducer& operator=(const CommandCloseProducer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandCloseProducer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandCloseProducer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandCloseProducer* other);

  // implements Message ----------------------------------------------

  CommandCloseProducer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandCloseProducer& from);
  void MergeFrom(const CommandCloseProducer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 producer_id = 1;
  inline bool has_producer_id() const;
  inline void clear_producer_id();
  static const int kProducerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 producer_id() const;
  inline void set_producer_id(::google::protobuf::uint64 value);

  // required uint64 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandCloseProducer)
 private:
  inline void set_has_producer_id();
  inline void clear_has_producer_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 producer_id_;
  ::google::protobuf::uint64 request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandCloseProducer* default_instance_;
};
// -------------------------------------------------------------------

class CommandCloseConsumer : public ::google::protobuf::MessageLite {
 public:
  CommandCloseConsumer();
  virtual ~CommandCloseConsumer();

  CommandCloseConsumer(const CommandCloseConsumer& from);

  inline CommandCloseConsumer& operator=(const CommandCloseConsumer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandCloseConsumer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandCloseConsumer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandCloseConsumer* other);

  // implements Message ----------------------------------------------

  CommandCloseConsumer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandCloseConsumer& from);
  void MergeFrom(const CommandCloseConsumer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 consumer_id = 1;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // required uint64 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandCloseConsumer)
 private:
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 consumer_id_;
  ::google::protobuf::uint64 request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandCloseConsumer* default_instance_;
};
// -------------------------------------------------------------------

class CommandRedeliverUnacknowledgedMessages : public ::google::protobuf::MessageLite {
 public:
  CommandRedeliverUnacknowledgedMessages();
  virtual ~CommandRedeliverUnacknowledgedMessages();

  CommandRedeliverUnacknowledgedMessages(const CommandRedeliverUnacknowledgedMessages& from);

  inline CommandRedeliverUnacknowledgedMessages& operator=(const CommandRedeliverUnacknowledgedMessages& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandRedeliverUnacknowledgedMessages& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandRedeliverUnacknowledgedMessages* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandRedeliverUnacknowledgedMessages* other);

  // implements Message ----------------------------------------------

  CommandRedeliverUnacknowledgedMessages* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandRedeliverUnacknowledgedMessages& from);
  void MergeFrom(const CommandRedeliverUnacknowledgedMessages& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 consumer_id = 1;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // repeated .pulsar.proto.MessageIdData message_ids = 2;
  inline int message_ids_size() const;
  inline void clear_message_ids();
  static const int kMessageIdsFieldNumber = 2;
  inline const ::pulsar::proto::MessageIdData& message_ids(int index) const;
  inline ::pulsar::proto::MessageIdData* mutable_message_ids(int index);
  inline ::pulsar::proto::MessageIdData* add_message_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >&
      message_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >*
      mutable_message_ids();

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
 private:
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 consumer_id_;
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData > message_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandRedeliverUnacknowledgedMessages* default_instance_;
};
// -------------------------------------------------------------------

class CommandSuccess : public ::google::protobuf::MessageLite {
 public:
  CommandSuccess();
  virtual ~CommandSuccess();

  CommandSuccess(const CommandSuccess& from);

  inline CommandSuccess& operator=(const CommandSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandSuccess& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandSuccess* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandSuccess* other);

  // implements Message ----------------------------------------------

  CommandSuccess* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandSuccess& from);
  void MergeFrom(const CommandSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional .pulsar.proto.Schema schema = 2;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 2;
  inline const ::pulsar::proto::Schema& schema() const;
  inline ::pulsar::proto::Schema* mutable_schema();
  inline ::pulsar::proto::Schema* release_schema();
  inline void set_allocated_schema(::pulsar::proto::Schema* schema);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSuccess)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_schema();
  inline void clear_has_schema();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::pulsar::proto::Schema* schema_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandSuccess* default_instance_;
};
// -------------------------------------------------------------------

class CommandProducerSuccess : public ::google::protobuf::MessageLite {
 public:
  CommandProducerSuccess();
  virtual ~CommandProducerSuccess();

  CommandProducerSuccess(const CommandProducerSuccess& from);

  inline CommandProducerSuccess& operator=(const CommandProducerSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandProducerSuccess& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandProducerSuccess* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandProducerSuccess* other);

  // implements Message ----------------------------------------------

  CommandProducerSuccess* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandProducerSuccess& from);
  void MergeFrom(const CommandProducerSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // required string producer_name = 2;
  inline bool has_producer_name() const;
  inline void clear_producer_name();
  static const int kProducerNameFieldNumber = 2;
  inline const ::std::string& producer_name() const;
  inline void set_producer_name(const ::std::string& value);
  inline void set_producer_name(const char* value);
  inline void set_producer_name(const char* value, size_t size);
  inline ::std::string* mutable_producer_name();
  inline ::std::string* release_producer_name();
  inline void set_allocated_producer_name(::std::string* producer_name);

  // optional int64 last_sequence_id = 3 [default = -1];
  inline bool has_last_sequence_id() const;
  inline void clear_last_sequence_id();
  static const int kLastSequenceIdFieldNumber = 3;
  inline ::google::protobuf::int64 last_sequence_id() const;
  inline void set_last_sequence_id(::google::protobuf::int64 value);

  // optional bytes schema_version = 4;
  inline bool has_schema_version() const;
  inline void clear_schema_version();
  static const int kSchemaVersionFieldNumber = 4;
  inline const ::std::string& schema_version() const;
  inline void set_schema_version(const ::std::string& value);
  inline void set_schema_version(const char* value);
  inline void set_schema_version(const void* value, size_t size);
  inline ::std::string* mutable_schema_version();
  inline ::std::string* release_schema_version();
  inline void set_allocated_schema_version(::std::string* schema_version);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandProducerSuccess)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_last_sequence_id();
  inline void clear_has_last_sequence_id();
  inline void set_has_schema_version();
  inline void clear_has_schema_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::std::string* producer_name_;
  ::google::protobuf::int64 last_sequence_id_;
  ::std::string* schema_version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandProducerSuccess* default_instance_;
};
// -------------------------------------------------------------------

class CommandError : public ::google::protobuf::MessageLite {
 public:
  CommandError();
  virtual ~CommandError();

  CommandError(const CommandError& from);

  inline CommandError& operator=(const CommandError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandError& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandError* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandError* other);

  // implements Message ----------------------------------------------

  CommandError* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandError& from);
  void MergeFrom(const CommandError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // required .pulsar.proto.ServerError error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline ::pulsar::proto::ServerError error() const;
  inline void set_error(::pulsar::proto::ServerError value);

  // required string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandError)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::std::string* message_;
  int error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandError* default_instance_;
};
// -------------------------------------------------------------------

class CommandPing : public ::google::protobuf::MessageLite {
 public:
  CommandPing();
  virtual ~CommandPing();

  CommandPing(const CommandPing& from);

  inline CommandPing& operator=(const CommandPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandPing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandPing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandPing* other);

  // implements Message ----------------------------------------------

  CommandPing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandPing& from);
  void MergeFrom(const CommandPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPing)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandPing* default_instance_;
};
// -------------------------------------------------------------------

class CommandPong : public ::google::protobuf::MessageLite {
 public:
  CommandPong();
  virtual ~CommandPong();

  CommandPong(const CommandPong& from);

  inline CommandPong& operator=(const CommandPong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandPong& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandPong* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandPong* other);

  // implements Message ----------------------------------------------

  CommandPong* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandPong& from);
  void MergeFrom(const CommandPong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPong)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandPong* default_instance_;
};
// -------------------------------------------------------------------

class CommandConsumerStats : public ::google::protobuf::MessageLite {
 public:
  CommandConsumerStats();
  virtual ~CommandConsumerStats();

  CommandConsumerStats(const CommandConsumerStats& from);

  inline CommandConsumerStats& operator=(const CommandConsumerStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandConsumerStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandConsumerStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandConsumerStats* other);

  // implements Message ----------------------------------------------

  CommandConsumerStats* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandConsumerStats& from);
  void MergeFrom(const CommandConsumerStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // required uint64 consumer_id = 4;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 4;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConsumerStats)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::google::protobuf::uint64 consumer_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandConsumerStats* default_instance_;
};
// -------------------------------------------------------------------

class CommandConsumerStatsResponse : public ::google::protobuf::MessageLite {
 public:
  CommandConsumerStatsResponse();
  virtual ~CommandConsumerStatsResponse();

  CommandConsumerStatsResponse(const CommandConsumerStatsResponse& from);

  inline CommandConsumerStatsResponse& operator=(const CommandConsumerStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandConsumerStatsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandConsumerStatsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandConsumerStatsResponse* other);

  // implements Message ----------------------------------------------

  CommandConsumerStatsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandConsumerStatsResponse& from);
  void MergeFrom(const CommandConsumerStatsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional .pulsar.proto.ServerError error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::pulsar::proto::ServerError error_code() const;
  inline void set_error_code(::pulsar::proto::ServerError value);

  // optional string error_message = 3;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // optional double msgRateOut = 4;
  inline bool has_msgrateout() const;
  inline void clear_msgrateout();
  static const int kMsgRateOutFieldNumber = 4;
  inline double msgrateout() const;
  inline void set_msgrateout(double value);

  // optional double msgThroughputOut = 5;
  inline bool has_msgthroughputout() const;
  inline void clear_msgthroughputout();
  static const int kMsgThroughputOutFieldNumber = 5;
  inline double msgthroughputout() const;
  inline void set_msgthroughputout(double value);

  // optional double msgRateRedeliver = 6;
  inline bool has_msgrateredeliver() const;
  inline void clear_msgrateredeliver();
  static const int kMsgRateRedeliverFieldNumber = 6;
  inline double msgrateredeliver() const;
  inline void set_msgrateredeliver(double value);

  // optional string consumerName = 7;
  inline bool has_consumername() const;
  inline void clear_consumername();
  static const int kConsumerNameFieldNumber = 7;
  inline const ::std::string& consumername() const;
  inline void set_consumername(const ::std::string& value);
  inline void set_consumername(const char* value);
  inline void set_consumername(const char* value, size_t size);
  inline ::std::string* mutable_consumername();
  inline ::std::string* release_consumername();
  inline void set_allocated_consumername(::std::string* consumername);

  // optional uint64 availablePermits = 8;
  inline bool has_availablepermits() const;
  inline void clear_availablepermits();
  static const int kAvailablePermitsFieldNumber = 8;
  inline ::google::protobuf::uint64 availablepermits() const;
  inline void set_availablepermits(::google::protobuf::uint64 value);

  // optional uint64 unackedMessages = 9;
  inline bool has_unackedmessages() const;
  inline void clear_unackedmessages();
  static const int kUnackedMessagesFieldNumber = 9;
  inline ::google::protobuf::uint64 unackedmessages() const;
  inline void set_unackedmessages(::google::protobuf::uint64 value);

  // optional bool blockedConsumerOnUnackedMsgs = 10;
  inline bool has_blockedconsumeronunackedmsgs() const;
  inline void clear_blockedconsumeronunackedmsgs();
  static const int kBlockedConsumerOnUnackedMsgsFieldNumber = 10;
  inline bool blockedconsumeronunackedmsgs() const;
  inline void set_blockedconsumeronunackedmsgs(bool value);

  // optional string address = 11;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 11;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional string connectedSince = 12;
  inline bool has_connectedsince() const;
  inline void clear_connectedsince();
  static const int kConnectedSinceFieldNumber = 12;
  inline const ::std::string& connectedsince() const;
  inline void set_connectedsince(const ::std::string& value);
  inline void set_connectedsince(const char* value);
  inline void set_connectedsince(const char* value, size_t size);
  inline ::std::string* mutable_connectedsince();
  inline ::std::string* release_connectedsince();
  inline void set_allocated_connectedsince(::std::string* connectedsince);

  // optional string type = 13;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 13;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional double msgRateExpired = 14;
  inline bool has_msgrateexpired() const;
  inline void clear_msgrateexpired();
  static const int kMsgRateExpiredFieldNumber = 14;
  inline double msgrateexpired() const;
  inline void set_msgrateexpired(double value);

  // optional uint64 msgBacklog = 15;
  inline bool has_msgbacklog() const;
  inline void clear_msgbacklog();
  static const int kMsgBacklogFieldNumber = 15;
  inline ::google::protobuf::uint64 msgbacklog() const;
  inline void set_msgbacklog(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConsumerStatsResponse)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_msgrateout();
  inline void clear_has_msgrateout();
  inline void set_has_msgthroughputout();
  inline void clear_has_msgthroughputout();
  inline void set_has_msgrateredeliver();
  inline void clear_has_msgrateredeliver();
  inline void set_has_consumername();
  inline void clear_has_consumername();
  inline void set_has_availablepermits();
  inline void clear_has_availablepermits();
  inline void set_has_unackedmessages();
  inline void clear_has_unackedmessages();
  inline void set_has_blockedconsumeronunackedmsgs();
  inline void clear_has_blockedconsumeronunackedmsgs();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_connectedsince();
  inline void clear_has_connectedsince();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msgrateexpired();
  inline void clear_has_msgrateexpired();
  inline void set_has_msgbacklog();
  inline void clear_has_msgbacklog();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::std::string* error_message_;
  double msgrateout_;
  double msgthroughputout_;
  double msgrateredeliver_;
  int error_code_;
  bool blockedconsumeronunackedmsgs_;
  ::std::string* consumername_;
  ::google::protobuf::uint64 availablepermits_;
  ::google::protobuf::uint64 unackedmessages_;
  ::std::string* address_;
  ::std::string* connectedsince_;
  ::std::string* type_;
  double msgrateexpired_;
  ::google::protobuf::uint64 msgbacklog_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandConsumerStatsResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommandGetLastMessageId : public ::google::protobuf::MessageLite {
 public:
  CommandGetLastMessageId();
  virtual ~CommandGetLastMessageId();

  CommandGetLastMessageId(const CommandGetLastMessageId& from);

  inline CommandGetLastMessageId& operator=(const CommandGetLastMessageId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandGetLastMessageId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandGetLastMessageId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandGetLastMessageId* other);

  // implements Message ----------------------------------------------

  CommandGetLastMessageId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandGetLastMessageId& from);
  void MergeFrom(const CommandGetLastMessageId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 consumer_id = 1;
  inline bool has_consumer_id() const;
  inline void clear_consumer_id();
  static const int kConsumerIdFieldNumber = 1;
  inline ::google::protobuf::uint64 consumer_id() const;
  inline void set_consumer_id(::google::protobuf::uint64 value);

  // required uint64 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetLastMessageId)
 private:
  inline void set_has_consumer_id();
  inline void clear_has_consumer_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 consumer_id_;
  ::google::protobuf::uint64 request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandGetLastMessageId* default_instance_;
};
// -------------------------------------------------------------------

class CommandGetLastMessageIdResponse : public ::google::protobuf::MessageLite {
 public:
  CommandGetLastMessageIdResponse();
  virtual ~CommandGetLastMessageIdResponse();

  CommandGetLastMessageIdResponse(const CommandGetLastMessageIdResponse& from);

  inline CommandGetLastMessageIdResponse& operator=(const CommandGetLastMessageIdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandGetLastMessageIdResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandGetLastMessageIdResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandGetLastMessageIdResponse* other);

  // implements Message ----------------------------------------------

  CommandGetLastMessageIdResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandGetLastMessageIdResponse& from);
  void MergeFrom(const CommandGetLastMessageIdResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pulsar.proto.MessageIdData last_message_id = 1;
  inline bool has_last_message_id() const;
  inline void clear_last_message_id();
  static const int kLastMessageIdFieldNumber = 1;
  inline const ::pulsar::proto::MessageIdData& last_message_id() const;
  inline ::pulsar::proto::MessageIdData* mutable_last_message_id();
  inline ::pulsar::proto::MessageIdData* release_last_message_id();
  inline void set_allocated_last_message_id(::pulsar::proto::MessageIdData* last_message_id);

  // required uint64 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetLastMessageIdResponse)
 private:
  inline void set_has_last_message_id();
  inline void clear_has_last_message_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pulsar::proto::MessageIdData* last_message_id_;
  ::google::protobuf::uint64 request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandGetLastMessageIdResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommandGetTopicsOfNamespace : public ::google::protobuf::MessageLite {
 public:
  CommandGetTopicsOfNamespace();
  virtual ~CommandGetTopicsOfNamespace();

  CommandGetTopicsOfNamespace(const CommandGetTopicsOfNamespace& from);

  inline CommandGetTopicsOfNamespace& operator=(const CommandGetTopicsOfNamespace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandGetTopicsOfNamespace& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandGetTopicsOfNamespace* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandGetTopicsOfNamespace* other);

  // implements Message ----------------------------------------------

  CommandGetTopicsOfNamespace* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandGetTopicsOfNamespace& from);
  void MergeFrom(const CommandGetTopicsOfNamespace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommandGetTopicsOfNamespace_Mode Mode;
  static const Mode PERSISTENT = CommandGetTopicsOfNamespace_Mode_PERSISTENT;
  static const Mode NON_PERSISTENT = CommandGetTopicsOfNamespace_Mode_NON_PERSISTENT;
  static const Mode ALL = CommandGetTopicsOfNamespace_Mode_ALL;
  static inline bool Mode_IsValid(int value) {
    return CommandGetTopicsOfNamespace_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    CommandGetTopicsOfNamespace_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    CommandGetTopicsOfNamespace_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    CommandGetTopicsOfNamespace_Mode_Mode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // required string namespace = 2;
  inline bool has_namespace_() const;
  inline void clear_namespace_();
  static const int kNamespaceFieldNumber = 2;
  inline const ::std::string& namespace_() const;
  inline void set_namespace_(const ::std::string& value);
  inline void set_namespace_(const char* value);
  inline void set_namespace_(const char* value, size_t size);
  inline ::std::string* mutable_namespace_();
  inline ::std::string* release_namespace_();
  inline void set_allocated_namespace_(::std::string* namespace_);

  // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::pulsar::proto::CommandGetTopicsOfNamespace_Mode mode() const;
  inline void set_mode(::pulsar::proto::CommandGetTopicsOfNamespace_Mode value);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetTopicsOfNamespace)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_namespace_();
  inline void clear_has_namespace_();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::std::string* namespace__;
  int mode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandGetTopicsOfNamespace* default_instance_;
};
// -------------------------------------------------------------------

class CommandGetTopicsOfNamespaceResponse : public ::google::protobuf::MessageLite {
 public:
  CommandGetTopicsOfNamespaceResponse();
  virtual ~CommandGetTopicsOfNamespaceResponse();

  CommandGetTopicsOfNamespaceResponse(const CommandGetTopicsOfNamespaceResponse& from);

  inline CommandGetTopicsOfNamespaceResponse& operator=(const CommandGetTopicsOfNamespaceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandGetTopicsOfNamespaceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandGetTopicsOfNamespaceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandGetTopicsOfNamespaceResponse* other);

  // implements Message ----------------------------------------------

  CommandGetTopicsOfNamespaceResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandGetTopicsOfNamespaceResponse& from);
  void MergeFrom(const CommandGetTopicsOfNamespaceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // repeated string topics = 2;
  inline int topics_size() const;
  inline void clear_topics();
  static const int kTopicsFieldNumber = 2;
  inline const ::std::string& topics(int index) const;
  inline ::std::string* mutable_topics(int index);
  inline void set_topics(int index, const ::std::string& value);
  inline void set_topics(int index, const char* value);
  inline void set_topics(int index, const char* value, size_t size);
  inline ::std::string* add_topics();
  inline void add_topics(const ::std::string& value);
  inline void add_topics(const char* value);
  inline void add_topics(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& topics() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topics();

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topics_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandGetTopicsOfNamespaceResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommandGetSchema : public ::google::protobuf::MessageLite {
 public:
  CommandGetSchema();
  virtual ~CommandGetSchema();

  CommandGetSchema(const CommandGetSchema& from);

  inline CommandGetSchema& operator=(const CommandGetSchema& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandGetSchema& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandGetSchema* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandGetSchema* other);

  // implements Message ----------------------------------------------

  CommandGetSchema* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandGetSchema& from);
  void MergeFrom(const CommandGetSchema& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // required string topic = 2;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 2;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional bytes schema_version = 3;
  inline bool has_schema_version() const;
  inline void clear_schema_version();
  static const int kSchemaVersionFieldNumber = 3;
  inline const ::std::string& schema_version() const;
  inline void set_schema_version(const ::std::string& value);
  inline void set_schema_version(const char* value);
  inline void set_schema_version(const void* value, size_t size);
  inline ::std::string* mutable_schema_version();
  inline ::std::string* release_schema_version();
  inline void set_allocated_schema_version(::std::string* schema_version);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetSchema)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_schema_version();
  inline void clear_has_schema_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::std::string* topic_;
  ::std::string* schema_version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandGetSchema* default_instance_;
};
// -------------------------------------------------------------------

class CommandGetSchemaResponse : public ::google::protobuf::MessageLite {
 public:
  CommandGetSchemaResponse();
  virtual ~CommandGetSchemaResponse();

  CommandGetSchemaResponse(const CommandGetSchemaResponse& from);

  inline CommandGetSchemaResponse& operator=(const CommandGetSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommandGetSchemaResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommandGetSchemaResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommandGetSchemaResponse* other);

  // implements Message ----------------------------------------------

  CommandGetSchemaResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommandGetSchemaResponse& from);
  void MergeFrom(const CommandGetSchemaResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint64 request_id() const;
  inline void set_request_id(::google::protobuf::uint64 value);

  // optional .pulsar.proto.ServerError error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::pulsar::proto::ServerError error_code() const;
  inline void set_error_code(::pulsar::proto::ServerError value);

  // optional string error_message = 3;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // optional .pulsar.proto.Schema schema = 4;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 4;
  inline const ::pulsar::proto::Schema& schema() const;
  inline ::pulsar::proto::Schema* mutable_schema();
  inline ::pulsar::proto::Schema* release_schema();
  inline void set_allocated_schema(::pulsar::proto::Schema* schema);

  // optional bytes schema_version = 5;
  inline bool has_schema_version() const;
  inline void clear_schema_version();
  static const int kSchemaVersionFieldNumber = 5;
  inline const ::std::string& schema_version() const;
  inline void set_schema_version(const ::std::string& value);
  inline void set_schema_version(const char* value);
  inline void set_schema_version(const void* value, size_t size);
  inline ::std::string* mutable_schema_version();
  inline ::std::string* release_schema_version();
  inline void set_allocated_schema_version(::std::string* schema_version);

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetSchemaResponse)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_schema();
  inline void clear_has_schema();
  inline void set_has_schema_version();
  inline void clear_has_schema_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::std::string* error_message_;
  ::pulsar::proto::Schema* schema_;
  ::std::string* schema_version_;
  int error_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static CommandGetSchemaResponse* default_instance_;
};
// -------------------------------------------------------------------

class BaseCommand : public ::google::protobuf::MessageLite {
 public:
  BaseCommand();
  virtual ~BaseCommand();

  BaseCommand(const BaseCommand& from);

  inline BaseCommand& operator=(const BaseCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BaseCommand& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BaseCommand* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BaseCommand* other);

  // implements Message ----------------------------------------------

  BaseCommand* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BaseCommand& from);
  void MergeFrom(const BaseCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BaseCommand_Type Type;
  static const Type CONNECT = BaseCommand_Type_CONNECT;
  static const Type CONNECTED = BaseCommand_Type_CONNECTED;
  static const Type SUBSCRIBE = BaseCommand_Type_SUBSCRIBE;
  static const Type PRODUCER = BaseCommand_Type_PRODUCER;
  static const Type SEND = BaseCommand_Type_SEND;
  static const Type SEND_RECEIPT = BaseCommand_Type_SEND_RECEIPT;
  static const Type SEND_ERROR = BaseCommand_Type_SEND_ERROR;
  static const Type MESSAGE = BaseCommand_Type_MESSAGE;
  static const Type ACK = BaseCommand_Type_ACK;
  static const Type FLOW = BaseCommand_Type_FLOW;
  static const Type UNSUBSCRIBE = BaseCommand_Type_UNSUBSCRIBE;
  static const Type SUCCESS = BaseCommand_Type_SUCCESS;
  static const Type ERROR = BaseCommand_Type_ERROR;
  static const Type CLOSE_PRODUCER = BaseCommand_Type_CLOSE_PRODUCER;
  static const Type CLOSE_CONSUMER = BaseCommand_Type_CLOSE_CONSUMER;
  static const Type PRODUCER_SUCCESS = BaseCommand_Type_PRODUCER_SUCCESS;
  static const Type PING = BaseCommand_Type_PING;
  static const Type PONG = BaseCommand_Type_PONG;
  static const Type REDELIVER_UNACKNOWLEDGED_MESSAGES = BaseCommand_Type_REDELIVER_UNACKNOWLEDGED_MESSAGES;
  static const Type PARTITIONED_METADATA = BaseCommand_Type_PARTITIONED_METADATA;
  static const Type PARTITIONED_METADATA_RESPONSE = BaseCommand_Type_PARTITIONED_METADATA_RESPONSE;
  static const Type LOOKUP = BaseCommand_Type_LOOKUP;
  static const Type LOOKUP_RESPONSE = BaseCommand_Type_LOOKUP_RESPONSE;
  static const Type CONSUMER_STATS = BaseCommand_Type_CONSUMER_STATS;
  static const Type CONSUMER_STATS_RESPONSE = BaseCommand_Type_CONSUMER_STATS_RESPONSE;
  static const Type REACHED_END_OF_TOPIC = BaseCommand_Type_REACHED_END_OF_TOPIC;
  static const Type SEEK = BaseCommand_Type_SEEK;
  static const Type GET_LAST_MESSAGE_ID = BaseCommand_Type_GET_LAST_MESSAGE_ID;
  static const Type GET_LAST_MESSAGE_ID_RESPONSE = BaseCommand_Type_GET_LAST_MESSAGE_ID_RESPONSE;
  static const Type ACTIVE_CONSUMER_CHANGE = BaseCommand_Type_ACTIVE_CONSUMER_CHANGE;
  static const Type GET_TOPICS_OF_NAMESPACE = BaseCommand_Type_GET_TOPICS_OF_NAMESPACE;
  static const Type GET_TOPICS_OF_NAMESPACE_RESPONSE = BaseCommand_Type_GET_TOPICS_OF_NAMESPACE_RESPONSE;
  static const Type GET_SCHEMA = BaseCommand_Type_GET_SCHEMA;
  static const Type GET_SCHEMA_RESPONSE = BaseCommand_Type_GET_SCHEMA_RESPONSE;
  static const Type AUTH_CHALLENGE = BaseCommand_Type_AUTH_CHALLENGE;
  static const Type AUTH_RESPONSE = BaseCommand_Type_AUTH_RESPONSE;
  static inline bool Type_IsValid(int value) {
    return BaseCommand_Type_IsValid(value);
  }
  static const Type Type_MIN =
    BaseCommand_Type_Type_MIN;
  static const Type Type_MAX =
    BaseCommand_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    BaseCommand_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .pulsar.proto.BaseCommand.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pulsar::proto::BaseCommand_Type type() const;
  inline void set_type(::pulsar::proto::BaseCommand_Type value);

  // optional .pulsar.proto.CommandConnect connect = 2;
  inline bool has_connect() const;
  inline void clear_connect();
  static const int kConnectFieldNumber = 2;
  inline const ::pulsar::proto::CommandConnect& connect() const;
  inline ::pulsar::proto::CommandConnect* mutable_connect();
  inline ::pulsar::proto::CommandConnect* release_connect();
  inline void set_allocated_connect(::pulsar::proto::CommandConnect* connect);

  // optional .pulsar.proto.CommandConnected connected = 3;
  inline bool has_connected() const;
  inline void clear_connected();
  static const int kConnectedFieldNumber = 3;
  inline const ::pulsar::proto::CommandConnected& connected() const;
  inline ::pulsar::proto::CommandConnected* mutable_connected();
  inline ::pulsar::proto::CommandConnected* release_connected();
  inline void set_allocated_connected(::pulsar::proto::CommandConnected* connected);

  // optional .pulsar.proto.CommandSubscribe subscribe = 4;
  inline bool has_subscribe() const;
  inline void clear_subscribe();
  static const int kSubscribeFieldNumber = 4;
  inline const ::pulsar::proto::CommandSubscribe& subscribe() const;
  inline ::pulsar::proto::CommandSubscribe* mutable_subscribe();
  inline ::pulsar::proto::CommandSubscribe* release_subscribe();
  inline void set_allocated_subscribe(::pulsar::proto::CommandSubscribe* subscribe);

  // optional .pulsar.proto.CommandProducer producer = 5;
  inline bool has_producer() const;
  inline void clear_producer();
  static const int kProducerFieldNumber = 5;
  inline const ::pulsar::proto::CommandProducer& producer() const;
  inline ::pulsar::proto::CommandProducer* mutable_producer();
  inline ::pulsar::proto::CommandProducer* release_producer();
  inline void set_allocated_producer(::pulsar::proto::CommandProducer* producer);

  // optional .pulsar.proto.CommandSend send = 6;
  inline bool has_send() const;
  inline void clear_send();
  static const int kSendFieldNumber = 6;
  inline const ::pulsar::proto::CommandSend& send() const;
  inline ::pulsar::proto::CommandSend* mutable_send();
  inline ::pulsar::proto::CommandSend* release_send();
  inline void set_allocated_send(::pulsar::proto::CommandSend* send);

  // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
  inline bool has_send_receipt() const;
  inline void clear_send_receipt();
  static const int kSendReceiptFieldNumber = 7;
  inline const ::pulsar::proto::CommandSendReceipt& send_receipt() const;
  inline ::pulsar::proto::CommandSendReceipt* mutable_send_receipt();
  inline ::pulsar::proto::CommandSendReceipt* release_send_receipt();
  inline void set_allocated_send_receipt(::pulsar::proto::CommandSendReceipt* send_receipt);

  // optional .pulsar.proto.CommandSendError send_error = 8;
  inline bool has_send_error() const;
  inline void clear_send_error();
  static const int kSendErrorFieldNumber = 8;
  inline const ::pulsar::proto::CommandSendError& send_error() const;
  inline ::pulsar::proto::CommandSendError* mutable_send_error();
  inline ::pulsar::proto::CommandSendError* release_send_error();
  inline void set_allocated_send_error(::pulsar::proto::CommandSendError* send_error);

  // optional .pulsar.proto.CommandMessage message = 9;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 9;
  inline const ::pulsar::proto::CommandMessage& message() const;
  inline ::pulsar::proto::CommandMessage* mutable_message();
  inline ::pulsar::proto::CommandMessage* release_message();
  inline void set_allocated_message(::pulsar::proto::CommandMessage* message);

  // optional .pulsar.proto.CommandAck ack = 10;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 10;
  inline const ::pulsar::proto::CommandAck& ack() const;
  inline ::pulsar::proto::CommandAck* mutable_ack();
  inline ::pulsar::proto::CommandAck* release_ack();
  inline void set_allocated_ack(::pulsar::proto::CommandAck* ack);

  // optional .pulsar.proto.CommandFlow flow = 11;
  inline bool has_flow() const;
  inline void clear_flow();
  static const int kFlowFieldNumber = 11;
  inline const ::pulsar::proto::CommandFlow& flow() const;
  inline ::pulsar::proto::CommandFlow* mutable_flow();
  inline ::pulsar::proto::CommandFlow* release_flow();
  inline void set_allocated_flow(::pulsar::proto::CommandFlow* flow);

  // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
  inline bool has_unsubscribe() const;
  inline void clear_unsubscribe();
  static const int kUnsubscribeFieldNumber = 12;
  inline const ::pulsar::proto::CommandUnsubscribe& unsubscribe() const;
  inline ::pulsar::proto::CommandUnsubscribe* mutable_unsubscribe();
  inline ::pulsar::proto::CommandUnsubscribe* release_unsubscribe();
  inline void set_allocated_unsubscribe(::pulsar::proto::CommandUnsubscribe* unsubscribe);

  // optional .pulsar.proto.CommandSuccess success = 13;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 13;
  inline const ::pulsar::proto::CommandSuccess& success() const;
  inline ::pulsar::proto::CommandSuccess* mutable_success();
  inline ::pulsar::proto::CommandSuccess* release_success();
  inline void set_allocated_success(::pulsar::proto::CommandSuccess* success);

  // optional .pulsar.proto.CommandError error = 14;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 14;
  inline const ::pulsar::proto::CommandError& error() const;
  inline ::pulsar::proto::CommandError* mutable_error();
  inline ::pulsar::proto::CommandError* release_error();
  inline void set_allocated_error(::pulsar::proto::CommandError* error);

  // optional .pulsar.proto.CommandCloseProducer close_producer = 15;
  inline bool has_close_producer() const;
  inline void clear_close_producer();
  static const int kCloseProducerFieldNumber = 15;
  inline const ::pulsar::proto::CommandCloseProducer& close_producer() const;
  inline ::pulsar::proto::CommandCloseProducer* mutable_close_producer();
  inline ::pulsar::proto::CommandCloseProducer* release_close_producer();
  inline void set_allocated_close_producer(::pulsar::proto::CommandCloseProducer* close_producer);

  // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
  inline bool has_close_consumer() const;
  inline void clear_close_consumer();
  static const int kCloseConsumerFieldNumber = 16;
  inline const ::pulsar::proto::CommandCloseConsumer& close_consumer() const;
  inline ::pulsar::proto::CommandCloseConsumer* mutable_close_consumer();
  inline ::pulsar::proto::CommandCloseConsumer* release_close_consumer();
  inline void set_allocated_close_consumer(::pulsar::proto::CommandCloseConsumer* close_consumer);

  // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
  inline bool has_producer_success() const;
  inline void clear_producer_success();
  static const int kProducerSuccessFieldNumber = 17;
  inline const ::pulsar::proto::CommandProducerSuccess& producer_success() const;
  inline ::pulsar::proto::CommandProducerSuccess* mutable_producer_success();
  inline ::pulsar::proto::CommandProducerSuccess* release_producer_success();
  inline void set_allocated_producer_success(::pulsar::proto::CommandProducerSuccess* producer_success);

  // optional .pulsar.proto.CommandPing ping = 18;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 18;
  inline const ::pulsar::proto::CommandPing& ping() const;
  inline ::pulsar::proto::CommandPing* mutable_ping();
  inline ::pulsar::proto::CommandPing* release_ping();
  inline void set_allocated_ping(::pulsar::proto::CommandPing* ping);

  // optional .pulsar.proto.CommandPong pong = 19;
  inline bool has_pong() const;
  inline void clear_pong();
  static const int kPongFieldNumber = 19;
  inline const ::pulsar::proto::CommandPong& pong() const;
  inline ::pulsar::proto::CommandPong* mutable_pong();
  inline ::pulsar::proto::CommandPong* release_pong();
  inline void set_allocated_pong(::pulsar::proto::CommandPong* pong);

  // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
  inline bool has_redeliverunacknowledgedmessages() const;
  inline void clear_redeliverunacknowledgedmessages();
  static const int kRedeliverUnacknowledgedMessagesFieldNumber = 20;
  inline const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& redeliverunacknowledgedmessages() const;
  inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* mutable_redeliverunacknowledgedmessages();
  inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* release_redeliverunacknowledgedmessages();
  inline void set_allocated_redeliverunacknowledgedmessages(::pulsar::proto::CommandRedeliverUnacknowledgedMessages* redeliverunacknowledgedmessages);

  // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
  inline bool has_partitionmetadata() const;
  inline void clear_partitionmetadata();
  static const int kPartitionMetadataFieldNumber = 21;
  inline const ::pulsar::proto::CommandPartitionedTopicMetadata& partitionmetadata() const;
  inline ::pulsar::proto::CommandPartitionedTopicMetadata* mutable_partitionmetadata();
  inline ::pulsar::proto::CommandPartitionedTopicMetadata* release_partitionmetadata();
  inline void set_allocated_partitionmetadata(::pulsar::proto::CommandPartitionedTopicMetadata* partitionmetadata);

  // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
  inline bool has_partitionmetadataresponse() const;
  inline void clear_partitionmetadataresponse();
  static const int kPartitionMetadataResponseFieldNumber = 22;
  inline const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& partitionmetadataresponse() const;
  inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* mutable_partitionmetadataresponse();
  inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* release_partitionmetadataresponse();
  inline void set_allocated_partitionmetadataresponse(::pulsar::proto::CommandPartitionedTopicMetadataResponse* partitionmetadataresponse);

  // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
  inline bool has_lookuptopic() const;
  inline void clear_lookuptopic();
  static const int kLookupTopicFieldNumber = 23;
  inline const ::pulsar::proto::CommandLookupTopic& lookuptopic() const;
  inline ::pulsar::proto::CommandLookupTopic* mutable_lookuptopic();
  inline ::pulsar::proto::CommandLookupTopic* release_lookuptopic();
  inline void set_allocated_lookuptopic(::pulsar::proto::CommandLookupTopic* lookuptopic);

  // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
  inline bool has_lookuptopicresponse() const;
  inline void clear_lookuptopicresponse();
  static const int kLookupTopicResponseFieldNumber = 24;
  inline const ::pulsar::proto::CommandLookupTopicResponse& lookuptopicresponse() const;
  inline ::pulsar::proto::CommandLookupTopicResponse* mutable_lookuptopicresponse();
  inline ::pulsar::proto::CommandLookupTopicResponse* release_lookuptopicresponse();
  inline void set_allocated_lookuptopicresponse(::pulsar::proto::CommandLookupTopicResponse* lookuptopicresponse);

  // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
  inline bool has_consumerstats() const;
  inline void clear_consumerstats();
  static const int kConsumerStatsFieldNumber = 25;
  inline const ::pulsar::proto::CommandConsumerStats& consumerstats() const;
  inline ::pulsar::proto::CommandConsumerStats* mutable_consumerstats();
  inline ::pulsar::proto::CommandConsumerStats* release_consumerstats();
  inline void set_allocated_consumerstats(::pulsar::proto::CommandConsumerStats* consumerstats);

  // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
  inline bool has_consumerstatsresponse() const;
  inline void clear_consumerstatsresponse();
  static const int kConsumerStatsResponseFieldNumber = 26;
  inline const ::pulsar::proto::CommandConsumerStatsResponse& consumerstatsresponse() const;
  inline ::pulsar::proto::CommandConsumerStatsResponse* mutable_consumerstatsresponse();
  inline ::pulsar::proto::CommandConsumerStatsResponse* release_consumerstatsresponse();
  inline void set_allocated_consumerstatsresponse(::pulsar::proto::CommandConsumerStatsResponse* consumerstatsresponse);

  // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
  inline bool has_reachedendoftopic() const;
  inline void clear_reachedendoftopic();
  static const int kReachedEndOfTopicFieldNumber = 27;
  inline const ::pulsar::proto::CommandReachedEndOfTopic& reachedendoftopic() const;
  inline ::pulsar::proto::CommandReachedEndOfTopic* mutable_reachedendoftopic();
  inline ::pulsar::proto::CommandReachedEndOfTopic* release_reachedendoftopic();
  inline void set_allocated_reachedendoftopic(::pulsar::proto::CommandReachedEndOfTopic* reachedendoftopic);

  // optional .pulsar.proto.CommandSeek seek = 28;
  inline bool has_seek() const;
  inline void clear_seek();
  static const int kSeekFieldNumber = 28;
  inline const ::pulsar::proto::CommandSeek& seek() const;
  inline ::pulsar::proto::CommandSeek* mutable_seek();
  inline ::pulsar::proto::CommandSeek* release_seek();
  inline void set_allocated_seek(::pulsar::proto::CommandSeek* seek);

  // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
  inline bool has_getlastmessageid() const;
  inline void clear_getlastmessageid();
  static const int kGetLastMessageIdFieldNumber = 29;
  inline const ::pulsar::proto::CommandGetLastMessageId& getlastmessageid() const;
  inline ::pulsar::proto::CommandGetLastMessageId* mutable_getlastmessageid();
  inline ::pulsar::proto::CommandGetLastMessageId* release_getlastmessageid();
  inline void set_allocated_getlastmessageid(::pulsar::proto::CommandGetLastMessageId* getlastmessageid);

  // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
  inline bool has_getlastmessageidresponse() const;
  inline void clear_getlastmessageidresponse();
  static const int kGetLastMessageIdResponseFieldNumber = 30;
  inline const ::pulsar::proto::CommandGetLastMessageIdResponse& getlastmessageidresponse() const;
  inline ::pulsar::proto::CommandGetLastMessageIdResponse* mutable_getlastmessageidresponse();
  inline ::pulsar::proto::CommandGetLastMessageIdResponse* release_getlastmessageidresponse();
  inline void set_allocated_getlastmessageidresponse(::pulsar::proto::CommandGetLastMessageIdResponse* getlastmessageidresponse);

  // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
  inline bool has_active_consumer_change() const;
  inline void clear_active_consumer_change();
  static const int kActiveConsumerChangeFieldNumber = 31;
  inline const ::pulsar::proto::CommandActiveConsumerChange& active_consumer_change() const;
  inline ::pulsar::proto::CommandActiveConsumerChange* mutable_active_consumer_change();
  inline ::pulsar::proto::CommandActiveConsumerChange* release_active_consumer_change();
  inline void set_allocated_active_consumer_change(::pulsar::proto::CommandActiveConsumerChange* active_consumer_change);

  // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
  inline bool has_gettopicsofnamespace() const;
  inline void clear_gettopicsofnamespace();
  static const int kGetTopicsOfNamespaceFieldNumber = 32;
  inline const ::pulsar::proto::CommandGetTopicsOfNamespace& gettopicsofnamespace() const;
  inline ::pulsar::proto::CommandGetTopicsOfNamespace* mutable_gettopicsofnamespace();
  inline ::pulsar::proto::CommandGetTopicsOfNamespace* release_gettopicsofnamespace();
  inline void set_allocated_gettopicsofnamespace(::pulsar::proto::CommandGetTopicsOfNamespace* gettopicsofnamespace);

  // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
  inline bool has_gettopicsofnamespaceresponse() const;
  inline void clear_gettopicsofnamespaceresponse();
  static const int kGetTopicsOfNamespaceResponseFieldNumber = 33;
  inline const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& gettopicsofnamespaceresponse() const;
  inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* mutable_gettopicsofnamespaceresponse();
  inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* release_gettopicsofnamespaceresponse();
  inline void set_allocated_gettopicsofnamespaceresponse(::pulsar::proto::CommandGetTopicsOfNamespaceResponse* gettopicsofnamespaceresponse);

  // optional .pulsar.proto.CommandGetSchema getSchema = 34;
  inline bool has_getschema() const;
  inline void clear_getschema();
  static const int kGetSchemaFieldNumber = 34;
  inline const ::pulsar::proto::CommandGetSchema& getschema() const;
  inline ::pulsar::proto::CommandGetSchema* mutable_getschema();
  inline ::pulsar::proto::CommandGetSchema* release_getschema();
  inline void set_allocated_getschema(::pulsar::proto::CommandGetSchema* getschema);

  // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
  inline bool has_getschemaresponse() const;
  inline void clear_getschemaresponse();
  static const int kGetSchemaResponseFieldNumber = 35;
  inline const ::pulsar::proto::CommandGetSchemaResponse& getschemaresponse() const;
  inline ::pulsar::proto::CommandGetSchemaResponse* mutable_getschemaresponse();
  inline ::pulsar::proto::CommandGetSchemaResponse* release_getschemaresponse();
  inline void set_allocated_getschemaresponse(::pulsar::proto::CommandGetSchemaResponse* getschemaresponse);

  // optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
  inline bool has_authchallenge() const;
  inline void clear_authchallenge();
  static const int kAuthChallengeFieldNumber = 36;
  inline const ::pulsar::proto::CommandAuthChallenge& authchallenge() const;
  inline ::pulsar::proto::CommandAuthChallenge* mutable_authchallenge();
  inline ::pulsar::proto::CommandAuthChallenge* release_authchallenge();
  inline void set_allocated_authchallenge(::pulsar::proto::CommandAuthChallenge* authchallenge);

  // optional .pulsar.proto.CommandAuthResponse authResponse = 37;
  inline bool has_authresponse() const;
  inline void clear_authresponse();
  static const int kAuthResponseFieldNumber = 37;
  inline const ::pulsar::proto::CommandAuthResponse& authresponse() const;
  inline ::pulsar::proto::CommandAuthResponse* mutable_authresponse();
  inline ::pulsar::proto::CommandAuthResponse* release_authresponse();
  inline void set_allocated_authresponse(::pulsar::proto::CommandAuthResponse* authresponse);

  // @@protoc_insertion_point(class_scope:pulsar.proto.BaseCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_connect();
  inline void clear_has_connect();
  inline void set_has_connected();
  inline void clear_has_connected();
  inline void set_has_subscribe();
  inline void clear_has_subscribe();
  inline void set_has_producer();
  inline void clear_has_producer();
  inline void set_has_send();
  inline void clear_has_send();
  inline void set_has_send_receipt();
  inline void clear_has_send_receipt();
  inline void set_has_send_error();
  inline void clear_has_send_error();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_flow();
  inline void clear_has_flow();
  inline void set_has_unsubscribe();
  inline void clear_has_unsubscribe();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_close_producer();
  inline void clear_has_close_producer();
  inline void set_has_close_consumer();
  inline void clear_has_close_consumer();
  inline void set_has_producer_success();
  inline void clear_has_producer_success();
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_pong();
  inline void clear_has_pong();
  inline void set_has_redeliverunacknowledgedmessages();
  inline void clear_has_redeliverunacknowledgedmessages();
  inline void set_has_partitionmetadata();
  inline void clear_has_partitionmetadata();
  inline void set_has_partitionmetadataresponse();
  inline void clear_has_partitionmetadataresponse();
  inline void set_has_lookuptopic();
  inline void clear_has_lookuptopic();
  inline void set_has_lookuptopicresponse();
  inline void clear_has_lookuptopicresponse();
  inline void set_has_consumerstats();
  inline void clear_has_consumerstats();
  inline void set_has_consumerstatsresponse();
  inline void clear_has_consumerstatsresponse();
  inline void set_has_reachedendoftopic();
  inline void clear_has_reachedendoftopic();
  inline void set_has_seek();
  inline void clear_has_seek();
  inline void set_has_getlastmessageid();
  inline void clear_has_getlastmessageid();
  inline void set_has_getlastmessageidresponse();
  inline void clear_has_getlastmessageidresponse();
  inline void set_has_active_consumer_change();
  inline void clear_has_active_consumer_change();
  inline void set_has_gettopicsofnamespace();
  inline void clear_has_gettopicsofnamespace();
  inline void set_has_gettopicsofnamespaceresponse();
  inline void clear_has_gettopicsofnamespaceresponse();
  inline void set_has_getschema();
  inline void clear_has_getschema();
  inline void set_has_getschemaresponse();
  inline void clear_has_getschemaresponse();
  inline void set_has_authchallenge();
  inline void clear_has_authchallenge();
  inline void set_has_authresponse();
  inline void clear_has_authresponse();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  ::pulsar::proto::CommandConnect* connect_;
  ::pulsar::proto::CommandConnected* connected_;
  ::pulsar::proto::CommandSubscribe* subscribe_;
  ::pulsar::proto::CommandProducer* producer_;
  ::pulsar::proto::CommandSend* send_;
  ::pulsar::proto::CommandSendReceipt* send_receipt_;
  ::pulsar::proto::CommandSendError* send_error_;
  ::pulsar::proto::CommandMessage* message_;
  ::pulsar::proto::CommandAck* ack_;
  ::pulsar::proto::CommandFlow* flow_;
  ::pulsar::proto::CommandUnsubscribe* unsubscribe_;
  ::pulsar::proto::CommandSuccess* success_;
  ::pulsar::proto::CommandError* error_;
  ::pulsar::proto::CommandCloseProducer* close_producer_;
  ::pulsar::proto::CommandCloseConsumer* close_consumer_;
  ::pulsar::proto::CommandProducerSuccess* producer_success_;
  ::pulsar::proto::CommandPing* ping_;
  ::pulsar::proto::CommandPong* pong_;
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* redeliverunacknowledgedmessages_;
  ::pulsar::proto::CommandPartitionedTopicMetadata* partitionmetadata_;
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* partitionmetadataresponse_;
  ::pulsar::proto::CommandLookupTopic* lookuptopic_;
  ::pulsar::proto::CommandLookupTopicResponse* lookuptopicresponse_;
  ::pulsar::proto::CommandConsumerStats* consumerstats_;
  ::pulsar::proto::CommandConsumerStatsResponse* consumerstatsresponse_;
  ::pulsar::proto::CommandReachedEndOfTopic* reachedendoftopic_;
  ::pulsar::proto::CommandSeek* seek_;
  ::pulsar::proto::CommandGetLastMessageId* getlastmessageid_;
  ::pulsar::proto::CommandGetLastMessageIdResponse* getlastmessageidresponse_;
  ::pulsar::proto::CommandActiveConsumerChange* active_consumer_change_;
  ::pulsar::proto::CommandGetTopicsOfNamespace* gettopicsofnamespace_;
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* gettopicsofnamespaceresponse_;
  ::pulsar::proto::CommandGetSchema* getschema_;
  ::pulsar::proto::CommandGetSchemaResponse* getschemaresponse_;
  ::pulsar::proto::CommandAuthChallenge* authchallenge_;
  ::pulsar::proto::CommandAuthResponse* authresponse_;
  int type_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_PulsarApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_PulsarApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_PulsarApi_2eproto();
  friend void protobuf_ShutdownFile_PulsarApi_2eproto();

  void InitAsDefaultInstance();
  static BaseCommand* default_instance_;
};
// ===================================================================


// ===================================================================

// Schema

// required string name = 1;
inline bool Schema::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Schema::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Schema::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Schema::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Schema::name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.name)
  return *name_;
}
inline void Schema::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.Schema.name)
}
inline void Schema::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.Schema.name)
}
inline void Schema::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.Schema.name)
}
inline ::std::string* Schema::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Schema.name)
  return name_;
}
inline ::std::string* Schema::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Schema::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.Schema.name)
}

// required bytes schema_data = 3;
inline bool Schema::has_schema_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Schema::set_has_schema_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Schema::clear_has_schema_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Schema::clear_schema_data() {
  if (schema_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_data_->clear();
  }
  clear_has_schema_data();
}
inline const ::std::string& Schema::schema_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.schema_data)
  return *schema_data_;
}
inline void Schema::set_schema_data(const ::std::string& value) {
  set_has_schema_data();
  if (schema_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_data_ = new ::std::string;
  }
  schema_data_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.Schema.schema_data)
}
inline void Schema::set_schema_data(const char* value) {
  set_has_schema_data();
  if (schema_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_data_ = new ::std::string;
  }
  schema_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.Schema.schema_data)
}
inline void Schema::set_schema_data(const void* value, size_t size) {
  set_has_schema_data();
  if (schema_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_data_ = new ::std::string;
  }
  schema_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.Schema.schema_data)
}
inline ::std::string* Schema::mutable_schema_data() {
  set_has_schema_data();
  if (schema_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Schema.schema_data)
  return schema_data_;
}
inline ::std::string* Schema::release_schema_data() {
  clear_has_schema_data();
  if (schema_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_data_;
    schema_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Schema::set_allocated_schema_data(::std::string* schema_data) {
  if (schema_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_data_;
  }
  if (schema_data) {
    set_has_schema_data();
    schema_data_ = schema_data;
  } else {
    clear_has_schema_data();
    schema_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.Schema.schema_data)
}

// required .pulsar.proto.Schema.Type type = 4;
inline bool Schema::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Schema::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Schema::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Schema::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pulsar::proto::Schema_Type Schema::type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.type)
  return static_cast< ::pulsar::proto::Schema_Type >(type_);
}
inline void Schema::set_type(::pulsar::proto::Schema_Type value) {
  assert(::pulsar::proto::Schema_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.Schema.type)
}

// repeated .pulsar.proto.KeyValue properties = 5;
inline int Schema::properties_size() const {
  return properties_.size();
}
inline void Schema::clear_properties() {
  properties_.Clear();
}
inline const ::pulsar::proto::KeyValue& Schema::properties(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.properties)
  return properties_.Get(index);
}
inline ::pulsar::proto::KeyValue* Schema::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Schema.properties)
  return properties_.Mutable(index);
}
inline ::pulsar::proto::KeyValue* Schema::add_properties() {
  // @@protoc_insertion_point(field_add:pulsar.proto.Schema.properties)
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
Schema::properties() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.Schema.properties)
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
Schema::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.Schema.properties)
  return &properties_;
}

// -------------------------------------------------------------------

// MessageIdData

// required uint64 ledgerId = 1;
inline bool MessageIdData::has_ledgerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageIdData::set_has_ledgerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageIdData::clear_has_ledgerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageIdData::clear_ledgerid() {
  ledgerid_ = GOOGLE_ULONGLONG(0);
  clear_has_ledgerid();
}
inline ::google::protobuf::uint64 MessageIdData::ledgerid() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.ledgerId)
  return ledgerid_;
}
inline void MessageIdData::set_ledgerid(::google::protobuf::uint64 value) {
  set_has_ledgerid();
  ledgerid_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.ledgerId)
}

// required uint64 entryId = 2;
inline bool MessageIdData::has_entryid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageIdData::set_has_entryid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageIdData::clear_has_entryid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageIdData::clear_entryid() {
  entryid_ = GOOGLE_ULONGLONG(0);
  clear_has_entryid();
}
inline ::google::protobuf::uint64 MessageIdData::entryid() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.entryId)
  return entryid_;
}
inline void MessageIdData::set_entryid(::google::protobuf::uint64 value) {
  set_has_entryid();
  entryid_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.entryId)
}

// optional int32 partition = 3 [default = -1];
inline bool MessageIdData::has_partition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageIdData::set_has_partition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageIdData::clear_has_partition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageIdData::clear_partition() {
  partition_ = -1;
  clear_has_partition();
}
inline ::google::protobuf::int32 MessageIdData::partition() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.partition)
  return partition_;
}
inline void MessageIdData::set_partition(::google::protobuf::int32 value) {
  set_has_partition();
  partition_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.partition)
}

// optional int32 batch_index = 4 [default = -1];
inline bool MessageIdData::has_batch_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageIdData::set_has_batch_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageIdData::clear_has_batch_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageIdData::clear_batch_index() {
  batch_index_ = -1;
  clear_has_batch_index();
}
inline ::google::protobuf::int32 MessageIdData::batch_index() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.batch_index)
  return batch_index_;
}
inline void MessageIdData::set_batch_index(::google::protobuf::int32 value) {
  set_has_batch_index();
  batch_index_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.batch_index)
}

// -------------------------------------------------------------------

// KeyValue

// required string key = 1;
inline bool KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyValue.key)
  return *key_;
}
inline void KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyValue.key)
}
inline void KeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.KeyValue.key)
}
inline void KeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.KeyValue.key)
}
inline ::std::string* KeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeyValue.key)
  return key_;
}
inline ::std::string* KeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.KeyValue.key)
}

// required string value = 2;
inline bool KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& KeyValue::value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyValue.value)
  return *value_;
}
inline void KeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyValue.value)
}
inline void KeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.KeyValue.value)
}
inline void KeyValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.KeyValue.value)
}
inline ::std::string* KeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeyValue.value)
  return value_;
}
inline ::std::string* KeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.KeyValue.value)
}

// -------------------------------------------------------------------

// KeyLongValue

// required string key = 1;
inline bool KeyLongValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyLongValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyLongValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyLongValue::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& KeyLongValue::key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyLongValue.key)
  return *key_;
}
inline void KeyLongValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyLongValue.key)
}
inline void KeyLongValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.KeyLongValue.key)
}
inline void KeyLongValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.KeyLongValue.key)
}
inline ::std::string* KeyLongValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeyLongValue.key)
  return key_;
}
inline ::std::string* KeyLongValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyLongValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.KeyLongValue.key)
}

// required uint64 value = 2;
inline bool KeyLongValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyLongValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyLongValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyLongValue::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 KeyLongValue::value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyLongValue.value)
  return value_;
}
inline void KeyLongValue::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyLongValue.value)
}

// -------------------------------------------------------------------

// EncryptionKeys

// required string key = 1;
inline bool EncryptionKeys::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptionKeys::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptionKeys::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptionKeys::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& EncryptionKeys::key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.EncryptionKeys.key)
  return *key_;
}
inline void EncryptionKeys::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.EncryptionKeys.key)
}
inline void EncryptionKeys::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.EncryptionKeys.key)
}
inline void EncryptionKeys::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.EncryptionKeys.key)
}
inline ::std::string* EncryptionKeys::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.EncryptionKeys.key)
  return key_;
}
inline ::std::string* EncryptionKeys::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EncryptionKeys::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.EncryptionKeys.key)
}

// required bytes value = 2;
inline bool EncryptionKeys::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptionKeys::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncryptionKeys::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncryptionKeys::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& EncryptionKeys::value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.EncryptionKeys.value)
  return *value_;
}
inline void EncryptionKeys::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.EncryptionKeys.value)
}
inline void EncryptionKeys::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.EncryptionKeys.value)
}
inline void EncryptionKeys::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.EncryptionKeys.value)
}
inline ::std::string* EncryptionKeys::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.EncryptionKeys.value)
  return value_;
}
inline ::std::string* EncryptionKeys::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EncryptionKeys::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.EncryptionKeys.value)
}

// repeated .pulsar.proto.KeyValue metadata = 3;
inline int EncryptionKeys::metadata_size() const {
  return metadata_.size();
}
inline void EncryptionKeys::clear_metadata() {
  metadata_.Clear();
}
inline const ::pulsar::proto::KeyValue& EncryptionKeys::metadata(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.EncryptionKeys.metadata)
  return metadata_.Get(index);
}
inline ::pulsar::proto::KeyValue* EncryptionKeys::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.EncryptionKeys.metadata)
  return metadata_.Mutable(index);
}
inline ::pulsar::proto::KeyValue* EncryptionKeys::add_metadata() {
  // @@protoc_insertion_point(field_add:pulsar.proto.EncryptionKeys.metadata)
  return metadata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
EncryptionKeys::metadata() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.EncryptionKeys.metadata)
  return metadata_;
}
inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
EncryptionKeys::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.EncryptionKeys.metadata)
  return &metadata_;
}

// -------------------------------------------------------------------

// MessageMetadata

// required string producer_name = 1;
inline bool MessageMetadata::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageMetadata::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageMetadata::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageMetadata::clear_producer_name() {
  if (producer_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_->clear();
  }
  clear_has_producer_name();
}
inline const ::std::string& MessageMetadata::producer_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.producer_name)
  return *producer_name_;
}
inline void MessageMetadata::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  producer_name_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.producer_name)
}
inline void MessageMetadata::set_producer_name(const char* value) {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  producer_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.MessageMetadata.producer_name)
}
inline void MessageMetadata::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  producer_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.MessageMetadata.producer_name)
}
inline ::std::string* MessageMetadata::mutable_producer_name() {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.producer_name)
  return producer_name_;
}
inline ::std::string* MessageMetadata::release_producer_name() {
  clear_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = producer_name_;
    producer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageMetadata::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete producer_name_;
  }
  if (producer_name) {
    set_has_producer_name();
    producer_name_ = producer_name;
  } else {
    clear_has_producer_name();
    producer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.producer_name)
}

// required uint64 sequence_id = 2;
inline bool MessageMetadata::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageMetadata::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageMetadata::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageMetadata::clear_sequence_id() {
  sequence_id_ = GOOGLE_ULONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::uint64 MessageMetadata::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.sequence_id)
  return sequence_id_;
}
inline void MessageMetadata::set_sequence_id(::google::protobuf::uint64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.sequence_id)
}

// required uint64 publish_time = 3;
inline bool MessageMetadata::has_publish_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageMetadata::set_has_publish_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageMetadata::clear_has_publish_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageMetadata::clear_publish_time() {
  publish_time_ = GOOGLE_ULONGLONG(0);
  clear_has_publish_time();
}
inline ::google::protobuf::uint64 MessageMetadata::publish_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.publish_time)
  return publish_time_;
}
inline void MessageMetadata::set_publish_time(::google::protobuf::uint64 value) {
  set_has_publish_time();
  publish_time_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.publish_time)
}

// repeated .pulsar.proto.KeyValue properties = 4;
inline int MessageMetadata::properties_size() const {
  return properties_.size();
}
inline void MessageMetadata::clear_properties() {
  properties_.Clear();
}
inline const ::pulsar::proto::KeyValue& MessageMetadata::properties(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.properties)
  return properties_.Get(index);
}
inline ::pulsar::proto::KeyValue* MessageMetadata::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.properties)
  return properties_.Mutable(index);
}
inline ::pulsar::proto::KeyValue* MessageMetadata::add_properties() {
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.properties)
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
MessageMetadata::properties() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageMetadata.properties)
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
MessageMetadata::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageMetadata.properties)
  return &properties_;
}

// optional string replicated_from = 5;
inline bool MessageMetadata::has_replicated_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageMetadata::set_has_replicated_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageMetadata::clear_has_replicated_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageMetadata::clear_replicated_from() {
  if (replicated_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replicated_from_->clear();
  }
  clear_has_replicated_from();
}
inline const ::std::string& MessageMetadata::replicated_from() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.replicated_from)
  return *replicated_from_;
}
inline void MessageMetadata::set_replicated_from(const ::std::string& value) {
  set_has_replicated_from();
  if (replicated_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replicated_from_ = new ::std::string;
  }
  replicated_from_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.replicated_from)
}
inline void MessageMetadata::set_replicated_from(const char* value) {
  set_has_replicated_from();
  if (replicated_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replicated_from_ = new ::std::string;
  }
  replicated_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.MessageMetadata.replicated_from)
}
inline void MessageMetadata::set_replicated_from(const char* value, size_t size) {
  set_has_replicated_from();
  if (replicated_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replicated_from_ = new ::std::string;
  }
  replicated_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.MessageMetadata.replicated_from)
}
inline ::std::string* MessageMetadata::mutable_replicated_from() {
  set_has_replicated_from();
  if (replicated_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replicated_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.replicated_from)
  return replicated_from_;
}
inline ::std::string* MessageMetadata::release_replicated_from() {
  clear_has_replicated_from();
  if (replicated_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = replicated_from_;
    replicated_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageMetadata::set_allocated_replicated_from(::std::string* replicated_from) {
  if (replicated_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete replicated_from_;
  }
  if (replicated_from) {
    set_has_replicated_from();
    replicated_from_ = replicated_from;
  } else {
    clear_has_replicated_from();
    replicated_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.replicated_from)
}

// optional string partition_key = 6;
inline bool MessageMetadata::has_partition_key() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageMetadata::set_has_partition_key() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageMetadata::clear_has_partition_key() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageMetadata::clear_partition_key() {
  if (partition_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_key_->clear();
  }
  clear_has_partition_key();
}
inline const ::std::string& MessageMetadata::partition_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.partition_key)
  return *partition_key_;
}
inline void MessageMetadata::set_partition_key(const ::std::string& value) {
  set_has_partition_key();
  if (partition_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_key_ = new ::std::string;
  }
  partition_key_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.partition_key)
}
inline void MessageMetadata::set_partition_key(const char* value) {
  set_has_partition_key();
  if (partition_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_key_ = new ::std::string;
  }
  partition_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.MessageMetadata.partition_key)
}
inline void MessageMetadata::set_partition_key(const char* value, size_t size) {
  set_has_partition_key();
  if (partition_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_key_ = new ::std::string;
  }
  partition_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.MessageMetadata.partition_key)
}
inline ::std::string* MessageMetadata::mutable_partition_key() {
  set_has_partition_key();
  if (partition_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.partition_key)
  return partition_key_;
}
inline ::std::string* MessageMetadata::release_partition_key() {
  clear_has_partition_key();
  if (partition_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = partition_key_;
    partition_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageMetadata::set_allocated_partition_key(::std::string* partition_key) {
  if (partition_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete partition_key_;
  }
  if (partition_key) {
    set_has_partition_key();
    partition_key_ = partition_key;
  } else {
    clear_has_partition_key();
    partition_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.partition_key)
}

// repeated string replicate_to = 7;
inline int MessageMetadata::replicate_to_size() const {
  return replicate_to_.size();
}
inline void MessageMetadata::clear_replicate_to() {
  replicate_to_.Clear();
}
inline const ::std::string& MessageMetadata::replicate_to(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.replicate_to)
  return replicate_to_.Get(index);
}
inline ::std::string* MessageMetadata::mutable_replicate_to(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.replicate_to)
  return replicate_to_.Mutable(index);
}
inline void MessageMetadata::set_replicate_to(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.replicate_to)
  replicate_to_.Mutable(index)->assign(value);
}
inline void MessageMetadata::set_replicate_to(int index, const char* value) {
  replicate_to_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::set_replicate_to(int index, const char* value, size_t size) {
  replicate_to_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.MessageMetadata.replicate_to)
}
inline ::std::string* MessageMetadata::add_replicate_to() {
  return replicate_to_.Add();
}
inline void MessageMetadata::add_replicate_to(const ::std::string& value) {
  replicate_to_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::add_replicate_to(const char* value) {
  replicate_to_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::add_replicate_to(const char* value, size_t size) {
  replicate_to_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.MessageMetadata.replicate_to)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessageMetadata::replicate_to() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageMetadata.replicate_to)
  return replicate_to_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessageMetadata::mutable_replicate_to() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageMetadata.replicate_to)
  return &replicate_to_;
}

// optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
inline bool MessageMetadata::has_compression() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MessageMetadata::set_has_compression() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MessageMetadata::clear_has_compression() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MessageMetadata::clear_compression() {
  compression_ = 0;
  clear_has_compression();
}
inline ::pulsar::proto::CompressionType MessageMetadata::compression() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.compression)
  return static_cast< ::pulsar::proto::CompressionType >(compression_);
}
inline void MessageMetadata::set_compression(::pulsar::proto::CompressionType value) {
  assert(::pulsar::proto::CompressionType_IsValid(value));
  set_has_compression();
  compression_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.compression)
}

// optional uint32 uncompressed_size = 9 [default = 0];
inline bool MessageMetadata::has_uncompressed_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MessageMetadata::set_has_uncompressed_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MessageMetadata::clear_has_uncompressed_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MessageMetadata::clear_uncompressed_size() {
  uncompressed_size_ = 0u;
  clear_has_uncompressed_size();
}
inline ::google::protobuf::uint32 MessageMetadata::uncompressed_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.uncompressed_size)
  return uncompressed_size_;
}
inline void MessageMetadata::set_uncompressed_size(::google::protobuf::uint32 value) {
  set_has_uncompressed_size();
  uncompressed_size_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.uncompressed_size)
}

// optional int32 num_messages_in_batch = 11 [default = 1];
inline bool MessageMetadata::has_num_messages_in_batch() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MessageMetadata::set_has_num_messages_in_batch() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MessageMetadata::clear_has_num_messages_in_batch() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MessageMetadata::clear_num_messages_in_batch() {
  num_messages_in_batch_ = 1;
  clear_has_num_messages_in_batch();
}
inline ::google::protobuf::int32 MessageMetadata::num_messages_in_batch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.num_messages_in_batch)
  return num_messages_in_batch_;
}
inline void MessageMetadata::set_num_messages_in_batch(::google::protobuf::int32 value) {
  set_has_num_messages_in_batch();
  num_messages_in_batch_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.num_messages_in_batch)
}

// optional uint64 event_time = 12 [default = 0];
inline bool MessageMetadata::has_event_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MessageMetadata::set_has_event_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MessageMetadata::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MessageMetadata::clear_event_time() {
  event_time_ = GOOGLE_ULONGLONG(0);
  clear_has_event_time();
}
inline ::google::protobuf::uint64 MessageMetadata::event_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.event_time)
  return event_time_;
}
inline void MessageMetadata::set_event_time(::google::protobuf::uint64 value) {
  set_has_event_time();
  event_time_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.event_time)
}

// repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
inline int MessageMetadata::encryption_keys_size() const {
  return encryption_keys_.size();
}
inline void MessageMetadata::clear_encryption_keys() {
  encryption_keys_.Clear();
}
inline const ::pulsar::proto::EncryptionKeys& MessageMetadata::encryption_keys(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.encryption_keys)
  return encryption_keys_.Get(index);
}
inline ::pulsar::proto::EncryptionKeys* MessageMetadata::mutable_encryption_keys(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.encryption_keys)
  return encryption_keys_.Mutable(index);
}
inline ::pulsar::proto::EncryptionKeys* MessageMetadata::add_encryption_keys() {
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.encryption_keys)
  return encryption_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::EncryptionKeys >&
MessageMetadata::encryption_keys() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageMetadata.encryption_keys)
  return encryption_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::EncryptionKeys >*
MessageMetadata::mutable_encryption_keys() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageMetadata.encryption_keys)
  return &encryption_keys_;
}

// optional string encryption_algo = 14;
inline bool MessageMetadata::has_encryption_algo() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MessageMetadata::set_has_encryption_algo() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MessageMetadata::clear_has_encryption_algo() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MessageMetadata::clear_encryption_algo() {
  if (encryption_algo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryption_algo_->clear();
  }
  clear_has_encryption_algo();
}
inline const ::std::string& MessageMetadata::encryption_algo() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.encryption_algo)
  return *encryption_algo_;
}
inline void MessageMetadata::set_encryption_algo(const ::std::string& value) {
  set_has_encryption_algo();
  if (encryption_algo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryption_algo_ = new ::std::string;
  }
  encryption_algo_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.encryption_algo)
}
inline void MessageMetadata::set_encryption_algo(const char* value) {
  set_has_encryption_algo();
  if (encryption_algo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryption_algo_ = new ::std::string;
  }
  encryption_algo_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.MessageMetadata.encryption_algo)
}
inline void MessageMetadata::set_encryption_algo(const char* value, size_t size) {
  set_has_encryption_algo();
  if (encryption_algo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryption_algo_ = new ::std::string;
  }
  encryption_algo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.MessageMetadata.encryption_algo)
}
inline ::std::string* MessageMetadata::mutable_encryption_algo() {
  set_has_encryption_algo();
  if (encryption_algo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryption_algo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.encryption_algo)
  return encryption_algo_;
}
inline ::std::string* MessageMetadata::release_encryption_algo() {
  clear_has_encryption_algo();
  if (encryption_algo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encryption_algo_;
    encryption_algo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageMetadata::set_allocated_encryption_algo(::std::string* encryption_algo) {
  if (encryption_algo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encryption_algo_;
  }
  if (encryption_algo) {
    set_has_encryption_algo();
    encryption_algo_ = encryption_algo;
  } else {
    clear_has_encryption_algo();
    encryption_algo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.encryption_algo)
}

// optional bytes encryption_param = 15;
inline bool MessageMetadata::has_encryption_param() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MessageMetadata::set_has_encryption_param() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MessageMetadata::clear_has_encryption_param() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MessageMetadata::clear_encryption_param() {
  if (encryption_param_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryption_param_->clear();
  }
  clear_has_encryption_param();
}
inline const ::std::string& MessageMetadata::encryption_param() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.encryption_param)
  return *encryption_param_;
}
inline void MessageMetadata::set_encryption_param(const ::std::string& value) {
  set_has_encryption_param();
  if (encryption_param_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryption_param_ = new ::std::string;
  }
  encryption_param_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.encryption_param)
}
inline void MessageMetadata::set_encryption_param(const char* value) {
  set_has_encryption_param();
  if (encryption_param_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryption_param_ = new ::std::string;
  }
  encryption_param_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.MessageMetadata.encryption_param)
}
inline void MessageMetadata::set_encryption_param(const void* value, size_t size) {
  set_has_encryption_param();
  if (encryption_param_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryption_param_ = new ::std::string;
  }
  encryption_param_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.MessageMetadata.encryption_param)
}
inline ::std::string* MessageMetadata::mutable_encryption_param() {
  set_has_encryption_param();
  if (encryption_param_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryption_param_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.encryption_param)
  return encryption_param_;
}
inline ::std::string* MessageMetadata::release_encryption_param() {
  clear_has_encryption_param();
  if (encryption_param_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encryption_param_;
    encryption_param_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageMetadata::set_allocated_encryption_param(::std::string* encryption_param) {
  if (encryption_param_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encryption_param_;
  }
  if (encryption_param) {
    set_has_encryption_param();
    encryption_param_ = encryption_param;
  } else {
    clear_has_encryption_param();
    encryption_param_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.encryption_param)
}

// optional bytes schema_version = 16;
inline bool MessageMetadata::has_schema_version() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MessageMetadata::set_has_schema_version() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MessageMetadata::clear_has_schema_version() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MessageMetadata::clear_schema_version() {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_->clear();
  }
  clear_has_schema_version();
}
inline const ::std::string& MessageMetadata::schema_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.schema_version)
  return *schema_version_;
}
inline void MessageMetadata::set_schema_version(const ::std::string& value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.schema_version)
}
inline void MessageMetadata::set_schema_version(const char* value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.MessageMetadata.schema_version)
}
inline void MessageMetadata::set_schema_version(const void* value, size_t size) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.MessageMetadata.schema_version)
}
inline ::std::string* MessageMetadata::mutable_schema_version() {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.schema_version)
  return schema_version_;
}
inline ::std::string* MessageMetadata::release_schema_version() {
  clear_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_version_;
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageMetadata::set_allocated_schema_version(::std::string* schema_version) {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_version_;
  }
  if (schema_version) {
    set_has_schema_version();
    schema_version_ = schema_version;
  } else {
    clear_has_schema_version();
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.schema_version)
}

// optional bool partition_key_b64_encoded = 17 [default = false];
inline bool MessageMetadata::has_partition_key_b64_encoded() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MessageMetadata::set_has_partition_key_b64_encoded() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MessageMetadata::clear_has_partition_key_b64_encoded() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MessageMetadata::clear_partition_key_b64_encoded() {
  partition_key_b64_encoded_ = false;
  clear_has_partition_key_b64_encoded();
}
inline bool MessageMetadata::partition_key_b64_encoded() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.partition_key_b64_encoded)
  return partition_key_b64_encoded_;
}
inline void MessageMetadata::set_partition_key_b64_encoded(bool value) {
  set_has_partition_key_b64_encoded();
  partition_key_b64_encoded_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.partition_key_b64_encoded)
}

// optional bytes ordering_key = 18;
inline bool MessageMetadata::has_ordering_key() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MessageMetadata::set_has_ordering_key() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MessageMetadata::clear_has_ordering_key() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MessageMetadata::clear_ordering_key() {
  if (ordering_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordering_key_->clear();
  }
  clear_has_ordering_key();
}
inline const ::std::string& MessageMetadata::ordering_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.ordering_key)
  return *ordering_key_;
}
inline void MessageMetadata::set_ordering_key(const ::std::string& value) {
  set_has_ordering_key();
  if (ordering_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordering_key_ = new ::std::string;
  }
  ordering_key_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.ordering_key)
}
inline void MessageMetadata::set_ordering_key(const char* value) {
  set_has_ordering_key();
  if (ordering_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordering_key_ = new ::std::string;
  }
  ordering_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.MessageMetadata.ordering_key)
}
inline void MessageMetadata::set_ordering_key(const void* value, size_t size) {
  set_has_ordering_key();
  if (ordering_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordering_key_ = new ::std::string;
  }
  ordering_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.MessageMetadata.ordering_key)
}
inline ::std::string* MessageMetadata::mutable_ordering_key() {
  set_has_ordering_key();
  if (ordering_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordering_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.ordering_key)
  return ordering_key_;
}
inline ::std::string* MessageMetadata::release_ordering_key() {
  clear_has_ordering_key();
  if (ordering_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ordering_key_;
    ordering_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageMetadata::set_allocated_ordering_key(::std::string* ordering_key) {
  if (ordering_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ordering_key_;
  }
  if (ordering_key) {
    set_has_ordering_key();
    ordering_key_ = ordering_key;
  } else {
    clear_has_ordering_key();
    ordering_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.ordering_key)
}

// optional int64 deliver_at_time = 19;
inline bool MessageMetadata::has_deliver_at_time() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MessageMetadata::set_has_deliver_at_time() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MessageMetadata::clear_has_deliver_at_time() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MessageMetadata::clear_deliver_at_time() {
  deliver_at_time_ = GOOGLE_LONGLONG(0);
  clear_has_deliver_at_time();
}
inline ::google::protobuf::int64 MessageMetadata::deliver_at_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.deliver_at_time)
  return deliver_at_time_;
}
inline void MessageMetadata::set_deliver_at_time(::google::protobuf::int64 value) {
  set_has_deliver_at_time();
  deliver_at_time_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.deliver_at_time)
}

// optional int32 marker_type = 20;
inline bool MessageMetadata::has_marker_type() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MessageMetadata::set_has_marker_type() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MessageMetadata::clear_has_marker_type() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MessageMetadata::clear_marker_type() {
  marker_type_ = 0;
  clear_has_marker_type();
}
inline ::google::protobuf::int32 MessageMetadata::marker_type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.marker_type)
  return marker_type_;
}
inline void MessageMetadata::set_marker_type(::google::protobuf::int32 value) {
  set_has_marker_type();
  marker_type_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.marker_type)
}

// -------------------------------------------------------------------

// SingleMessageMetadata

// repeated .pulsar.proto.KeyValue properties = 1;
inline int SingleMessageMetadata::properties_size() const {
  return properties_.size();
}
inline void SingleMessageMetadata::clear_properties() {
  properties_.Clear();
}
inline const ::pulsar::proto::KeyValue& SingleMessageMetadata::properties(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.properties)
  return properties_.Get(index);
}
inline ::pulsar::proto::KeyValue* SingleMessageMetadata::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.SingleMessageMetadata.properties)
  return properties_.Mutable(index);
}
inline ::pulsar::proto::KeyValue* SingleMessageMetadata::add_properties() {
  // @@protoc_insertion_point(field_add:pulsar.proto.SingleMessageMetadata.properties)
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
SingleMessageMetadata::properties() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.SingleMessageMetadata.properties)
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
SingleMessageMetadata::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.SingleMessageMetadata.properties)
  return &properties_;
}

// optional string partition_key = 2;
inline bool SingleMessageMetadata::has_partition_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleMessageMetadata::set_has_partition_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleMessageMetadata::clear_has_partition_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleMessageMetadata::clear_partition_key() {
  if (partition_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_key_->clear();
  }
  clear_has_partition_key();
}
inline const ::std::string& SingleMessageMetadata::partition_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.partition_key)
  return *partition_key_;
}
inline void SingleMessageMetadata::set_partition_key(const ::std::string& value) {
  set_has_partition_key();
  if (partition_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_key_ = new ::std::string;
  }
  partition_key_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.partition_key)
}
inline void SingleMessageMetadata::set_partition_key(const char* value) {
  set_has_partition_key();
  if (partition_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_key_ = new ::std::string;
  }
  partition_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.SingleMessageMetadata.partition_key)
}
inline void SingleMessageMetadata::set_partition_key(const char* value, size_t size) {
  set_has_partition_key();
  if (partition_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_key_ = new ::std::string;
  }
  partition_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.SingleMessageMetadata.partition_key)
}
inline ::std::string* SingleMessageMetadata::mutable_partition_key() {
  set_has_partition_key();
  if (partition_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.SingleMessageMetadata.partition_key)
  return partition_key_;
}
inline ::std::string* SingleMessageMetadata::release_partition_key() {
  clear_has_partition_key();
  if (partition_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = partition_key_;
    partition_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SingleMessageMetadata::set_allocated_partition_key(::std::string* partition_key) {
  if (partition_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete partition_key_;
  }
  if (partition_key) {
    set_has_partition_key();
    partition_key_ = partition_key;
  } else {
    clear_has_partition_key();
    partition_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.SingleMessageMetadata.partition_key)
}

// required int32 payload_size = 3;
inline bool SingleMessageMetadata::has_payload_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SingleMessageMetadata::set_has_payload_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SingleMessageMetadata::clear_has_payload_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SingleMessageMetadata::clear_payload_size() {
  payload_size_ = 0;
  clear_has_payload_size();
}
inline ::google::protobuf::int32 SingleMessageMetadata::payload_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.payload_size)
  return payload_size_;
}
inline void SingleMessageMetadata::set_payload_size(::google::protobuf::int32 value) {
  set_has_payload_size();
  payload_size_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.payload_size)
}

// optional bool compacted_out = 4 [default = false];
inline bool SingleMessageMetadata::has_compacted_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SingleMessageMetadata::set_has_compacted_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SingleMessageMetadata::clear_has_compacted_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SingleMessageMetadata::clear_compacted_out() {
  compacted_out_ = false;
  clear_has_compacted_out();
}
inline bool SingleMessageMetadata::compacted_out() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.compacted_out)
  return compacted_out_;
}
inline void SingleMessageMetadata::set_compacted_out(bool value) {
  set_has_compacted_out();
  compacted_out_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.compacted_out)
}

// optional uint64 event_time = 5 [default = 0];
inline bool SingleMessageMetadata::has_event_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SingleMessageMetadata::set_has_event_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SingleMessageMetadata::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SingleMessageMetadata::clear_event_time() {
  event_time_ = GOOGLE_ULONGLONG(0);
  clear_has_event_time();
}
inline ::google::protobuf::uint64 SingleMessageMetadata::event_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.event_time)
  return event_time_;
}
inline void SingleMessageMetadata::set_event_time(::google::protobuf::uint64 value) {
  set_has_event_time();
  event_time_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.event_time)
}

// optional bool partition_key_b64_encoded = 6 [default = false];
inline bool SingleMessageMetadata::has_partition_key_b64_encoded() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SingleMessageMetadata::set_has_partition_key_b64_encoded() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SingleMessageMetadata::clear_has_partition_key_b64_encoded() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SingleMessageMetadata::clear_partition_key_b64_encoded() {
  partition_key_b64_encoded_ = false;
  clear_has_partition_key_b64_encoded();
}
inline bool SingleMessageMetadata::partition_key_b64_encoded() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.partition_key_b64_encoded)
  return partition_key_b64_encoded_;
}
inline void SingleMessageMetadata::set_partition_key_b64_encoded(bool value) {
  set_has_partition_key_b64_encoded();
  partition_key_b64_encoded_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.partition_key_b64_encoded)
}

// optional bytes ordering_key = 7;
inline bool SingleMessageMetadata::has_ordering_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SingleMessageMetadata::set_has_ordering_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SingleMessageMetadata::clear_has_ordering_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SingleMessageMetadata::clear_ordering_key() {
  if (ordering_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordering_key_->clear();
  }
  clear_has_ordering_key();
}
inline const ::std::string& SingleMessageMetadata::ordering_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.ordering_key)
  return *ordering_key_;
}
inline void SingleMessageMetadata::set_ordering_key(const ::std::string& value) {
  set_has_ordering_key();
  if (ordering_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordering_key_ = new ::std::string;
  }
  ordering_key_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.ordering_key)
}
inline void SingleMessageMetadata::set_ordering_key(const char* value) {
  set_has_ordering_key();
  if (ordering_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordering_key_ = new ::std::string;
  }
  ordering_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.SingleMessageMetadata.ordering_key)
}
inline void SingleMessageMetadata::set_ordering_key(const void* value, size_t size) {
  set_has_ordering_key();
  if (ordering_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordering_key_ = new ::std::string;
  }
  ordering_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.SingleMessageMetadata.ordering_key)
}
inline ::std::string* SingleMessageMetadata::mutable_ordering_key() {
  set_has_ordering_key();
  if (ordering_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ordering_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.SingleMessageMetadata.ordering_key)
  return ordering_key_;
}
inline ::std::string* SingleMessageMetadata::release_ordering_key() {
  clear_has_ordering_key();
  if (ordering_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ordering_key_;
    ordering_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SingleMessageMetadata::set_allocated_ordering_key(::std::string* ordering_key) {
  if (ordering_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ordering_key_;
  }
  if (ordering_key) {
    set_has_ordering_key();
    ordering_key_ = ordering_key;
  } else {
    clear_has_ordering_key();
    ordering_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.SingleMessageMetadata.ordering_key)
}

// -------------------------------------------------------------------

// CommandConnect

// required string client_version = 1;
inline bool CommandConnect::has_client_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandConnect::set_has_client_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandConnect::clear_has_client_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandConnect::clear_client_version() {
  if (client_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_->clear();
  }
  clear_has_client_version();
}
inline const ::std::string& CommandConnect::client_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.client_version)
  return *client_version_;
}
inline void CommandConnect::set_client_version(const ::std::string& value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.client_version)
}
inline void CommandConnect::set_client_version(const char* value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConnect.client_version)
}
inline void CommandConnect::set_client_version(const char* value, size_t size) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConnect.client_version)
}
inline ::std::string* CommandConnect::mutable_client_version() {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.client_version)
  return client_version_;
}
inline ::std::string* CommandConnect::release_client_version() {
  clear_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_version_;
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConnect::set_allocated_client_version(::std::string* client_version) {
  if (client_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_version_;
  }
  if (client_version) {
    set_has_client_version();
    client_version_ = client_version;
  } else {
    clear_has_client_version();
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.client_version)
}

// optional .pulsar.proto.AuthMethod auth_method = 2;
inline bool CommandConnect::has_auth_method() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandConnect::set_has_auth_method() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandConnect::clear_has_auth_method() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandConnect::clear_auth_method() {
  auth_method_ = 0;
  clear_has_auth_method();
}
inline ::pulsar::proto::AuthMethod CommandConnect::auth_method() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.auth_method)
  return static_cast< ::pulsar::proto::AuthMethod >(auth_method_);
}
inline void CommandConnect::set_auth_method(::pulsar::proto::AuthMethod value) {
  assert(::pulsar::proto::AuthMethod_IsValid(value));
  set_has_auth_method();
  auth_method_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.auth_method)
}

// optional string auth_method_name = 5;
inline bool CommandConnect::has_auth_method_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandConnect::set_has_auth_method_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandConnect::clear_has_auth_method_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandConnect::clear_auth_method_name() {
  if (auth_method_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_method_name_->clear();
  }
  clear_has_auth_method_name();
}
inline const ::std::string& CommandConnect::auth_method_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.auth_method_name)
  return *auth_method_name_;
}
inline void CommandConnect::set_auth_method_name(const ::std::string& value) {
  set_has_auth_method_name();
  if (auth_method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_method_name_ = new ::std::string;
  }
  auth_method_name_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.auth_method_name)
}
inline void CommandConnect::set_auth_method_name(const char* value) {
  set_has_auth_method_name();
  if (auth_method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_method_name_ = new ::std::string;
  }
  auth_method_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConnect.auth_method_name)
}
inline void CommandConnect::set_auth_method_name(const char* value, size_t size) {
  set_has_auth_method_name();
  if (auth_method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_method_name_ = new ::std::string;
  }
  auth_method_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConnect.auth_method_name)
}
inline ::std::string* CommandConnect::mutable_auth_method_name() {
  set_has_auth_method_name();
  if (auth_method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_method_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.auth_method_name)
  return auth_method_name_;
}
inline ::std::string* CommandConnect::release_auth_method_name() {
  clear_has_auth_method_name();
  if (auth_method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = auth_method_name_;
    auth_method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConnect::set_allocated_auth_method_name(::std::string* auth_method_name) {
  if (auth_method_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete auth_method_name_;
  }
  if (auth_method_name) {
    set_has_auth_method_name();
    auth_method_name_ = auth_method_name;
  } else {
    clear_has_auth_method_name();
    auth_method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.auth_method_name)
}

// optional bytes auth_data = 3;
inline bool CommandConnect::has_auth_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandConnect::set_has_auth_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandConnect::clear_has_auth_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandConnect::clear_auth_data() {
  if (auth_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_data_->clear();
  }
  clear_has_auth_data();
}
inline const ::std::string& CommandConnect::auth_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.auth_data)
  return *auth_data_;
}
inline void CommandConnect::set_auth_data(const ::std::string& value) {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.auth_data)
}
inline void CommandConnect::set_auth_data(const char* value) {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConnect.auth_data)
}
inline void CommandConnect::set_auth_data(const void* value, size_t size) {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConnect.auth_data)
}
inline ::std::string* CommandConnect::mutable_auth_data() {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.auth_data)
  return auth_data_;
}
inline ::std::string* CommandConnect::release_auth_data() {
  clear_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = auth_data_;
    auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConnect::set_allocated_auth_data(::std::string* auth_data) {
  if (auth_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete auth_data_;
  }
  if (auth_data) {
    set_has_auth_data();
    auth_data_ = auth_data;
  } else {
    clear_has_auth_data();
    auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.auth_data)
}

// optional int32 protocol_version = 4 [default = 0];
inline bool CommandConnect::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandConnect::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandConnect::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandConnect::clear_protocol_version() {
  protocol_version_ = 0;
  clear_has_protocol_version();
}
inline ::google::protobuf::int32 CommandConnect::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.protocol_version)
  return protocol_version_;
}
inline void CommandConnect::set_protocol_version(::google::protobuf::int32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.protocol_version)
}

// optional string proxy_to_broker_url = 6;
inline bool CommandConnect::has_proxy_to_broker_url() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandConnect::set_has_proxy_to_broker_url() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandConnect::clear_has_proxy_to_broker_url() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandConnect::clear_proxy_to_broker_url() {
  if (proxy_to_broker_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proxy_to_broker_url_->clear();
  }
  clear_has_proxy_to_broker_url();
}
inline const ::std::string& CommandConnect::proxy_to_broker_url() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.proxy_to_broker_url)
  return *proxy_to_broker_url_;
}
inline void CommandConnect::set_proxy_to_broker_url(const ::std::string& value) {
  set_has_proxy_to_broker_url();
  if (proxy_to_broker_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proxy_to_broker_url_ = new ::std::string;
  }
  proxy_to_broker_url_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.proxy_to_broker_url)
}
inline void CommandConnect::set_proxy_to_broker_url(const char* value) {
  set_has_proxy_to_broker_url();
  if (proxy_to_broker_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proxy_to_broker_url_ = new ::std::string;
  }
  proxy_to_broker_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConnect.proxy_to_broker_url)
}
inline void CommandConnect::set_proxy_to_broker_url(const char* value, size_t size) {
  set_has_proxy_to_broker_url();
  if (proxy_to_broker_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proxy_to_broker_url_ = new ::std::string;
  }
  proxy_to_broker_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConnect.proxy_to_broker_url)
}
inline ::std::string* CommandConnect::mutable_proxy_to_broker_url() {
  set_has_proxy_to_broker_url();
  if (proxy_to_broker_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proxy_to_broker_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.proxy_to_broker_url)
  return proxy_to_broker_url_;
}
inline ::std::string* CommandConnect::release_proxy_to_broker_url() {
  clear_has_proxy_to_broker_url();
  if (proxy_to_broker_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = proxy_to_broker_url_;
    proxy_to_broker_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConnect::set_allocated_proxy_to_broker_url(::std::string* proxy_to_broker_url) {
  if (proxy_to_broker_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete proxy_to_broker_url_;
  }
  if (proxy_to_broker_url) {
    set_has_proxy_to_broker_url();
    proxy_to_broker_url_ = proxy_to_broker_url;
  } else {
    clear_has_proxy_to_broker_url();
    proxy_to_broker_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.proxy_to_broker_url)
}

// optional string original_principal = 7;
inline bool CommandConnect::has_original_principal() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandConnect::set_has_original_principal() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandConnect::clear_has_original_principal() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandConnect::clear_original_principal() {
  if (original_principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_->clear();
  }
  clear_has_original_principal();
}
inline const ::std::string& CommandConnect::original_principal() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.original_principal)
  return *original_principal_;
}
inline void CommandConnect::set_original_principal(const ::std::string& value) {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  original_principal_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.original_principal)
}
inline void CommandConnect::set_original_principal(const char* value) {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  original_principal_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConnect.original_principal)
}
inline void CommandConnect::set_original_principal(const char* value, size_t size) {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  original_principal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConnect.original_principal)
}
inline ::std::string* CommandConnect::mutable_original_principal() {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.original_principal)
  return original_principal_;
}
inline ::std::string* CommandConnect::release_original_principal() {
  clear_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = original_principal_;
    original_principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConnect::set_allocated_original_principal(::std::string* original_principal) {
  if (original_principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete original_principal_;
  }
  if (original_principal) {
    set_has_original_principal();
    original_principal_ = original_principal;
  } else {
    clear_has_original_principal();
    original_principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.original_principal)
}

// optional string original_auth_data = 8;
inline bool CommandConnect::has_original_auth_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandConnect::set_has_original_auth_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandConnect::clear_has_original_auth_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandConnect::clear_original_auth_data() {
  if (original_auth_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_->clear();
  }
  clear_has_original_auth_data();
}
inline const ::std::string& CommandConnect::original_auth_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.original_auth_data)
  return *original_auth_data_;
}
inline void CommandConnect::set_original_auth_data(const ::std::string& value) {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  original_auth_data_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.original_auth_data)
}
inline void CommandConnect::set_original_auth_data(const char* value) {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  original_auth_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConnect.original_auth_data)
}
inline void CommandConnect::set_original_auth_data(const char* value, size_t size) {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  original_auth_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConnect.original_auth_data)
}
inline ::std::string* CommandConnect::mutable_original_auth_data() {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.original_auth_data)
  return original_auth_data_;
}
inline ::std::string* CommandConnect::release_original_auth_data() {
  clear_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = original_auth_data_;
    original_auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConnect::set_allocated_original_auth_data(::std::string* original_auth_data) {
  if (original_auth_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete original_auth_data_;
  }
  if (original_auth_data) {
    set_has_original_auth_data();
    original_auth_data_ = original_auth_data;
  } else {
    clear_has_original_auth_data();
    original_auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.original_auth_data)
}

// optional string original_auth_method = 9;
inline bool CommandConnect::has_original_auth_method() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommandConnect::set_has_original_auth_method() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommandConnect::clear_has_original_auth_method() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommandConnect::clear_original_auth_method() {
  if (original_auth_method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_->clear();
  }
  clear_has_original_auth_method();
}
inline const ::std::string& CommandConnect::original_auth_method() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.original_auth_method)
  return *original_auth_method_;
}
inline void CommandConnect::set_original_auth_method(const ::std::string& value) {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  original_auth_method_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.original_auth_method)
}
inline void CommandConnect::set_original_auth_method(const char* value) {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  original_auth_method_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConnect.original_auth_method)
}
inline void CommandConnect::set_original_auth_method(const char* value, size_t size) {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  original_auth_method_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConnect.original_auth_method)
}
inline ::std::string* CommandConnect::mutable_original_auth_method() {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.original_auth_method)
  return original_auth_method_;
}
inline ::std::string* CommandConnect::release_original_auth_method() {
  clear_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = original_auth_method_;
    original_auth_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConnect::set_allocated_original_auth_method(::std::string* original_auth_method) {
  if (original_auth_method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete original_auth_method_;
  }
  if (original_auth_method) {
    set_has_original_auth_method();
    original_auth_method_ = original_auth_method;
  } else {
    clear_has_original_auth_method();
    original_auth_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.original_auth_method)
}

// -------------------------------------------------------------------

// CommandConnected

// required string server_version = 1;
inline bool CommandConnected::has_server_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandConnected::set_has_server_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandConnected::clear_has_server_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandConnected::clear_server_version() {
  if (server_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_->clear();
  }
  clear_has_server_version();
}
inline const ::std::string& CommandConnected::server_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.server_version)
  return *server_version_;
}
inline void CommandConnected::set_server_version(const ::std::string& value) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnected.server_version)
}
inline void CommandConnected::set_server_version(const char* value) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConnected.server_version)
}
inline void CommandConnected::set_server_version(const char* value, size_t size) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConnected.server_version)
}
inline ::std::string* CommandConnected::mutable_server_version() {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnected.server_version)
  return server_version_;
}
inline ::std::string* CommandConnected::release_server_version() {
  clear_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_version_;
    server_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConnected::set_allocated_server_version(::std::string* server_version) {
  if (server_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_version_;
  }
  if (server_version) {
    set_has_server_version();
    server_version_ = server_version;
  } else {
    clear_has_server_version();
    server_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnected.server_version)
}

// optional int32 protocol_version = 2 [default = 0];
inline bool CommandConnected::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandConnected::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandConnected::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandConnected::clear_protocol_version() {
  protocol_version_ = 0;
  clear_has_protocol_version();
}
inline ::google::protobuf::int32 CommandConnected::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.protocol_version)
  return protocol_version_;
}
inline void CommandConnected::set_protocol_version(::google::protobuf::int32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnected.protocol_version)
}

// optional int32 max_message_size = 3;
inline bool CommandConnected::has_max_message_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandConnected::set_has_max_message_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandConnected::clear_has_max_message_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandConnected::clear_max_message_size() {
  max_message_size_ = 0;
  clear_has_max_message_size();
}
inline ::google::protobuf::int32 CommandConnected::max_message_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.max_message_size)
  return max_message_size_;
}
inline void CommandConnected::set_max_message_size(::google::protobuf::int32 value) {
  set_has_max_message_size();
  max_message_size_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnected.max_message_size)
}

// -------------------------------------------------------------------

// CommandAuthResponse

// optional string client_version = 1;
inline bool CommandAuthResponse::has_client_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandAuthResponse::set_has_client_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandAuthResponse::clear_has_client_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandAuthResponse::clear_client_version() {
  if (client_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_->clear();
  }
  clear_has_client_version();
}
inline const ::std::string& CommandAuthResponse::client_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthResponse.client_version)
  return *client_version_;
}
inline void CommandAuthResponse::set_client_version(const ::std::string& value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthResponse.client_version)
}
inline void CommandAuthResponse::set_client_version(const char* value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandAuthResponse.client_version)
}
inline void CommandAuthResponse::set_client_version(const char* value, size_t size) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandAuthResponse.client_version)
}
inline ::std::string* CommandAuthResponse::mutable_client_version() {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthResponse.client_version)
  return client_version_;
}
inline ::std::string* CommandAuthResponse::release_client_version() {
  clear_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_version_;
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandAuthResponse::set_allocated_client_version(::std::string* client_version) {
  if (client_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_version_;
  }
  if (client_version) {
    set_has_client_version();
    client_version_ = client_version;
  } else {
    clear_has_client_version();
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthResponse.client_version)
}

// optional .pulsar.proto.AuthData response = 2;
inline bool CommandAuthResponse::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandAuthResponse::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandAuthResponse::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandAuthResponse::clear_response() {
  if (response_ != NULL) response_->::pulsar::proto::AuthData::Clear();
  clear_has_response();
}
inline const ::pulsar::proto::AuthData& CommandAuthResponse::response() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthResponse.response)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return response_ != NULL ? *response_ : *default_instance().response_;
#else
  return response_ != NULL ? *response_ : *default_instance_->response_;
#endif
}
inline ::pulsar::proto::AuthData* CommandAuthResponse::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::pulsar::proto::AuthData;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthResponse.response)
  return response_;
}
inline ::pulsar::proto::AuthData* CommandAuthResponse::release_response() {
  clear_has_response();
  ::pulsar::proto::AuthData* temp = response_;
  response_ = NULL;
  return temp;
}
inline void CommandAuthResponse::set_allocated_response(::pulsar::proto::AuthData* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthResponse.response)
}

// optional int32 protocol_version = 3 [default = 0];
inline bool CommandAuthResponse::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandAuthResponse::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandAuthResponse::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandAuthResponse::clear_protocol_version() {
  protocol_version_ = 0;
  clear_has_protocol_version();
}
inline ::google::protobuf::int32 CommandAuthResponse::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthResponse.protocol_version)
  return protocol_version_;
}
inline void CommandAuthResponse::set_protocol_version(::google::protobuf::int32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthResponse.protocol_version)
}

// -------------------------------------------------------------------

// CommandAuthChallenge

// optional string server_version = 1;
inline bool CommandAuthChallenge::has_server_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandAuthChallenge::set_has_server_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandAuthChallenge::clear_has_server_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandAuthChallenge::clear_server_version() {
  if (server_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_->clear();
  }
  clear_has_server_version();
}
inline const ::std::string& CommandAuthChallenge::server_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthChallenge.server_version)
  return *server_version_;
}
inline void CommandAuthChallenge::set_server_version(const ::std::string& value) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthChallenge.server_version)
}
inline void CommandAuthChallenge::set_server_version(const char* value) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandAuthChallenge.server_version)
}
inline void CommandAuthChallenge::set_server_version(const char* value, size_t size) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandAuthChallenge.server_version)
}
inline ::std::string* CommandAuthChallenge::mutable_server_version() {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthChallenge.server_version)
  return server_version_;
}
inline ::std::string* CommandAuthChallenge::release_server_version() {
  clear_has_server_version();
  if (server_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_version_;
    server_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandAuthChallenge::set_allocated_server_version(::std::string* server_version) {
  if (server_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_version_;
  }
  if (server_version) {
    set_has_server_version();
    server_version_ = server_version;
  } else {
    clear_has_server_version();
    server_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthChallenge.server_version)
}

// optional .pulsar.proto.AuthData challenge = 2;
inline bool CommandAuthChallenge::has_challenge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandAuthChallenge::set_has_challenge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandAuthChallenge::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandAuthChallenge::clear_challenge() {
  if (challenge_ != NULL) challenge_->::pulsar::proto::AuthData::Clear();
  clear_has_challenge();
}
inline const ::pulsar::proto::AuthData& CommandAuthChallenge::challenge() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthChallenge.challenge)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return challenge_ != NULL ? *challenge_ : *default_instance().challenge_;
#else
  return challenge_ != NULL ? *challenge_ : *default_instance_->challenge_;
#endif
}
inline ::pulsar::proto::AuthData* CommandAuthChallenge::mutable_challenge() {
  set_has_challenge();
  if (challenge_ == NULL) challenge_ = new ::pulsar::proto::AuthData;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthChallenge.challenge)
  return challenge_;
}
inline ::pulsar::proto::AuthData* CommandAuthChallenge::release_challenge() {
  clear_has_challenge();
  ::pulsar::proto::AuthData* temp = challenge_;
  challenge_ = NULL;
  return temp;
}
inline void CommandAuthChallenge::set_allocated_challenge(::pulsar::proto::AuthData* challenge) {
  delete challenge_;
  challenge_ = challenge;
  if (challenge) {
    set_has_challenge();
  } else {
    clear_has_challenge();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthChallenge.challenge)
}

// optional int32 protocol_version = 3 [default = 0];
inline bool CommandAuthChallenge::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandAuthChallenge::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandAuthChallenge::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandAuthChallenge::clear_protocol_version() {
  protocol_version_ = 0;
  clear_has_protocol_version();
}
inline ::google::protobuf::int32 CommandAuthChallenge::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthChallenge.protocol_version)
  return protocol_version_;
}
inline void CommandAuthChallenge::set_protocol_version(::google::protobuf::int32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthChallenge.protocol_version)
}

// -------------------------------------------------------------------

// AuthData

// optional string auth_method_name = 1;
inline bool AuthData::has_auth_method_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthData::set_has_auth_method_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthData::clear_has_auth_method_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthData::clear_auth_method_name() {
  if (auth_method_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_method_name_->clear();
  }
  clear_has_auth_method_name();
}
inline const ::std::string& AuthData::auth_method_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.AuthData.auth_method_name)
  return *auth_method_name_;
}
inline void AuthData::set_auth_method_name(const ::std::string& value) {
  set_has_auth_method_name();
  if (auth_method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_method_name_ = new ::std::string;
  }
  auth_method_name_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.AuthData.auth_method_name)
}
inline void AuthData::set_auth_method_name(const char* value) {
  set_has_auth_method_name();
  if (auth_method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_method_name_ = new ::std::string;
  }
  auth_method_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.AuthData.auth_method_name)
}
inline void AuthData::set_auth_method_name(const char* value, size_t size) {
  set_has_auth_method_name();
  if (auth_method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_method_name_ = new ::std::string;
  }
  auth_method_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.AuthData.auth_method_name)
}
inline ::std::string* AuthData::mutable_auth_method_name() {
  set_has_auth_method_name();
  if (auth_method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_method_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.AuthData.auth_method_name)
  return auth_method_name_;
}
inline ::std::string* AuthData::release_auth_method_name() {
  clear_has_auth_method_name();
  if (auth_method_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = auth_method_name_;
    auth_method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthData::set_allocated_auth_method_name(::std::string* auth_method_name) {
  if (auth_method_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete auth_method_name_;
  }
  if (auth_method_name) {
    set_has_auth_method_name();
    auth_method_name_ = auth_method_name;
  } else {
    clear_has_auth_method_name();
    auth_method_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.AuthData.auth_method_name)
}

// optional bytes auth_data = 2;
inline bool AuthData::has_auth_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthData::set_has_auth_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthData::clear_has_auth_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthData::clear_auth_data() {
  if (auth_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_data_->clear();
  }
  clear_has_auth_data();
}
inline const ::std::string& AuthData::auth_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.AuthData.auth_data)
  return *auth_data_;
}
inline void AuthData::set_auth_data(const ::std::string& value) {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.AuthData.auth_data)
}
inline void AuthData::set_auth_data(const char* value) {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.AuthData.auth_data)
}
inline void AuthData::set_auth_data(const void* value, size_t size) {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.AuthData.auth_data)
}
inline ::std::string* AuthData::mutable_auth_data() {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.AuthData.auth_data)
  return auth_data_;
}
inline ::std::string* AuthData::release_auth_data() {
  clear_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = auth_data_;
    auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthData::set_allocated_auth_data(::std::string* auth_data) {
  if (auth_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete auth_data_;
  }
  if (auth_data) {
    set_has_auth_data();
    auth_data_ = auth_data;
  } else {
    clear_has_auth_data();
    auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.AuthData.auth_data)
}

// -------------------------------------------------------------------

// CommandSubscribe

// required string topic = 1;
inline bool CommandSubscribe::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSubscribe::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSubscribe::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSubscribe::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& CommandSubscribe::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.topic)
  return *topic_;
}
inline void CommandSubscribe::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.topic)
}
inline void CommandSubscribe::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandSubscribe.topic)
}
inline void CommandSubscribe::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandSubscribe.topic)
}
inline ::std::string* CommandSubscribe::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.topic)
  return topic_;
}
inline ::std::string* CommandSubscribe::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandSubscribe::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.topic)
}

// required string subscription = 2;
inline bool CommandSubscribe::has_subscription() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSubscribe::set_has_subscription() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSubscribe::clear_has_subscription() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSubscribe::clear_subscription() {
  if (subscription_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subscription_->clear();
  }
  clear_has_subscription();
}
inline const ::std::string& CommandSubscribe::subscription() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.subscription)
  return *subscription_;
}
inline void CommandSubscribe::set_subscription(const ::std::string& value) {
  set_has_subscription();
  if (subscription_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subscription_ = new ::std::string;
  }
  subscription_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.subscription)
}
inline void CommandSubscribe::set_subscription(const char* value) {
  set_has_subscription();
  if (subscription_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subscription_ = new ::std::string;
  }
  subscription_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandSubscribe.subscription)
}
inline void CommandSubscribe::set_subscription(const char* value, size_t size) {
  set_has_subscription();
  if (subscription_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subscription_ = new ::std::string;
  }
  subscription_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandSubscribe.subscription)
}
inline ::std::string* CommandSubscribe::mutable_subscription() {
  set_has_subscription();
  if (subscription_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subscription_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.subscription)
  return subscription_;
}
inline ::std::string* CommandSubscribe::release_subscription() {
  clear_has_subscription();
  if (subscription_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subscription_;
    subscription_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandSubscribe::set_allocated_subscription(::std::string* subscription) {
  if (subscription_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subscription_;
  }
  if (subscription) {
    set_has_subscription();
    subscription_ = subscription;
  } else {
    clear_has_subscription();
    subscription_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.subscription)
}

// required .pulsar.proto.CommandSubscribe.SubType subType = 3;
inline bool CommandSubscribe::has_subtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSubscribe::set_has_subtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSubscribe::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSubscribe::clear_subtype() {
  subtype_ = 0;
  clear_has_subtype();
}
inline ::pulsar::proto::CommandSubscribe_SubType CommandSubscribe::subtype() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.subType)
  return static_cast< ::pulsar::proto::CommandSubscribe_SubType >(subtype_);
}
inline void CommandSubscribe::set_subtype(::pulsar::proto::CommandSubscribe_SubType value) {
  assert(::pulsar::proto::CommandSubscribe_SubType_IsValid(value));
  set_has_subtype();
  subtype_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.subType)
}

// required uint64 consumer_id = 4;
inline bool CommandSubscribe::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSubscribe::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSubscribe::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSubscribe::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandSubscribe::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.consumer_id)
  return consumer_id_;
}
inline void CommandSubscribe::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.consumer_id)
}

// required uint64 request_id = 5;
inline bool CommandSubscribe::has_request_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSubscribe::set_has_request_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSubscribe::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSubscribe::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandSubscribe::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.request_id)
  return request_id_;
}
inline void CommandSubscribe::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.request_id)
}

// optional string consumer_name = 6;
inline bool CommandSubscribe::has_consumer_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSubscribe::set_has_consumer_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSubscribe::clear_has_consumer_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSubscribe::clear_consumer_name() {
  if (consumer_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    consumer_name_->clear();
  }
  clear_has_consumer_name();
}
inline const ::std::string& CommandSubscribe::consumer_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.consumer_name)
  return *consumer_name_;
}
inline void CommandSubscribe::set_consumer_name(const ::std::string& value) {
  set_has_consumer_name();
  if (consumer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    consumer_name_ = new ::std::string;
  }
  consumer_name_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.consumer_name)
}
inline void CommandSubscribe::set_consumer_name(const char* value) {
  set_has_consumer_name();
  if (consumer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    consumer_name_ = new ::std::string;
  }
  consumer_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandSubscribe.consumer_name)
}
inline void CommandSubscribe::set_consumer_name(const char* value, size_t size) {
  set_has_consumer_name();
  if (consumer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    consumer_name_ = new ::std::string;
  }
  consumer_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandSubscribe.consumer_name)
}
inline ::std::string* CommandSubscribe::mutable_consumer_name() {
  set_has_consumer_name();
  if (consumer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    consumer_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.consumer_name)
  return consumer_name_;
}
inline ::std::string* CommandSubscribe::release_consumer_name() {
  clear_has_consumer_name();
  if (consumer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = consumer_name_;
    consumer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandSubscribe::set_allocated_consumer_name(::std::string* consumer_name) {
  if (consumer_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete consumer_name_;
  }
  if (consumer_name) {
    set_has_consumer_name();
    consumer_name_ = consumer_name;
  } else {
    clear_has_consumer_name();
    consumer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.consumer_name)
}

// optional int32 priority_level = 7;
inline bool CommandSubscribe::has_priority_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandSubscribe::set_has_priority_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandSubscribe::clear_has_priority_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandSubscribe::clear_priority_level() {
  priority_level_ = 0;
  clear_has_priority_level();
}
inline ::google::protobuf::int32 CommandSubscribe::priority_level() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.priority_level)
  return priority_level_;
}
inline void CommandSubscribe::set_priority_level(::google::protobuf::int32 value) {
  set_has_priority_level();
  priority_level_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.priority_level)
}

// optional bool durable = 8 [default = true];
inline bool CommandSubscribe::has_durable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandSubscribe::set_has_durable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandSubscribe::clear_has_durable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandSubscribe::clear_durable() {
  durable_ = true;
  clear_has_durable();
}
inline bool CommandSubscribe::durable() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.durable)
  return durable_;
}
inline void CommandSubscribe::set_durable(bool value) {
  set_has_durable();
  durable_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.durable)
}

// optional .pulsar.proto.MessageIdData start_message_id = 9;
inline bool CommandSubscribe::has_start_message_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommandSubscribe::set_has_start_message_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommandSubscribe::clear_has_start_message_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommandSubscribe::clear_start_message_id() {
  if (start_message_id_ != NULL) start_message_id_->::pulsar::proto::MessageIdData::Clear();
  clear_has_start_message_id();
}
inline const ::pulsar::proto::MessageIdData& CommandSubscribe::start_message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.start_message_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return start_message_id_ != NULL ? *start_message_id_ : *default_instance().start_message_id_;
#else
  return start_message_id_ != NULL ? *start_message_id_ : *default_instance_->start_message_id_;
#endif
}
inline ::pulsar::proto::MessageIdData* CommandSubscribe::mutable_start_message_id() {
  set_has_start_message_id();
  if (start_message_id_ == NULL) start_message_id_ = new ::pulsar::proto::MessageIdData;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.start_message_id)
  return start_message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSubscribe::release_start_message_id() {
  clear_has_start_message_id();
  ::pulsar::proto::MessageIdData* temp = start_message_id_;
  start_message_id_ = NULL;
  return temp;
}
inline void CommandSubscribe::set_allocated_start_message_id(::pulsar::proto::MessageIdData* start_message_id) {
  delete start_message_id_;
  start_message_id_ = start_message_id;
  if (start_message_id) {
    set_has_start_message_id();
  } else {
    clear_has_start_message_id();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.start_message_id)
}

// repeated .pulsar.proto.KeyValue metadata = 10;
inline int CommandSubscribe::metadata_size() const {
  return metadata_.size();
}
inline void CommandSubscribe::clear_metadata() {
  metadata_.Clear();
}
inline const ::pulsar::proto::KeyValue& CommandSubscribe::metadata(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.metadata)
  return metadata_.Get(index);
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.metadata)
  return metadata_.Mutable(index);
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::add_metadata() {
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandSubscribe.metadata)
  return metadata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
CommandSubscribe::metadata() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandSubscribe.metadata)
  return metadata_;
}
inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
CommandSubscribe::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandSubscribe.metadata)
  return &metadata_;
}

// optional bool read_compacted = 11;
inline bool CommandSubscribe::has_read_compacted() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommandSubscribe::set_has_read_compacted() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommandSubscribe::clear_has_read_compacted() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommandSubscribe::clear_read_compacted() {
  read_compacted_ = false;
  clear_has_read_compacted();
}
inline bool CommandSubscribe::read_compacted() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.read_compacted)
  return read_compacted_;
}
inline void CommandSubscribe::set_read_compacted(bool value) {
  set_has_read_compacted();
  read_compacted_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.read_compacted)
}

// optional .pulsar.proto.Schema schema = 12;
inline bool CommandSubscribe::has_schema() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommandSubscribe::set_has_schema() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommandSubscribe::clear_has_schema() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommandSubscribe::clear_schema() {
  if (schema_ != NULL) schema_->::pulsar::proto::Schema::Clear();
  clear_has_schema();
}
inline const ::pulsar::proto::Schema& CommandSubscribe::schema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.schema)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return schema_ != NULL ? *schema_ : *default_instance().schema_;
#else
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
#endif
}
inline ::pulsar::proto::Schema* CommandSubscribe::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::pulsar::proto::Schema;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.schema)
  return schema_;
}
inline ::pulsar::proto::Schema* CommandSubscribe::release_schema() {
  clear_has_schema();
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void CommandSubscribe::set_allocated_schema(::pulsar::proto::Schema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.schema)
}

// optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
inline bool CommandSubscribe::has_initialposition() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommandSubscribe::set_has_initialposition() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommandSubscribe::clear_has_initialposition() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommandSubscribe::clear_initialposition() {
  initialposition_ = 0;
  clear_has_initialposition();
}
inline ::pulsar::proto::CommandSubscribe_InitialPosition CommandSubscribe::initialposition() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.initialPosition)
  return static_cast< ::pulsar::proto::CommandSubscribe_InitialPosition >(initialposition_);
}
inline void CommandSubscribe::set_initialposition(::pulsar::proto::CommandSubscribe_InitialPosition value) {
  assert(::pulsar::proto::CommandSubscribe_InitialPosition_IsValid(value));
  set_has_initialposition();
  initialposition_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.initialPosition)
}

// optional bool replicate_subscription_state = 14;
inline bool CommandSubscribe::has_replicate_subscription_state() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CommandSubscribe::set_has_replicate_subscription_state() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CommandSubscribe::clear_has_replicate_subscription_state() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CommandSubscribe::clear_replicate_subscription_state() {
  replicate_subscription_state_ = false;
  clear_has_replicate_subscription_state();
}
inline bool CommandSubscribe::replicate_subscription_state() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.replicate_subscription_state)
  return replicate_subscription_state_;
}
inline void CommandSubscribe::set_replicate_subscription_state(bool value) {
  set_has_replicate_subscription_state();
  replicate_subscription_state_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.replicate_subscription_state)
}

// -------------------------------------------------------------------

// CommandPartitionedTopicMetadata

// required string topic = 1;
inline bool CommandPartitionedTopicMetadata::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPartitionedTopicMetadata::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPartitionedTopicMetadata::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPartitionedTopicMetadata::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& CommandPartitionedTopicMetadata::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.topic)
  return *topic_;
}
inline void CommandPartitionedTopicMetadata::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.topic)
}
inline void CommandPartitionedTopicMetadata::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandPartitionedTopicMetadata.topic)
}
inline void CommandPartitionedTopicMetadata::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandPartitionedTopicMetadata.topic)
}
inline ::std::string* CommandPartitionedTopicMetadata::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.topic)
  return topic_;
}
inline ::std::string* CommandPartitionedTopicMetadata::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandPartitionedTopicMetadata::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.topic)
}

// required uint64 request_id = 2;
inline bool CommandPartitionedTopicMetadata::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPartitionedTopicMetadata::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPartitionedTopicMetadata::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPartitionedTopicMetadata::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandPartitionedTopicMetadata::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.request_id)
  return request_id_;
}
inline void CommandPartitionedTopicMetadata::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.request_id)
}

// optional string original_principal = 3;
inline bool CommandPartitionedTopicMetadata::has_original_principal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandPartitionedTopicMetadata::set_has_original_principal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandPartitionedTopicMetadata::clear_has_original_principal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandPartitionedTopicMetadata::clear_original_principal() {
  if (original_principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_->clear();
  }
  clear_has_original_principal();
}
inline const ::std::string& CommandPartitionedTopicMetadata::original_principal() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
  return *original_principal_;
}
inline void CommandPartitionedTopicMetadata::set_original_principal(const ::std::string& value) {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  original_principal_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
}
inline void CommandPartitionedTopicMetadata::set_original_principal(const char* value) {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  original_principal_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
}
inline void CommandPartitionedTopicMetadata::set_original_principal(const char* value, size_t size) {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  original_principal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
}
inline ::std::string* CommandPartitionedTopicMetadata::mutable_original_principal() {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
  return original_principal_;
}
inline ::std::string* CommandPartitionedTopicMetadata::release_original_principal() {
  clear_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = original_principal_;
    original_principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandPartitionedTopicMetadata::set_allocated_original_principal(::std::string* original_principal) {
  if (original_principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete original_principal_;
  }
  if (original_principal) {
    set_has_original_principal();
    original_principal_ = original_principal;
  } else {
    clear_has_original_principal();
    original_principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
}

// optional string original_auth_data = 4;
inline bool CommandPartitionedTopicMetadata::has_original_auth_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandPartitionedTopicMetadata::set_has_original_auth_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandPartitionedTopicMetadata::clear_has_original_auth_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandPartitionedTopicMetadata::clear_original_auth_data() {
  if (original_auth_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_->clear();
  }
  clear_has_original_auth_data();
}
inline const ::std::string& CommandPartitionedTopicMetadata::original_auth_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
  return *original_auth_data_;
}
inline void CommandPartitionedTopicMetadata::set_original_auth_data(const ::std::string& value) {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  original_auth_data_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
}
inline void CommandPartitionedTopicMetadata::set_original_auth_data(const char* value) {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  original_auth_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
}
inline void CommandPartitionedTopicMetadata::set_original_auth_data(const char* value, size_t size) {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  original_auth_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
}
inline ::std::string* CommandPartitionedTopicMetadata::mutable_original_auth_data() {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
  return original_auth_data_;
}
inline ::std::string* CommandPartitionedTopicMetadata::release_original_auth_data() {
  clear_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = original_auth_data_;
    original_auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandPartitionedTopicMetadata::set_allocated_original_auth_data(::std::string* original_auth_data) {
  if (original_auth_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete original_auth_data_;
  }
  if (original_auth_data) {
    set_has_original_auth_data();
    original_auth_data_ = original_auth_data;
  } else {
    clear_has_original_auth_data();
    original_auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
}

// optional string original_auth_method = 5;
inline bool CommandPartitionedTopicMetadata::has_original_auth_method() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandPartitionedTopicMetadata::set_has_original_auth_method() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandPartitionedTopicMetadata::clear_has_original_auth_method() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandPartitionedTopicMetadata::clear_original_auth_method() {
  if (original_auth_method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_->clear();
  }
  clear_has_original_auth_method();
}
inline const ::std::string& CommandPartitionedTopicMetadata::original_auth_method() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
  return *original_auth_method_;
}
inline void CommandPartitionedTopicMetadata::set_original_auth_method(const ::std::string& value) {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  original_auth_method_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
}
inline void CommandPartitionedTopicMetadata::set_original_auth_method(const char* value) {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  original_auth_method_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
}
inline void CommandPartitionedTopicMetadata::set_original_auth_method(const char* value, size_t size) {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  original_auth_method_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
}
inline ::std::string* CommandPartitionedTopicMetadata::mutable_original_auth_method() {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
  return original_auth_method_;
}
inline ::std::string* CommandPartitionedTopicMetadata::release_original_auth_method() {
  clear_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = original_auth_method_;
    original_auth_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandPartitionedTopicMetadata::set_allocated_original_auth_method(::std::string* original_auth_method) {
  if (original_auth_method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete original_auth_method_;
  }
  if (original_auth_method) {
    set_has_original_auth_method();
    original_auth_method_ = original_auth_method;
  } else {
    clear_has_original_auth_method();
    original_auth_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
}

// -------------------------------------------------------------------

// CommandPartitionedTopicMetadataResponse

// optional uint32 partitions = 1;
inline bool CommandPartitionedTopicMetadataResponse::has_partitions() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPartitionedTopicMetadataResponse::set_has_partitions() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPartitionedTopicMetadataResponse::clear_has_partitions() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPartitionedTopicMetadataResponse::clear_partitions() {
  partitions_ = 0u;
  clear_has_partitions();
}
inline ::google::protobuf::uint32 CommandPartitionedTopicMetadataResponse::partitions() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.partitions)
  return partitions_;
}
inline void CommandPartitionedTopicMetadataResponse::set_partitions(::google::protobuf::uint32 value) {
  set_has_partitions();
  partitions_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.partitions)
}

// required uint64 request_id = 2;
inline bool CommandPartitionedTopicMetadataResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPartitionedTopicMetadataResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPartitionedTopicMetadataResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPartitionedTopicMetadataResponse::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandPartitionedTopicMetadataResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.request_id)
  return request_id_;
}
inline void CommandPartitionedTopicMetadataResponse::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.request_id)
}

// optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
inline bool CommandPartitionedTopicMetadataResponse::has_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandPartitionedTopicMetadataResponse::set_has_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandPartitionedTopicMetadataResponse::clear_has_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandPartitionedTopicMetadataResponse::clear_response() {
  response_ = 0;
  clear_has_response();
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::response() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.response)
  return static_cast< ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType >(response_);
}
inline void CommandPartitionedTopicMetadataResponse::set_response(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType value) {
  assert(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType_IsValid(value));
  set_has_response();
  response_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.response)
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandPartitionedTopicMetadataResponse::has_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandPartitionedTopicMetadataResponse::set_has_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandPartitionedTopicMetadataResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandPartitionedTopicMetadataResponse::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::pulsar::proto::ServerError CommandPartitionedTopicMetadataResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.error)
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline void CommandPartitionedTopicMetadataResponse::set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.error)
}

// optional string message = 5;
inline bool CommandPartitionedTopicMetadataResponse::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandPartitionedTopicMetadataResponse::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandPartitionedTopicMetadataResponse::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandPartitionedTopicMetadataResponse::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CommandPartitionedTopicMetadataResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
  return *message_;
}
inline void CommandPartitionedTopicMetadataResponse::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
}
inline void CommandPartitionedTopicMetadataResponse::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
}
inline void CommandPartitionedTopicMetadataResponse::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
}
inline ::std::string* CommandPartitionedTopicMetadataResponse::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
  return message_;
}
inline ::std::string* CommandPartitionedTopicMetadataResponse::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandPartitionedTopicMetadataResponse::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
}

// -------------------------------------------------------------------

// CommandLookupTopic

// required string topic = 1;
inline bool CommandLookupTopic::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandLookupTopic::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandLookupTopic::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandLookupTopic::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& CommandLookupTopic::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.topic)
  return *topic_;
}
inline void CommandLookupTopic::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.topic)
}
inline void CommandLookupTopic::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandLookupTopic.topic)
}
inline void CommandLookupTopic::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandLookupTopic.topic)
}
inline ::std::string* CommandLookupTopic::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.topic)
  return topic_;
}
inline ::std::string* CommandLookupTopic::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandLookupTopic::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.topic)
}

// required uint64 request_id = 2;
inline bool CommandLookupTopic::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandLookupTopic::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandLookupTopic::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandLookupTopic::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandLookupTopic::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.request_id)
  return request_id_;
}
inline void CommandLookupTopic::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.request_id)
}

// optional bool authoritative = 3 [default = false];
inline bool CommandLookupTopic::has_authoritative() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandLookupTopic::set_has_authoritative() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandLookupTopic::clear_has_authoritative() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandLookupTopic::clear_authoritative() {
  authoritative_ = false;
  clear_has_authoritative();
}
inline bool CommandLookupTopic::authoritative() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.authoritative)
  return authoritative_;
}
inline void CommandLookupTopic::set_authoritative(bool value) {
  set_has_authoritative();
  authoritative_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.authoritative)
}

// optional string original_principal = 4;
inline bool CommandLookupTopic::has_original_principal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandLookupTopic::set_has_original_principal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandLookupTopic::clear_has_original_principal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandLookupTopic::clear_original_principal() {
  if (original_principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_->clear();
  }
  clear_has_original_principal();
}
inline const ::std::string& CommandLookupTopic::original_principal() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.original_principal)
  return *original_principal_;
}
inline void CommandLookupTopic::set_original_principal(const ::std::string& value) {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  original_principal_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.original_principal)
}
inline void CommandLookupTopic::set_original_principal(const char* value) {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  original_principal_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandLookupTopic.original_principal)
}
inline void CommandLookupTopic::set_original_principal(const char* value, size_t size) {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  original_principal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandLookupTopic.original_principal)
}
inline ::std::string* CommandLookupTopic::mutable_original_principal() {
  set_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_principal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.original_principal)
  return original_principal_;
}
inline ::std::string* CommandLookupTopic::release_original_principal() {
  clear_has_original_principal();
  if (original_principal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = original_principal_;
    original_principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandLookupTopic::set_allocated_original_principal(::std::string* original_principal) {
  if (original_principal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete original_principal_;
  }
  if (original_principal) {
    set_has_original_principal();
    original_principal_ = original_principal;
  } else {
    clear_has_original_principal();
    original_principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.original_principal)
}

// optional string original_auth_data = 5;
inline bool CommandLookupTopic::has_original_auth_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandLookupTopic::set_has_original_auth_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandLookupTopic::clear_has_original_auth_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandLookupTopic::clear_original_auth_data() {
  if (original_auth_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_->clear();
  }
  clear_has_original_auth_data();
}
inline const ::std::string& CommandLookupTopic::original_auth_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.original_auth_data)
  return *original_auth_data_;
}
inline void CommandLookupTopic::set_original_auth_data(const ::std::string& value) {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  original_auth_data_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.original_auth_data)
}
inline void CommandLookupTopic::set_original_auth_data(const char* value) {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  original_auth_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandLookupTopic.original_auth_data)
}
inline void CommandLookupTopic::set_original_auth_data(const char* value, size_t size) {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  original_auth_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandLookupTopic.original_auth_data)
}
inline ::std::string* CommandLookupTopic::mutable_original_auth_data() {
  set_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.original_auth_data)
  return original_auth_data_;
}
inline ::std::string* CommandLookupTopic::release_original_auth_data() {
  clear_has_original_auth_data();
  if (original_auth_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = original_auth_data_;
    original_auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandLookupTopic::set_allocated_original_auth_data(::std::string* original_auth_data) {
  if (original_auth_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete original_auth_data_;
  }
  if (original_auth_data) {
    set_has_original_auth_data();
    original_auth_data_ = original_auth_data;
  } else {
    clear_has_original_auth_data();
    original_auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.original_auth_data)
}

// optional string original_auth_method = 6;
inline bool CommandLookupTopic::has_original_auth_method() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandLookupTopic::set_has_original_auth_method() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandLookupTopic::clear_has_original_auth_method() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandLookupTopic::clear_original_auth_method() {
  if (original_auth_method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_->clear();
  }
  clear_has_original_auth_method();
}
inline const ::std::string& CommandLookupTopic::original_auth_method() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.original_auth_method)
  return *original_auth_method_;
}
inline void CommandLookupTopic::set_original_auth_method(const ::std::string& value) {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  original_auth_method_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.original_auth_method)
}
inline void CommandLookupTopic::set_original_auth_method(const char* value) {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  original_auth_method_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandLookupTopic.original_auth_method)
}
inline void CommandLookupTopic::set_original_auth_method(const char* value, size_t size) {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  original_auth_method_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandLookupTopic.original_auth_method)
}
inline ::std::string* CommandLookupTopic::mutable_original_auth_method() {
  set_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    original_auth_method_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.original_auth_method)
  return original_auth_method_;
}
inline ::std::string* CommandLookupTopic::release_original_auth_method() {
  clear_has_original_auth_method();
  if (original_auth_method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = original_auth_method_;
    original_auth_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandLookupTopic::set_allocated_original_auth_method(::std::string* original_auth_method) {
  if (original_auth_method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete original_auth_method_;
  }
  if (original_auth_method) {
    set_has_original_auth_method();
    original_auth_method_ = original_auth_method;
  } else {
    clear_has_original_auth_method();
    original_auth_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.original_auth_method)
}

// -------------------------------------------------------------------

// CommandLookupTopicResponse

// optional string brokerServiceUrl = 1;
inline bool CommandLookupTopicResponse::has_brokerserviceurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandLookupTopicResponse::set_has_brokerserviceurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandLookupTopicResponse::clear_has_brokerserviceurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandLookupTopicResponse::clear_brokerserviceurl() {
  if (brokerserviceurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brokerserviceurl_->clear();
  }
  clear_has_brokerserviceurl();
}
inline const ::std::string& CommandLookupTopicResponse::brokerserviceurl() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
  return *brokerserviceurl_;
}
inline void CommandLookupTopicResponse::set_brokerserviceurl(const ::std::string& value) {
  set_has_brokerserviceurl();
  if (brokerserviceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brokerserviceurl_ = new ::std::string;
  }
  brokerserviceurl_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
}
inline void CommandLookupTopicResponse::set_brokerserviceurl(const char* value) {
  set_has_brokerserviceurl();
  if (brokerserviceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brokerserviceurl_ = new ::std::string;
  }
  brokerserviceurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
}
inline void CommandLookupTopicResponse::set_brokerserviceurl(const char* value, size_t size) {
  set_has_brokerserviceurl();
  if (brokerserviceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brokerserviceurl_ = new ::std::string;
  }
  brokerserviceurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
}
inline ::std::string* CommandLookupTopicResponse::mutable_brokerserviceurl() {
  set_has_brokerserviceurl();
  if (brokerserviceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brokerserviceurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
  return brokerserviceurl_;
}
inline ::std::string* CommandLookupTopicResponse::release_brokerserviceurl() {
  clear_has_brokerserviceurl();
  if (brokerserviceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = brokerserviceurl_;
    brokerserviceurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandLookupTopicResponse::set_allocated_brokerserviceurl(::std::string* brokerserviceurl) {
  if (brokerserviceurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete brokerserviceurl_;
  }
  if (brokerserviceurl) {
    set_has_brokerserviceurl();
    brokerserviceurl_ = brokerserviceurl;
  } else {
    clear_has_brokerserviceurl();
    brokerserviceurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
}

// optional string brokerServiceUrlTls = 2;
inline bool CommandLookupTopicResponse::has_brokerserviceurltls() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandLookupTopicResponse::set_has_brokerserviceurltls() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandLookupTopicResponse::clear_has_brokerserviceurltls() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandLookupTopicResponse::clear_brokerserviceurltls() {
  if (brokerserviceurltls_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brokerserviceurltls_->clear();
  }
  clear_has_brokerserviceurltls();
}
inline const ::std::string& CommandLookupTopicResponse::brokerserviceurltls() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
  return *brokerserviceurltls_;
}
inline void CommandLookupTopicResponse::set_brokerserviceurltls(const ::std::string& value) {
  set_has_brokerserviceurltls();
  if (brokerserviceurltls_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brokerserviceurltls_ = new ::std::string;
  }
  brokerserviceurltls_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
}
inline void CommandLookupTopicResponse::set_brokerserviceurltls(const char* value) {
  set_has_brokerserviceurltls();
  if (brokerserviceurltls_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brokerserviceurltls_ = new ::std::string;
  }
  brokerserviceurltls_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
}
inline void CommandLookupTopicResponse::set_brokerserviceurltls(const char* value, size_t size) {
  set_has_brokerserviceurltls();
  if (brokerserviceurltls_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brokerserviceurltls_ = new ::std::string;
  }
  brokerserviceurltls_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
}
inline ::std::string* CommandLookupTopicResponse::mutable_brokerserviceurltls() {
  set_has_brokerserviceurltls();
  if (brokerserviceurltls_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brokerserviceurltls_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
  return brokerserviceurltls_;
}
inline ::std::string* CommandLookupTopicResponse::release_brokerserviceurltls() {
  clear_has_brokerserviceurltls();
  if (brokerserviceurltls_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = brokerserviceurltls_;
    brokerserviceurltls_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandLookupTopicResponse::set_allocated_brokerserviceurltls(::std::string* brokerserviceurltls) {
  if (brokerserviceurltls_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete brokerserviceurltls_;
  }
  if (brokerserviceurltls) {
    set_has_brokerserviceurltls();
    brokerserviceurltls_ = brokerserviceurltls;
  } else {
    clear_has_brokerserviceurltls();
    brokerserviceurltls_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
}

// optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
inline bool CommandLookupTopicResponse::has_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandLookupTopicResponse::set_has_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandLookupTopicResponse::clear_has_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandLookupTopicResponse::clear_response() {
  response_ = 0;
  clear_has_response();
}
inline ::pulsar::proto::CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::response() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.response)
  return static_cast< ::pulsar::proto::CommandLookupTopicResponse_LookupType >(response_);
}
inline void CommandLookupTopicResponse::set_response(::pulsar::proto::CommandLookupTopicResponse_LookupType value) {
  assert(::pulsar::proto::CommandLookupTopicResponse_LookupType_IsValid(value));
  set_has_response();
  response_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.response)
}

// required uint64 request_id = 4;
inline bool CommandLookupTopicResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandLookupTopicResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandLookupTopicResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandLookupTopicResponse::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandLookupTopicResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.request_id)
  return request_id_;
}
inline void CommandLookupTopicResponse::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.request_id)
}

// optional bool authoritative = 5 [default = false];
inline bool CommandLookupTopicResponse::has_authoritative() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandLookupTopicResponse::set_has_authoritative() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandLookupTopicResponse::clear_has_authoritative() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandLookupTopicResponse::clear_authoritative() {
  authoritative_ = false;
  clear_has_authoritative();
}
inline bool CommandLookupTopicResponse::authoritative() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.authoritative)
  return authoritative_;
}
inline void CommandLookupTopicResponse::set_authoritative(bool value) {
  set_has_authoritative();
  authoritative_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.authoritative)
}

// optional .pulsar.proto.ServerError error = 6;
inline bool CommandLookupTopicResponse::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandLookupTopicResponse::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandLookupTopicResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandLookupTopicResponse::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::pulsar::proto::ServerError CommandLookupTopicResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.error)
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline void CommandLookupTopicResponse::set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.error)
}

// optional string message = 7;
inline bool CommandLookupTopicResponse::has_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandLookupTopicResponse::set_has_message() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandLookupTopicResponse::clear_has_message() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandLookupTopicResponse::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CommandLookupTopicResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.message)
  return *message_;
}
inline void CommandLookupTopicResponse::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.message)
}
inline void CommandLookupTopicResponse::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandLookupTopicResponse.message)
}
inline void CommandLookupTopicResponse::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandLookupTopicResponse.message)
}
inline ::std::string* CommandLookupTopicResponse::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopicResponse.message)
  return message_;
}
inline ::std::string* CommandLookupTopicResponse::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandLookupTopicResponse::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopicResponse.message)
}

// optional bool proxy_through_service_url = 8 [default = false];
inline bool CommandLookupTopicResponse::has_proxy_through_service_url() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandLookupTopicResponse::set_has_proxy_through_service_url() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandLookupTopicResponse::clear_has_proxy_through_service_url() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandLookupTopicResponse::clear_proxy_through_service_url() {
  proxy_through_service_url_ = false;
  clear_has_proxy_through_service_url();
}
inline bool CommandLookupTopicResponse::proxy_through_service_url() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.proxy_through_service_url)
  return proxy_through_service_url_;
}
inline void CommandLookupTopicResponse::set_proxy_through_service_url(bool value) {
  set_has_proxy_through_service_url();
  proxy_through_service_url_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.proxy_through_service_url)
}

// -------------------------------------------------------------------

// CommandProducer

// required string topic = 1;
inline bool CommandProducer::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandProducer::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandProducer::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandProducer::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& CommandProducer::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.topic)
  return *topic_;
}
inline void CommandProducer::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.topic)
}
inline void CommandProducer::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandProducer.topic)
}
inline void CommandProducer::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandProducer.topic)
}
inline ::std::string* CommandProducer::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.topic)
  return topic_;
}
inline ::std::string* CommandProducer::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandProducer::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.topic)
}

// required uint64 producer_id = 2;
inline bool CommandProducer::has_producer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandProducer::set_has_producer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandProducer::clear_has_producer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandProducer::clear_producer_id() {
  producer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_producer_id();
}
inline ::google::protobuf::uint64 CommandProducer::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.producer_id)
  return producer_id_;
}
inline void CommandProducer::set_producer_id(::google::protobuf::uint64 value) {
  set_has_producer_id();
  producer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.producer_id)
}

// required uint64 request_id = 3;
inline bool CommandProducer::has_request_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandProducer::set_has_request_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandProducer::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandProducer::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandProducer::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.request_id)
  return request_id_;
}
inline void CommandProducer::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.request_id)
}

// optional string producer_name = 4;
inline bool CommandProducer::has_producer_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandProducer::set_has_producer_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandProducer::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandProducer::clear_producer_name() {
  if (producer_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_->clear();
  }
  clear_has_producer_name();
}
inline const ::std::string& CommandProducer::producer_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.producer_name)
  return *producer_name_;
}
inline void CommandProducer::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  producer_name_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.producer_name)
}
inline void CommandProducer::set_producer_name(const char* value) {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  producer_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandProducer.producer_name)
}
inline void CommandProducer::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  producer_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandProducer.producer_name)
}
inline ::std::string* CommandProducer::mutable_producer_name() {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.producer_name)
  return producer_name_;
}
inline ::std::string* CommandProducer::release_producer_name() {
  clear_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = producer_name_;
    producer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandProducer::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete producer_name_;
  }
  if (producer_name) {
    set_has_producer_name();
    producer_name_ = producer_name;
  } else {
    clear_has_producer_name();
    producer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.producer_name)
}

// optional bool encrypted = 5 [default = false];
inline bool CommandProducer::has_encrypted() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandProducer::set_has_encrypted() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandProducer::clear_has_encrypted() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandProducer::clear_encrypted() {
  encrypted_ = false;
  clear_has_encrypted();
}
inline bool CommandProducer::encrypted() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.encrypted)
  return encrypted_;
}
inline void CommandProducer::set_encrypted(bool value) {
  set_has_encrypted();
  encrypted_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.encrypted)
}

// repeated .pulsar.proto.KeyValue metadata = 6;
inline int CommandProducer::metadata_size() const {
  return metadata_.size();
}
inline void CommandProducer::clear_metadata() {
  metadata_.Clear();
}
inline const ::pulsar::proto::KeyValue& CommandProducer::metadata(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.metadata)
  return metadata_.Get(index);
}
inline ::pulsar::proto::KeyValue* CommandProducer::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.metadata)
  return metadata_.Mutable(index);
}
inline ::pulsar::proto::KeyValue* CommandProducer::add_metadata() {
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandProducer.metadata)
  return metadata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
CommandProducer::metadata() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandProducer.metadata)
  return metadata_;
}
inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
CommandProducer::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandProducer.metadata)
  return &metadata_;
}

// optional .pulsar.proto.Schema schema = 7;
inline bool CommandProducer::has_schema() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandProducer::set_has_schema() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandProducer::clear_has_schema() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandProducer::clear_schema() {
  if (schema_ != NULL) schema_->::pulsar::proto::Schema::Clear();
  clear_has_schema();
}
inline const ::pulsar::proto::Schema& CommandProducer::schema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.schema)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return schema_ != NULL ? *schema_ : *default_instance().schema_;
#else
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
#endif
}
inline ::pulsar::proto::Schema* CommandProducer::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::pulsar::proto::Schema;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.schema)
  return schema_;
}
inline ::pulsar::proto::Schema* CommandProducer::release_schema() {
  clear_has_schema();
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void CommandProducer::set_allocated_schema(::pulsar::proto::Schema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.schema)
}

// -------------------------------------------------------------------

// CommandSend

// required uint64 producer_id = 1;
inline bool CommandSend::has_producer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSend::set_has_producer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSend::clear_has_producer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSend::clear_producer_id() {
  producer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_producer_id();
}
inline ::google::protobuf::uint64 CommandSend::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.producer_id)
  return producer_id_;
}
inline void CommandSend::set_producer_id(::google::protobuf::uint64 value) {
  set_has_producer_id();
  producer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.producer_id)
}

// required uint64 sequence_id = 2;
inline bool CommandSend::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSend::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSend::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSend::clear_sequence_id() {
  sequence_id_ = GOOGLE_ULONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::uint64 CommandSend::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.sequence_id)
  return sequence_id_;
}
inline void CommandSend::set_sequence_id(::google::protobuf::uint64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.sequence_id)
}

// optional int32 num_messages = 3 [default = 1];
inline bool CommandSend::has_num_messages() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSend::set_has_num_messages() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSend::clear_has_num_messages() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSend::clear_num_messages() {
  num_messages_ = 1;
  clear_has_num_messages();
}
inline ::google::protobuf::int32 CommandSend::num_messages() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.num_messages)
  return num_messages_;
}
inline void CommandSend::set_num_messages(::google::protobuf::int32 value) {
  set_has_num_messages();
  num_messages_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.num_messages)
}

// -------------------------------------------------------------------

// CommandSendReceipt

// required uint64 producer_id = 1;
inline bool CommandSendReceipt::has_producer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSendReceipt::set_has_producer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSendReceipt::clear_has_producer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSendReceipt::clear_producer_id() {
  producer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_producer_id();
}
inline ::google::protobuf::uint64 CommandSendReceipt::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.producer_id)
  return producer_id_;
}
inline void CommandSendReceipt::set_producer_id(::google::protobuf::uint64 value) {
  set_has_producer_id();
  producer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendReceipt.producer_id)
}

// required uint64 sequence_id = 2;
inline bool CommandSendReceipt::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSendReceipt::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSendReceipt::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSendReceipt::clear_sequence_id() {
  sequence_id_ = GOOGLE_ULONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::uint64 CommandSendReceipt::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.sequence_id)
  return sequence_id_;
}
inline void CommandSendReceipt::set_sequence_id(::google::protobuf::uint64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendReceipt.sequence_id)
}

// optional .pulsar.proto.MessageIdData message_id = 3;
inline bool CommandSendReceipt::has_message_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSendReceipt::set_has_message_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSendReceipt::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSendReceipt::clear_message_id() {
  if (message_id_ != NULL) message_id_->::pulsar::proto::MessageIdData::Clear();
  clear_has_message_id();
}
inline const ::pulsar::proto::MessageIdData& CommandSendReceipt::message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.message_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_id_ != NULL ? *message_id_ : *default_instance().message_id_;
#else
  return message_id_ != NULL ? *message_id_ : *default_instance_->message_id_;
#endif
}
inline ::pulsar::proto::MessageIdData* CommandSendReceipt::mutable_message_id() {
  set_has_message_id();
  if (message_id_ == NULL) message_id_ = new ::pulsar::proto::MessageIdData;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSendReceipt.message_id)
  return message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSendReceipt::release_message_id() {
  clear_has_message_id();
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = NULL;
  return temp;
}
inline void CommandSendReceipt::set_allocated_message_id(::pulsar::proto::MessageIdData* message_id) {
  delete message_id_;
  message_id_ = message_id;
  if (message_id) {
    set_has_message_id();
  } else {
    clear_has_message_id();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSendReceipt.message_id)
}

// -------------------------------------------------------------------

// CommandSendError

// required uint64 producer_id = 1;
inline bool CommandSendError::has_producer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSendError::set_has_producer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSendError::clear_has_producer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSendError::clear_producer_id() {
  producer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_producer_id();
}
inline ::google::protobuf::uint64 CommandSendError::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.producer_id)
  return producer_id_;
}
inline void CommandSendError::set_producer_id(::google::protobuf::uint64 value) {
  set_has_producer_id();
  producer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.producer_id)
}

// required uint64 sequence_id = 2;
inline bool CommandSendError::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSendError::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSendError::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSendError::clear_sequence_id() {
  sequence_id_ = GOOGLE_ULONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::uint64 CommandSendError::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.sequence_id)
  return sequence_id_;
}
inline void CommandSendError::set_sequence_id(::google::protobuf::uint64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.sequence_id)
}

// required .pulsar.proto.ServerError error = 3;
inline bool CommandSendError::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSendError::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSendError::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSendError::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::pulsar::proto::ServerError CommandSendError::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.error)
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline void CommandSendError::set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.error)
}

// required string message = 4;
inline bool CommandSendError::has_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSendError::set_has_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSendError::clear_has_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSendError::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CommandSendError::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.message)
  return *message_;
}
inline void CommandSendError::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.message)
}
inline void CommandSendError::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandSendError.message)
}
inline void CommandSendError::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandSendError.message)
}
inline ::std::string* CommandSendError::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSendError.message)
  return message_;
}
inline ::std::string* CommandSendError::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandSendError::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSendError.message)
}

// -------------------------------------------------------------------

// CommandMessage

// required uint64 consumer_id = 1;
inline bool CommandMessage::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMessage::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMessage::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMessage::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandMessage::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.consumer_id)
  return consumer_id_;
}
inline void CommandMessage::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandMessage.consumer_id)
}

// required .pulsar.proto.MessageIdData message_id = 2;
inline bool CommandMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMessage::clear_message_id() {
  if (message_id_ != NULL) message_id_->::pulsar::proto::MessageIdData::Clear();
  clear_has_message_id();
}
inline const ::pulsar::proto::MessageIdData& CommandMessage::message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.message_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_id_ != NULL ? *message_id_ : *default_instance().message_id_;
#else
  return message_id_ != NULL ? *message_id_ : *default_instance_->message_id_;
#endif
}
inline ::pulsar::proto::MessageIdData* CommandMessage::mutable_message_id() {
  set_has_message_id();
  if (message_id_ == NULL) message_id_ = new ::pulsar::proto::MessageIdData;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandMessage.message_id)
  return message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandMessage::release_message_id() {
  clear_has_message_id();
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = NULL;
  return temp;
}
inline void CommandMessage::set_allocated_message_id(::pulsar::proto::MessageIdData* message_id) {
  delete message_id_;
  message_id_ = message_id;
  if (message_id) {
    set_has_message_id();
  } else {
    clear_has_message_id();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandMessage.message_id)
}

// optional uint32 redelivery_count = 3 [default = 0];
inline bool CommandMessage::has_redelivery_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandMessage::set_has_redelivery_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandMessage::clear_has_redelivery_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandMessage::clear_redelivery_count() {
  redelivery_count_ = 0u;
  clear_has_redelivery_count();
}
inline ::google::protobuf::uint32 CommandMessage::redelivery_count() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.redelivery_count)
  return redelivery_count_;
}
inline void CommandMessage::set_redelivery_count(::google::protobuf::uint32 value) {
  set_has_redelivery_count();
  redelivery_count_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandMessage.redelivery_count)
}

// -------------------------------------------------------------------

// CommandAck

// required uint64 consumer_id = 1;
inline bool CommandAck::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandAck::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandAck::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandAck::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandAck::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.consumer_id)
  return consumer_id_;
}
inline void CommandAck::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.consumer_id)
}

// required .pulsar.proto.CommandAck.AckType ack_type = 2;
inline bool CommandAck::has_ack_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandAck::set_has_ack_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandAck::clear_has_ack_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandAck::clear_ack_type() {
  ack_type_ = 0;
  clear_has_ack_type();
}
inline ::pulsar::proto::CommandAck_AckType CommandAck::ack_type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.ack_type)
  return static_cast< ::pulsar::proto::CommandAck_AckType >(ack_type_);
}
inline void CommandAck::set_ack_type(::pulsar::proto::CommandAck_AckType value) {
  assert(::pulsar::proto::CommandAck_AckType_IsValid(value));
  set_has_ack_type();
  ack_type_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.ack_type)
}

// repeated .pulsar.proto.MessageIdData message_id = 3;
inline int CommandAck::message_id_size() const {
  return message_id_.size();
}
inline void CommandAck::clear_message_id() {
  message_id_.Clear();
}
inline const ::pulsar::proto::MessageIdData& CommandAck::message_id(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.message_id)
  return message_id_.Get(index);
}
inline ::pulsar::proto::MessageIdData* CommandAck::mutable_message_id(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAck.message_id)
  return message_id_.Mutable(index);
}
inline ::pulsar::proto::MessageIdData* CommandAck::add_message_id() {
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAck.message_id)
  return message_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >&
CommandAck::message_id() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandAck.message_id)
  return message_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >*
CommandAck::mutable_message_id() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandAck.message_id)
  return &message_id_;
}

// optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
inline bool CommandAck::has_validation_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandAck::set_has_validation_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandAck::clear_has_validation_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandAck::clear_validation_error() {
  validation_error_ = 0;
  clear_has_validation_error();
}
inline ::pulsar::proto::CommandAck_ValidationError CommandAck::validation_error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.validation_error)
  return static_cast< ::pulsar::proto::CommandAck_ValidationError >(validation_error_);
}
inline void CommandAck::set_validation_error(::pulsar::proto::CommandAck_ValidationError value) {
  assert(::pulsar::proto::CommandAck_ValidationError_IsValid(value));
  set_has_validation_error();
  validation_error_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.validation_error)
}

// repeated .pulsar.proto.KeyLongValue properties = 5;
inline int CommandAck::properties_size() const {
  return properties_.size();
}
inline void CommandAck::clear_properties() {
  properties_.Clear();
}
inline const ::pulsar::proto::KeyLongValue& CommandAck::properties(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.properties)
  return properties_.Get(index);
}
inline ::pulsar::proto::KeyLongValue* CommandAck::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAck.properties)
  return properties_.Mutable(index);
}
inline ::pulsar::proto::KeyLongValue* CommandAck::add_properties() {
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAck.properties)
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyLongValue >&
CommandAck::properties() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandAck.properties)
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyLongValue >*
CommandAck::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandAck.properties)
  return &properties_;
}

// -------------------------------------------------------------------

// CommandActiveConsumerChange

// required uint64 consumer_id = 1;
inline bool CommandActiveConsumerChange::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandActiveConsumerChange::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandActiveConsumerChange::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandActiveConsumerChange::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandActiveConsumerChange::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandActiveConsumerChange.consumer_id)
  return consumer_id_;
}
inline void CommandActiveConsumerChange::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandActiveConsumerChange.consumer_id)
}

// optional bool is_active = 2 [default = false];
inline bool CommandActiveConsumerChange::has_is_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandActiveConsumerChange::set_has_is_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandActiveConsumerChange::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandActiveConsumerChange::clear_is_active() {
  is_active_ = false;
  clear_has_is_active();
}
inline bool CommandActiveConsumerChange::is_active() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandActiveConsumerChange.is_active)
  return is_active_;
}
inline void CommandActiveConsumerChange::set_is_active(bool value) {
  set_has_is_active();
  is_active_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandActiveConsumerChange.is_active)
}

// -------------------------------------------------------------------

// CommandFlow

// required uint64 consumer_id = 1;
inline bool CommandFlow::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandFlow::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandFlow::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandFlow::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandFlow::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandFlow.consumer_id)
  return consumer_id_;
}
inline void CommandFlow::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandFlow.consumer_id)
}

// required uint32 messagePermits = 2;
inline bool CommandFlow::has_messagepermits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandFlow::set_has_messagepermits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandFlow::clear_has_messagepermits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandFlow::clear_messagepermits() {
  messagepermits_ = 0u;
  clear_has_messagepermits();
}
inline ::google::protobuf::uint32 CommandFlow::messagepermits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandFlow.messagePermits)
  return messagepermits_;
}
inline void CommandFlow::set_messagepermits(::google::protobuf::uint32 value) {
  set_has_messagepermits();
  messagepermits_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandFlow.messagePermits)
}

// -------------------------------------------------------------------

// CommandUnsubscribe

// required uint64 consumer_id = 1;
inline bool CommandUnsubscribe::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandUnsubscribe::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandUnsubscribe::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandUnsubscribe::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandUnsubscribe::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandUnsubscribe.consumer_id)
  return consumer_id_;
}
inline void CommandUnsubscribe::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandUnsubscribe.consumer_id)
}

// required uint64 request_id = 2;
inline bool CommandUnsubscribe::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandUnsubscribe::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandUnsubscribe::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandUnsubscribe::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandUnsubscribe::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandUnsubscribe.request_id)
  return request_id_;
}
inline void CommandUnsubscribe::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandUnsubscribe.request_id)
}

// -------------------------------------------------------------------

// CommandSeek

// required uint64 consumer_id = 1;
inline bool CommandSeek::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSeek::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSeek::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSeek::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandSeek::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.consumer_id)
  return consumer_id_;
}
inline void CommandSeek::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSeek.consumer_id)
}

// required uint64 request_id = 2;
inline bool CommandSeek::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSeek::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSeek::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSeek::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandSeek::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.request_id)
  return request_id_;
}
inline void CommandSeek::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSeek.request_id)
}

// optional .pulsar.proto.MessageIdData message_id = 3;
inline bool CommandSeek::has_message_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSeek::set_has_message_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSeek::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSeek::clear_message_id() {
  if (message_id_ != NULL) message_id_->::pulsar::proto::MessageIdData::Clear();
  clear_has_message_id();
}
inline const ::pulsar::proto::MessageIdData& CommandSeek::message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.message_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_id_ != NULL ? *message_id_ : *default_instance().message_id_;
#else
  return message_id_ != NULL ? *message_id_ : *default_instance_->message_id_;
#endif
}
inline ::pulsar::proto::MessageIdData* CommandSeek::mutable_message_id() {
  set_has_message_id();
  if (message_id_ == NULL) message_id_ = new ::pulsar::proto::MessageIdData;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSeek.message_id)
  return message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSeek::release_message_id() {
  clear_has_message_id();
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = NULL;
  return temp;
}
inline void CommandSeek::set_allocated_message_id(::pulsar::proto::MessageIdData* message_id) {
  delete message_id_;
  message_id_ = message_id;
  if (message_id) {
    set_has_message_id();
  } else {
    clear_has_message_id();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSeek.message_id)
}

// optional uint64 message_publish_time = 4;
inline bool CommandSeek::has_message_publish_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSeek::set_has_message_publish_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSeek::clear_has_message_publish_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSeek::clear_message_publish_time() {
  message_publish_time_ = GOOGLE_ULONGLONG(0);
  clear_has_message_publish_time();
}
inline ::google::protobuf::uint64 CommandSeek::message_publish_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.message_publish_time)
  return message_publish_time_;
}
inline void CommandSeek::set_message_publish_time(::google::protobuf::uint64 value) {
  set_has_message_publish_time();
  message_publish_time_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSeek.message_publish_time)
}

// -------------------------------------------------------------------

// CommandReachedEndOfTopic

// required uint64 consumer_id = 1;
inline bool CommandReachedEndOfTopic::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandReachedEndOfTopic::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandReachedEndOfTopic::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandReachedEndOfTopic::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandReachedEndOfTopic::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandReachedEndOfTopic.consumer_id)
  return consumer_id_;
}
inline void CommandReachedEndOfTopic::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandReachedEndOfTopic.consumer_id)
}

// -------------------------------------------------------------------

// CommandCloseProducer

// required uint64 producer_id = 1;
inline bool CommandCloseProducer::has_producer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandCloseProducer::set_has_producer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandCloseProducer::clear_has_producer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandCloseProducer::clear_producer_id() {
  producer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_producer_id();
}
inline ::google::protobuf::uint64 CommandCloseProducer::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseProducer.producer_id)
  return producer_id_;
}
inline void CommandCloseProducer::set_producer_id(::google::protobuf::uint64 value) {
  set_has_producer_id();
  producer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseProducer.producer_id)
}

// required uint64 request_id = 2;
inline bool CommandCloseProducer::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandCloseProducer::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandCloseProducer::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandCloseProducer::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandCloseProducer::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseProducer.request_id)
  return request_id_;
}
inline void CommandCloseProducer::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseProducer.request_id)
}

// -------------------------------------------------------------------

// CommandCloseConsumer

// required uint64 consumer_id = 1;
inline bool CommandCloseConsumer::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandCloseConsumer::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandCloseConsumer::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandCloseConsumer::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandCloseConsumer::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseConsumer.consumer_id)
  return consumer_id_;
}
inline void CommandCloseConsumer::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseConsumer.consumer_id)
}

// required uint64 request_id = 2;
inline bool CommandCloseConsumer::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandCloseConsumer::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandCloseConsumer::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandCloseConsumer::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandCloseConsumer::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseConsumer.request_id)
  return request_id_;
}
inline void CommandCloseConsumer::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseConsumer.request_id)
}

// -------------------------------------------------------------------

// CommandRedeliverUnacknowledgedMessages

// required uint64 consumer_id = 1;
inline bool CommandRedeliverUnacknowledgedMessages::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRedeliverUnacknowledgedMessages::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRedeliverUnacknowledgedMessages::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRedeliverUnacknowledgedMessages::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandRedeliverUnacknowledgedMessages::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandRedeliverUnacknowledgedMessages.consumer_id)
  return consumer_id_;
}
inline void CommandRedeliverUnacknowledgedMessages::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandRedeliverUnacknowledgedMessages.consumer_id)
}

// repeated .pulsar.proto.MessageIdData message_ids = 2;
inline int CommandRedeliverUnacknowledgedMessages::message_ids_size() const {
  return message_ids_.size();
}
inline void CommandRedeliverUnacknowledgedMessages::clear_message_ids() {
  message_ids_.Clear();
}
inline const ::pulsar::proto::MessageIdData& CommandRedeliverUnacknowledgedMessages::message_ids(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return message_ids_.Get(index);
}
inline ::pulsar::proto::MessageIdData* CommandRedeliverUnacknowledgedMessages::mutable_message_ids(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return message_ids_.Mutable(index);
}
inline ::pulsar::proto::MessageIdData* CommandRedeliverUnacknowledgedMessages::add_message_ids() {
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return message_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >&
CommandRedeliverUnacknowledgedMessages::message_ids() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return message_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >*
CommandRedeliverUnacknowledgedMessages::mutable_message_ids() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return &message_ids_;
}

// -------------------------------------------------------------------

// CommandSuccess

// required uint64 request_id = 1;
inline bool CommandSuccess::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSuccess::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSuccess::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSuccess::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandSuccess::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSuccess.request_id)
  return request_id_;
}
inline void CommandSuccess::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSuccess.request_id)
}

// optional .pulsar.proto.Schema schema = 2;
inline bool CommandSuccess::has_schema() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSuccess::set_has_schema() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSuccess::clear_has_schema() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSuccess::clear_schema() {
  if (schema_ != NULL) schema_->::pulsar::proto::Schema::Clear();
  clear_has_schema();
}
inline const ::pulsar::proto::Schema& CommandSuccess::schema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSuccess.schema)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return schema_ != NULL ? *schema_ : *default_instance().schema_;
#else
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
#endif
}
inline ::pulsar::proto::Schema* CommandSuccess::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::pulsar::proto::Schema;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSuccess.schema)
  return schema_;
}
inline ::pulsar::proto::Schema* CommandSuccess::release_schema() {
  clear_has_schema();
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void CommandSuccess::set_allocated_schema(::pulsar::proto::Schema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSuccess.schema)
}

// -------------------------------------------------------------------

// CommandProducerSuccess

// required uint64 request_id = 1;
inline bool CommandProducerSuccess::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandProducerSuccess::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandProducerSuccess::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandProducerSuccess::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandProducerSuccess::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.request_id)
  return request_id_;
}
inline void CommandProducerSuccess::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.request_id)
}

// required string producer_name = 2;
inline bool CommandProducerSuccess::has_producer_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandProducerSuccess::set_has_producer_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandProducerSuccess::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandProducerSuccess::clear_producer_name() {
  if (producer_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_->clear();
  }
  clear_has_producer_name();
}
inline const ::std::string& CommandProducerSuccess::producer_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.producer_name)
  return *producer_name_;
}
inline void CommandProducerSuccess::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  producer_name_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.producer_name)
}
inline void CommandProducerSuccess::set_producer_name(const char* value) {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  producer_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandProducerSuccess.producer_name)
}
inline void CommandProducerSuccess::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  producer_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandProducerSuccess.producer_name)
}
inline ::std::string* CommandProducerSuccess::mutable_producer_name() {
  set_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    producer_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducerSuccess.producer_name)
  return producer_name_;
}
inline ::std::string* CommandProducerSuccess::release_producer_name() {
  clear_has_producer_name();
  if (producer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = producer_name_;
    producer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandProducerSuccess::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete producer_name_;
  }
  if (producer_name) {
    set_has_producer_name();
    producer_name_ = producer_name;
  } else {
    clear_has_producer_name();
    producer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducerSuccess.producer_name)
}

// optional int64 last_sequence_id = 3 [default = -1];
inline bool CommandProducerSuccess::has_last_sequence_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandProducerSuccess::set_has_last_sequence_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandProducerSuccess::clear_has_last_sequence_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandProducerSuccess::clear_last_sequence_id() {
  last_sequence_id_ = GOOGLE_LONGLONG(-1);
  clear_has_last_sequence_id();
}
inline ::google::protobuf::int64 CommandProducerSuccess::last_sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.last_sequence_id)
  return last_sequence_id_;
}
inline void CommandProducerSuccess::set_last_sequence_id(::google::protobuf::int64 value) {
  set_has_last_sequence_id();
  last_sequence_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.last_sequence_id)
}

// optional bytes schema_version = 4;
inline bool CommandProducerSuccess::has_schema_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandProducerSuccess::set_has_schema_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandProducerSuccess::clear_has_schema_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandProducerSuccess::clear_schema_version() {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_->clear();
  }
  clear_has_schema_version();
}
inline const ::std::string& CommandProducerSuccess::schema_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.schema_version)
  return *schema_version_;
}
inline void CommandProducerSuccess::set_schema_version(const ::std::string& value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.schema_version)
}
inline void CommandProducerSuccess::set_schema_version(const char* value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandProducerSuccess.schema_version)
}
inline void CommandProducerSuccess::set_schema_version(const void* value, size_t size) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandProducerSuccess.schema_version)
}
inline ::std::string* CommandProducerSuccess::mutable_schema_version() {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducerSuccess.schema_version)
  return schema_version_;
}
inline ::std::string* CommandProducerSuccess::release_schema_version() {
  clear_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_version_;
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandProducerSuccess::set_allocated_schema_version(::std::string* schema_version) {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_version_;
  }
  if (schema_version) {
    set_has_schema_version();
    schema_version_ = schema_version;
  } else {
    clear_has_schema_version();
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducerSuccess.schema_version)
}

// -------------------------------------------------------------------

// CommandError

// required uint64 request_id = 1;
inline bool CommandError::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandError::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandError::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandError::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandError::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandError.request_id)
  return request_id_;
}
inline void CommandError::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandError.request_id)
}

// required .pulsar.proto.ServerError error = 2;
inline bool CommandError::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandError::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandError::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandError::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::pulsar::proto::ServerError CommandError::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandError.error)
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline void CommandError::set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandError.error)
}

// required string message = 3;
inline bool CommandError::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandError::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandError::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandError::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& CommandError::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandError.message)
  return *message_;
}
inline void CommandError::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandError.message)
}
inline void CommandError::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandError.message)
}
inline void CommandError::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandError.message)
}
inline ::std::string* CommandError::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandError.message)
  return message_;
}
inline ::std::string* CommandError::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandError::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandError.message)
}

// -------------------------------------------------------------------

// CommandPing

// -------------------------------------------------------------------

// CommandPong

// -------------------------------------------------------------------

// CommandConsumerStats

// required uint64 request_id = 1;
inline bool CommandConsumerStats::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandConsumerStats::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandConsumerStats::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandConsumerStats::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandConsumerStats::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStats.request_id)
  return request_id_;
}
inline void CommandConsumerStats::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStats.request_id)
}

// required uint64 consumer_id = 4;
inline bool CommandConsumerStats::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandConsumerStats::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandConsumerStats::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandConsumerStats::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandConsumerStats::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStats.consumer_id)
  return consumer_id_;
}
inline void CommandConsumerStats::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStats.consumer_id)
}

// -------------------------------------------------------------------

// CommandConsumerStatsResponse

// required uint64 request_id = 1;
inline bool CommandConsumerStatsResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandConsumerStatsResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandConsumerStatsResponse::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandConsumerStatsResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.request_id)
  return request_id_;
}
inline void CommandConsumerStatsResponse::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.request_id)
}

// optional .pulsar.proto.ServerError error_code = 2;
inline bool CommandConsumerStatsResponse::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandConsumerStatsResponse::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandConsumerStatsResponse::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::pulsar::proto::ServerError CommandConsumerStatsResponse::error_code() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.error_code)
  return static_cast< ::pulsar::proto::ServerError >(error_code_);
}
inline void CommandConsumerStatsResponse::set_error_code(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.error_code)
}

// optional string error_message = 3;
inline bool CommandConsumerStatsResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandConsumerStatsResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandConsumerStatsResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& CommandConsumerStatsResponse::error_message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.error_message)
  return *error_message_;
}
inline void CommandConsumerStatsResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.error_message)
}
inline void CommandConsumerStatsResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConsumerStatsResponse.error_message)
}
inline void CommandConsumerStatsResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConsumerStatsResponse.error_message)
}
inline ::std::string* CommandConsumerStatsResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.error_message)
  return error_message_;
}
inline ::std::string* CommandConsumerStatsResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConsumerStatsResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.error_message)
}

// optional double msgRateOut = 4;
inline bool CommandConsumerStatsResponse::has_msgrateout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_msgrateout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandConsumerStatsResponse::clear_has_msgrateout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandConsumerStatsResponse::clear_msgrateout() {
  msgrateout_ = 0;
  clear_has_msgrateout();
}
inline double CommandConsumerStatsResponse::msgrateout() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgRateOut)
  return msgrateout_;
}
inline void CommandConsumerStatsResponse::set_msgrateout(double value) {
  set_has_msgrateout();
  msgrateout_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgRateOut)
}

// optional double msgThroughputOut = 5;
inline bool CommandConsumerStatsResponse::has_msgthroughputout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_msgthroughputout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandConsumerStatsResponse::clear_has_msgthroughputout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandConsumerStatsResponse::clear_msgthroughputout() {
  msgthroughputout_ = 0;
  clear_has_msgthroughputout();
}
inline double CommandConsumerStatsResponse::msgthroughputout() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgThroughputOut)
  return msgthroughputout_;
}
inline void CommandConsumerStatsResponse::set_msgthroughputout(double value) {
  set_has_msgthroughputout();
  msgthroughputout_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgThroughputOut)
}

// optional double msgRateRedeliver = 6;
inline bool CommandConsumerStatsResponse::has_msgrateredeliver() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_msgrateredeliver() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandConsumerStatsResponse::clear_has_msgrateredeliver() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandConsumerStatsResponse::clear_msgrateredeliver() {
  msgrateredeliver_ = 0;
  clear_has_msgrateredeliver();
}
inline double CommandConsumerStatsResponse::msgrateredeliver() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgRateRedeliver)
  return msgrateredeliver_;
}
inline void CommandConsumerStatsResponse::set_msgrateredeliver(double value) {
  set_has_msgrateredeliver();
  msgrateredeliver_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgRateRedeliver)
}

// optional string consumerName = 7;
inline bool CommandConsumerStatsResponse::has_consumername() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_consumername() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandConsumerStatsResponse::clear_has_consumername() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandConsumerStatsResponse::clear_consumername() {
  if (consumername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    consumername_->clear();
  }
  clear_has_consumername();
}
inline const ::std::string& CommandConsumerStatsResponse::consumername() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.consumerName)
  return *consumername_;
}
inline void CommandConsumerStatsResponse::set_consumername(const ::std::string& value) {
  set_has_consumername();
  if (consumername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    consumername_ = new ::std::string;
  }
  consumername_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.consumerName)
}
inline void CommandConsumerStatsResponse::set_consumername(const char* value) {
  set_has_consumername();
  if (consumername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    consumername_ = new ::std::string;
  }
  consumername_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConsumerStatsResponse.consumerName)
}
inline void CommandConsumerStatsResponse::set_consumername(const char* value, size_t size) {
  set_has_consumername();
  if (consumername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    consumername_ = new ::std::string;
  }
  consumername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConsumerStatsResponse.consumerName)
}
inline ::std::string* CommandConsumerStatsResponse::mutable_consumername() {
  set_has_consumername();
  if (consumername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    consumername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.consumerName)
  return consumername_;
}
inline ::std::string* CommandConsumerStatsResponse::release_consumername() {
  clear_has_consumername();
  if (consumername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = consumername_;
    consumername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConsumerStatsResponse::set_allocated_consumername(::std::string* consumername) {
  if (consumername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete consumername_;
  }
  if (consumername) {
    set_has_consumername();
    consumername_ = consumername;
  } else {
    clear_has_consumername();
    consumername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.consumerName)
}

// optional uint64 availablePermits = 8;
inline bool CommandConsumerStatsResponse::has_availablepermits() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_availablepermits() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandConsumerStatsResponse::clear_has_availablepermits() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandConsumerStatsResponse::clear_availablepermits() {
  availablepermits_ = GOOGLE_ULONGLONG(0);
  clear_has_availablepermits();
}
inline ::google::protobuf::uint64 CommandConsumerStatsResponse::availablepermits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.availablePermits)
  return availablepermits_;
}
inline void CommandConsumerStatsResponse::set_availablepermits(::google::protobuf::uint64 value) {
  set_has_availablepermits();
  availablepermits_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.availablePermits)
}

// optional uint64 unackedMessages = 9;
inline bool CommandConsumerStatsResponse::has_unackedmessages() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_unackedmessages() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommandConsumerStatsResponse::clear_has_unackedmessages() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommandConsumerStatsResponse::clear_unackedmessages() {
  unackedmessages_ = GOOGLE_ULONGLONG(0);
  clear_has_unackedmessages();
}
inline ::google::protobuf::uint64 CommandConsumerStatsResponse::unackedmessages() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.unackedMessages)
  return unackedmessages_;
}
inline void CommandConsumerStatsResponse::set_unackedmessages(::google::protobuf::uint64 value) {
  set_has_unackedmessages();
  unackedmessages_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.unackedMessages)
}

// optional bool blockedConsumerOnUnackedMsgs = 10;
inline bool CommandConsumerStatsResponse::has_blockedconsumeronunackedmsgs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_blockedconsumeronunackedmsgs() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommandConsumerStatsResponse::clear_has_blockedconsumeronunackedmsgs() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommandConsumerStatsResponse::clear_blockedconsumeronunackedmsgs() {
  blockedconsumeronunackedmsgs_ = false;
  clear_has_blockedconsumeronunackedmsgs();
}
inline bool CommandConsumerStatsResponse::blockedconsumeronunackedmsgs() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.blockedConsumerOnUnackedMsgs)
  return blockedconsumeronunackedmsgs_;
}
inline void CommandConsumerStatsResponse::set_blockedconsumeronunackedmsgs(bool value) {
  set_has_blockedconsumeronunackedmsgs();
  blockedconsumeronunackedmsgs_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.blockedConsumerOnUnackedMsgs)
}

// optional string address = 11;
inline bool CommandConsumerStatsResponse::has_address() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_address() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommandConsumerStatsResponse::clear_has_address() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommandConsumerStatsResponse::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& CommandConsumerStatsResponse::address() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.address)
  return *address_;
}
inline void CommandConsumerStatsResponse::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.address)
}
inline void CommandConsumerStatsResponse::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConsumerStatsResponse.address)
}
inline void CommandConsumerStatsResponse::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConsumerStatsResponse.address)
}
inline ::std::string* CommandConsumerStatsResponse::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.address)
  return address_;
}
inline ::std::string* CommandConsumerStatsResponse::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConsumerStatsResponse::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.address)
}

// optional string connectedSince = 12;
inline bool CommandConsumerStatsResponse::has_connectedsince() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_connectedsince() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommandConsumerStatsResponse::clear_has_connectedsince() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommandConsumerStatsResponse::clear_connectedsince() {
  if (connectedsince_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    connectedsince_->clear();
  }
  clear_has_connectedsince();
}
inline const ::std::string& CommandConsumerStatsResponse::connectedsince() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
  return *connectedsince_;
}
inline void CommandConsumerStatsResponse::set_connectedsince(const ::std::string& value) {
  set_has_connectedsince();
  if (connectedsince_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    connectedsince_ = new ::std::string;
  }
  connectedsince_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
}
inline void CommandConsumerStatsResponse::set_connectedsince(const char* value) {
  set_has_connectedsince();
  if (connectedsince_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    connectedsince_ = new ::std::string;
  }
  connectedsince_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
}
inline void CommandConsumerStatsResponse::set_connectedsince(const char* value, size_t size) {
  set_has_connectedsince();
  if (connectedsince_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    connectedsince_ = new ::std::string;
  }
  connectedsince_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
}
inline ::std::string* CommandConsumerStatsResponse::mutable_connectedsince() {
  set_has_connectedsince();
  if (connectedsince_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    connectedsince_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
  return connectedsince_;
}
inline ::std::string* CommandConsumerStatsResponse::release_connectedsince() {
  clear_has_connectedsince();
  if (connectedsince_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = connectedsince_;
    connectedsince_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConsumerStatsResponse::set_allocated_connectedsince(::std::string* connectedsince) {
  if (connectedsince_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete connectedsince_;
  }
  if (connectedsince) {
    set_has_connectedsince();
    connectedsince_ = connectedsince;
  } else {
    clear_has_connectedsince();
    connectedsince_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
}

// optional string type = 13;
inline bool CommandConsumerStatsResponse::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommandConsumerStatsResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommandConsumerStatsResponse::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& CommandConsumerStatsResponse::type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.type)
  return *type_;
}
inline void CommandConsumerStatsResponse::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.type)
}
inline void CommandConsumerStatsResponse::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandConsumerStatsResponse.type)
}
inline void CommandConsumerStatsResponse::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandConsumerStatsResponse.type)
}
inline ::std::string* CommandConsumerStatsResponse::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.type)
  return type_;
}
inline ::std::string* CommandConsumerStatsResponse::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandConsumerStatsResponse::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.type)
}

// optional double msgRateExpired = 14;
inline bool CommandConsumerStatsResponse::has_msgrateexpired() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_msgrateexpired() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CommandConsumerStatsResponse::clear_has_msgrateexpired() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CommandConsumerStatsResponse::clear_msgrateexpired() {
  msgrateexpired_ = 0;
  clear_has_msgrateexpired();
}
inline double CommandConsumerStatsResponse::msgrateexpired() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgRateExpired)
  return msgrateexpired_;
}
inline void CommandConsumerStatsResponse::set_msgrateexpired(double value) {
  set_has_msgrateexpired();
  msgrateexpired_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgRateExpired)
}

// optional uint64 msgBacklog = 15;
inline bool CommandConsumerStatsResponse::has_msgbacklog() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CommandConsumerStatsResponse::set_has_msgbacklog() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CommandConsumerStatsResponse::clear_has_msgbacklog() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CommandConsumerStatsResponse::clear_msgbacklog() {
  msgbacklog_ = GOOGLE_ULONGLONG(0);
  clear_has_msgbacklog();
}
inline ::google::protobuf::uint64 CommandConsumerStatsResponse::msgbacklog() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgBacklog)
  return msgbacklog_;
}
inline void CommandConsumerStatsResponse::set_msgbacklog(::google::protobuf::uint64 value) {
  set_has_msgbacklog();
  msgbacklog_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgBacklog)
}

// -------------------------------------------------------------------

// CommandGetLastMessageId

// required uint64 consumer_id = 1;
inline bool CommandGetLastMessageId::has_consumer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandGetLastMessageId::set_has_consumer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandGetLastMessageId::clear_has_consumer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandGetLastMessageId::clear_consumer_id() {
  consumer_id_ = GOOGLE_ULONGLONG(0);
  clear_has_consumer_id();
}
inline ::google::protobuf::uint64 CommandGetLastMessageId::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageId.consumer_id)
  return consumer_id_;
}
inline void CommandGetLastMessageId::set_consumer_id(::google::protobuf::uint64 value) {
  set_has_consumer_id();
  consumer_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetLastMessageId.consumer_id)
}

// required uint64 request_id = 2;
inline bool CommandGetLastMessageId::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandGetLastMessageId::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandGetLastMessageId::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandGetLastMessageId::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandGetLastMessageId::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageId.request_id)
  return request_id_;
}
inline void CommandGetLastMessageId::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetLastMessageId.request_id)
}

// -------------------------------------------------------------------

// CommandGetLastMessageIdResponse

// required .pulsar.proto.MessageIdData last_message_id = 1;
inline bool CommandGetLastMessageIdResponse::has_last_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandGetLastMessageIdResponse::set_has_last_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandGetLastMessageIdResponse::clear_has_last_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandGetLastMessageIdResponse::clear_last_message_id() {
  if (last_message_id_ != NULL) last_message_id_->::pulsar::proto::MessageIdData::Clear();
  clear_has_last_message_id();
}
inline const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::last_message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return last_message_id_ != NULL ? *last_message_id_ : *default_instance().last_message_id_;
#else
  return last_message_id_ != NULL ? *last_message_id_ : *default_instance_->last_message_id_;
#endif
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::mutable_last_message_id() {
  set_has_last_message_id();
  if (last_message_id_ == NULL) last_message_id_ = new ::pulsar::proto::MessageIdData;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
  return last_message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::release_last_message_id() {
  clear_has_last_message_id();
  ::pulsar::proto::MessageIdData* temp = last_message_id_;
  last_message_id_ = NULL;
  return temp;
}
inline void CommandGetLastMessageIdResponse::set_allocated_last_message_id(::pulsar::proto::MessageIdData* last_message_id) {
  delete last_message_id_;
  last_message_id_ = last_message_id;
  if (last_message_id) {
    set_has_last_message_id();
  } else {
    clear_has_last_message_id();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
}

// required uint64 request_id = 2;
inline bool CommandGetLastMessageIdResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandGetLastMessageIdResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandGetLastMessageIdResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandGetLastMessageIdResponse::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandGetLastMessageIdResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageIdResponse.request_id)
  return request_id_;
}
inline void CommandGetLastMessageIdResponse::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetLastMessageIdResponse.request_id)
}

// -------------------------------------------------------------------

// CommandGetTopicsOfNamespace

// required uint64 request_id = 1;
inline bool CommandGetTopicsOfNamespace::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandGetTopicsOfNamespace::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandGetTopicsOfNamespace::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandGetTopicsOfNamespace::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandGetTopicsOfNamespace::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.request_id)
  return request_id_;
}
inline void CommandGetTopicsOfNamespace::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.request_id)
}

// required string namespace = 2;
inline bool CommandGetTopicsOfNamespace::has_namespace_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandGetTopicsOfNamespace::set_has_namespace_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandGetTopicsOfNamespace::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandGetTopicsOfNamespace::clear_namespace_() {
  if (namespace__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__->clear();
  }
  clear_has_namespace_();
}
inline const ::std::string& CommandGetTopicsOfNamespace::namespace_() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
  return *namespace__;
}
inline void CommandGetTopicsOfNamespace::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
}
inline void CommandGetTopicsOfNamespace::set_namespace_(const char* value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
}
inline void CommandGetTopicsOfNamespace::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
}
inline ::std::string* CommandGetTopicsOfNamespace::mutable_namespace_() {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
  return namespace__;
}
inline ::std::string* CommandGetTopicsOfNamespace::release_namespace_() {
  clear_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = namespace__;
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandGetTopicsOfNamespace::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete namespace__;
  }
  if (namespace_) {
    set_has_namespace_();
    namespace__ = namespace_;
  } else {
    clear_has_namespace_();
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
}

// optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
inline bool CommandGetTopicsOfNamespace::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandGetTopicsOfNamespace::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandGetTopicsOfNamespace::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandGetTopicsOfNamespace::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::mode() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.mode)
  return static_cast< ::pulsar::proto::CommandGetTopicsOfNamespace_Mode >(mode_);
}
inline void CommandGetTopicsOfNamespace::set_mode(::pulsar::proto::CommandGetTopicsOfNamespace_Mode value) {
  assert(::pulsar::proto::CommandGetTopicsOfNamespace_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.mode)
}

// -------------------------------------------------------------------

// CommandGetTopicsOfNamespaceResponse

// required uint64 request_id = 1;
inline bool CommandGetTopicsOfNamespaceResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandGetTopicsOfNamespaceResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandGetTopicsOfNamespaceResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandGetTopicsOfNamespaceResponse::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandGetTopicsOfNamespaceResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.request_id)
  return request_id_;
}
inline void CommandGetTopicsOfNamespaceResponse::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.request_id)
}

// repeated string topics = 2;
inline int CommandGetTopicsOfNamespaceResponse::topics_size() const {
  return topics_.size();
}
inline void CommandGetTopicsOfNamespaceResponse::clear_topics() {
  topics_.Clear();
}
inline const ::std::string& CommandGetTopicsOfNamespaceResponse::topics(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return topics_.Get(index);
}
inline ::std::string* CommandGetTopicsOfNamespaceResponse::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return topics_.Mutable(index);
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  topics_.Mutable(index)->assign(value);
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, const char* value) {
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, const char* value, size_t size) {
  topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline ::std::string* CommandGetTopicsOfNamespaceResponse::add_topics() {
  return topics_.Add();
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(const ::std::string& value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(const char* value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(const char* value, size_t size) {
  topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandGetTopicsOfNamespaceResponse::topics() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return topics_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandGetTopicsOfNamespaceResponse::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return &topics_;
}

// -------------------------------------------------------------------

// CommandGetSchema

// required uint64 request_id = 1;
inline bool CommandGetSchema::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandGetSchema::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandGetSchema::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandGetSchema::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandGetSchema::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchema.request_id)
  return request_id_;
}
inline void CommandGetSchema::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchema.request_id)
}

// required string topic = 2;
inline bool CommandGetSchema::has_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandGetSchema::set_has_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandGetSchema::clear_has_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandGetSchema::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& CommandGetSchema::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchema.topic)
  return *topic_;
}
inline void CommandGetSchema::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchema.topic)
}
inline void CommandGetSchema::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandGetSchema.topic)
}
inline void CommandGetSchema::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandGetSchema.topic)
}
inline ::std::string* CommandGetSchema::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchema.topic)
  return topic_;
}
inline ::std::string* CommandGetSchema::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandGetSchema::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchema.topic)
}

// optional bytes schema_version = 3;
inline bool CommandGetSchema::has_schema_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandGetSchema::set_has_schema_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandGetSchema::clear_has_schema_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandGetSchema::clear_schema_version() {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_->clear();
  }
  clear_has_schema_version();
}
inline const ::std::string& CommandGetSchema::schema_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchema.schema_version)
  return *schema_version_;
}
inline void CommandGetSchema::set_schema_version(const ::std::string& value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchema.schema_version)
}
inline void CommandGetSchema::set_schema_version(const char* value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandGetSchema.schema_version)
}
inline void CommandGetSchema::set_schema_version(const void* value, size_t size) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandGetSchema.schema_version)
}
inline ::std::string* CommandGetSchema::mutable_schema_version() {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchema.schema_version)
  return schema_version_;
}
inline ::std::string* CommandGetSchema::release_schema_version() {
  clear_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_version_;
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandGetSchema::set_allocated_schema_version(::std::string* schema_version) {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_version_;
  }
  if (schema_version) {
    set_has_schema_version();
    schema_version_ = schema_version;
  } else {
    clear_has_schema_version();
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchema.schema_version)
}

// -------------------------------------------------------------------

// CommandGetSchemaResponse

// required uint64 request_id = 1;
inline bool CommandGetSchemaResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandGetSchemaResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandGetSchemaResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandGetSchemaResponse::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 CommandGetSchemaResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.request_id)
  return request_id_;
}
inline void CommandGetSchemaResponse::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.request_id)
}

// optional .pulsar.proto.ServerError error_code = 2;
inline bool CommandGetSchemaResponse::has_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandGetSchemaResponse::set_has_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandGetSchemaResponse::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandGetSchemaResponse::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::pulsar::proto::ServerError CommandGetSchemaResponse::error_code() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.error_code)
  return static_cast< ::pulsar::proto::ServerError >(error_code_);
}
inline void CommandGetSchemaResponse::set_error_code(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.error_code)
}

// optional string error_message = 3;
inline bool CommandGetSchemaResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandGetSchemaResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandGetSchemaResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandGetSchemaResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& CommandGetSchemaResponse::error_message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.error_message)
  return *error_message_;
}
inline void CommandGetSchemaResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.error_message)
}
inline void CommandGetSchemaResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandGetSchemaResponse.error_message)
}
inline void CommandGetSchemaResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandGetSchemaResponse.error_message)
}
inline ::std::string* CommandGetSchemaResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchemaResponse.error_message)
  return error_message_;
}
inline ::std::string* CommandGetSchemaResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandGetSchemaResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchemaResponse.error_message)
}

// optional .pulsar.proto.Schema schema = 4;
inline bool CommandGetSchemaResponse::has_schema() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandGetSchemaResponse::set_has_schema() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandGetSchemaResponse::clear_has_schema() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandGetSchemaResponse::clear_schema() {
  if (schema_ != NULL) schema_->::pulsar::proto::Schema::Clear();
  clear_has_schema();
}
inline const ::pulsar::proto::Schema& CommandGetSchemaResponse::schema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.schema)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return schema_ != NULL ? *schema_ : *default_instance().schema_;
#else
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
#endif
}
inline ::pulsar::proto::Schema* CommandGetSchemaResponse::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::pulsar::proto::Schema;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchemaResponse.schema)
  return schema_;
}
inline ::pulsar::proto::Schema* CommandGetSchemaResponse::release_schema() {
  clear_has_schema();
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void CommandGetSchemaResponse::set_allocated_schema(::pulsar::proto::Schema* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchemaResponse.schema)
}

// optional bytes schema_version = 5;
inline bool CommandGetSchemaResponse::has_schema_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandGetSchemaResponse::set_has_schema_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandGetSchemaResponse::clear_has_schema_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandGetSchemaResponse::clear_schema_version() {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_->clear();
  }
  clear_has_schema_version();
}
inline const ::std::string& CommandGetSchemaResponse::schema_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.schema_version)
  return *schema_version_;
}
inline void CommandGetSchemaResponse::set_schema_version(const ::std::string& value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.schema_version)
}
inline void CommandGetSchemaResponse::set_schema_version(const char* value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandGetSchemaResponse.schema_version)
}
inline void CommandGetSchemaResponse::set_schema_version(const void* value, size_t size) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandGetSchemaResponse.schema_version)
}
inline ::std::string* CommandGetSchemaResponse::mutable_schema_version() {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchemaResponse.schema_version)
  return schema_version_;
}
inline ::std::string* CommandGetSchemaResponse::release_schema_version() {
  clear_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_version_;
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommandGetSchemaResponse::set_allocated_schema_version(::std::string* schema_version) {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_version_;
  }
  if (schema_version) {
    set_has_schema_version();
    schema_version_ = schema_version;
  } else {
    clear_has_schema_version();
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchemaResponse.schema_version)
}

// -------------------------------------------------------------------

// BaseCommand

// required .pulsar.proto.BaseCommand.Type type = 1;
inline bool BaseCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseCommand::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::pulsar::proto::BaseCommand_Type BaseCommand::type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.type)
  return static_cast< ::pulsar::proto::BaseCommand_Type >(type_);
}
inline void BaseCommand::set_type(::pulsar::proto::BaseCommand_Type value) {
  assert(::pulsar::proto::BaseCommand_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pulsar.proto.BaseCommand.type)
}

// optional .pulsar.proto.CommandConnect connect = 2;
inline bool BaseCommand::has_connect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseCommand::set_has_connect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseCommand::clear_has_connect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseCommand::clear_connect() {
  if (connect_ != NULL) connect_->::pulsar::proto::CommandConnect::Clear();
  clear_has_connect();
}
inline const ::pulsar::proto::CommandConnect& BaseCommand::connect() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.connect)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return connect_ != NULL ? *connect_ : *default_instance().connect_;
#else
  return connect_ != NULL ? *connect_ : *default_instance_->connect_;
#endif
}
inline ::pulsar::proto::CommandConnect* BaseCommand::mutable_connect() {
  set_has_connect();
  if (connect_ == NULL) connect_ = new ::pulsar::proto::CommandConnect;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.connect)
  return connect_;
}
inline ::pulsar::proto::CommandConnect* BaseCommand::release_connect() {
  clear_has_connect();
  ::pulsar::proto::CommandConnect* temp = connect_;
  connect_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_connect(::pulsar::proto::CommandConnect* connect) {
  delete connect_;
  connect_ = connect;
  if (connect) {
    set_has_connect();
  } else {
    clear_has_connect();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.connect)
}

// optional .pulsar.proto.CommandConnected connected = 3;
inline bool BaseCommand::has_connected() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BaseCommand::set_has_connected() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BaseCommand::clear_has_connected() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BaseCommand::clear_connected() {
  if (connected_ != NULL) connected_->::pulsar::proto::CommandConnected::Clear();
  clear_has_connected();
}
inline const ::pulsar::proto::CommandConnected& BaseCommand::connected() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.connected)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return connected_ != NULL ? *connected_ : *default_instance().connected_;
#else
  return connected_ != NULL ? *connected_ : *default_instance_->connected_;
#endif
}
inline ::pulsar::proto::CommandConnected* BaseCommand::mutable_connected() {
  set_has_connected();
  if (connected_ == NULL) connected_ = new ::pulsar::proto::CommandConnected;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.connected)
  return connected_;
}
inline ::pulsar::proto::CommandConnected* BaseCommand::release_connected() {
  clear_has_connected();
  ::pulsar::proto::CommandConnected* temp = connected_;
  connected_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_connected(::pulsar::proto::CommandConnected* connected) {
  delete connected_;
  connected_ = connected;
  if (connected) {
    set_has_connected();
  } else {
    clear_has_connected();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.connected)
}

// optional .pulsar.proto.CommandSubscribe subscribe = 4;
inline bool BaseCommand::has_subscribe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BaseCommand::set_has_subscribe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BaseCommand::clear_has_subscribe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BaseCommand::clear_subscribe() {
  if (subscribe_ != NULL) subscribe_->::pulsar::proto::CommandSubscribe::Clear();
  clear_has_subscribe();
}
inline const ::pulsar::proto::CommandSubscribe& BaseCommand::subscribe() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.subscribe)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return subscribe_ != NULL ? *subscribe_ : *default_instance().subscribe_;
#else
  return subscribe_ != NULL ? *subscribe_ : *default_instance_->subscribe_;
#endif
}
inline ::pulsar::proto::CommandSubscribe* BaseCommand::mutable_subscribe() {
  set_has_subscribe();
  if (subscribe_ == NULL) subscribe_ = new ::pulsar::proto::CommandSubscribe;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.subscribe)
  return subscribe_;
}
inline ::pulsar::proto::CommandSubscribe* BaseCommand::release_subscribe() {
  clear_has_subscribe();
  ::pulsar::proto::CommandSubscribe* temp = subscribe_;
  subscribe_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_subscribe(::pulsar::proto::CommandSubscribe* subscribe) {
  delete subscribe_;
  subscribe_ = subscribe;
  if (subscribe) {
    set_has_subscribe();
  } else {
    clear_has_subscribe();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.subscribe)
}

// optional .pulsar.proto.CommandProducer producer = 5;
inline bool BaseCommand::has_producer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BaseCommand::set_has_producer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BaseCommand::clear_has_producer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BaseCommand::clear_producer() {
  if (producer_ != NULL) producer_->::pulsar::proto::CommandProducer::Clear();
  clear_has_producer();
}
inline const ::pulsar::proto::CommandProducer& BaseCommand::producer() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.producer)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return producer_ != NULL ? *producer_ : *default_instance().producer_;
#else
  return producer_ != NULL ? *producer_ : *default_instance_->producer_;
#endif
}
inline ::pulsar::proto::CommandProducer* BaseCommand::mutable_producer() {
  set_has_producer();
  if (producer_ == NULL) producer_ = new ::pulsar::proto::CommandProducer;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.producer)
  return producer_;
}
inline ::pulsar::proto::CommandProducer* BaseCommand::release_producer() {
  clear_has_producer();
  ::pulsar::proto::CommandProducer* temp = producer_;
  producer_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_producer(::pulsar::proto::CommandProducer* producer) {
  delete producer_;
  producer_ = producer;
  if (producer) {
    set_has_producer();
  } else {
    clear_has_producer();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.producer)
}

// optional .pulsar.proto.CommandSend send = 6;
inline bool BaseCommand::has_send() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BaseCommand::set_has_send() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BaseCommand::clear_has_send() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BaseCommand::clear_send() {
  if (send_ != NULL) send_->::pulsar::proto::CommandSend::Clear();
  clear_has_send();
}
inline const ::pulsar::proto::CommandSend& BaseCommand::send() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.send)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return send_ != NULL ? *send_ : *default_instance().send_;
#else
  return send_ != NULL ? *send_ : *default_instance_->send_;
#endif
}
inline ::pulsar::proto::CommandSend* BaseCommand::mutable_send() {
  set_has_send();
  if (send_ == NULL) send_ = new ::pulsar::proto::CommandSend;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.send)
  return send_;
}
inline ::pulsar::proto::CommandSend* BaseCommand::release_send() {
  clear_has_send();
  ::pulsar::proto::CommandSend* temp = send_;
  send_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_send(::pulsar::proto::CommandSend* send) {
  delete send_;
  send_ = send;
  if (send) {
    set_has_send();
  } else {
    clear_has_send();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.send)
}

// optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
inline bool BaseCommand::has_send_receipt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BaseCommand::set_has_send_receipt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BaseCommand::clear_has_send_receipt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BaseCommand::clear_send_receipt() {
  if (send_receipt_ != NULL) send_receipt_->::pulsar::proto::CommandSendReceipt::Clear();
  clear_has_send_receipt();
}
inline const ::pulsar::proto::CommandSendReceipt& BaseCommand::send_receipt() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.send_receipt)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return send_receipt_ != NULL ? *send_receipt_ : *default_instance().send_receipt_;
#else
  return send_receipt_ != NULL ? *send_receipt_ : *default_instance_->send_receipt_;
#endif
}
inline ::pulsar::proto::CommandSendReceipt* BaseCommand::mutable_send_receipt() {
  set_has_send_receipt();
  if (send_receipt_ == NULL) send_receipt_ = new ::pulsar::proto::CommandSendReceipt;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.send_receipt)
  return send_receipt_;
}
inline ::pulsar::proto::CommandSendReceipt* BaseCommand::release_send_receipt() {
  clear_has_send_receipt();
  ::pulsar::proto::CommandSendReceipt* temp = send_receipt_;
  send_receipt_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_send_receipt(::pulsar::proto::CommandSendReceipt* send_receipt) {
  delete send_receipt_;
  send_receipt_ = send_receipt;
  if (send_receipt) {
    set_has_send_receipt();
  } else {
    clear_has_send_receipt();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.send_receipt)
}

// optional .pulsar.proto.CommandSendError send_error = 8;
inline bool BaseCommand::has_send_error() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BaseCommand::set_has_send_error() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BaseCommand::clear_has_send_error() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BaseCommand::clear_send_error() {
  if (send_error_ != NULL) send_error_->::pulsar::proto::CommandSendError::Clear();
  clear_has_send_error();
}
inline const ::pulsar::proto::CommandSendError& BaseCommand::send_error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.send_error)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return send_error_ != NULL ? *send_error_ : *default_instance().send_error_;
#else
  return send_error_ != NULL ? *send_error_ : *default_instance_->send_error_;
#endif
}
inline ::pulsar::proto::CommandSendError* BaseCommand::mutable_send_error() {
  set_has_send_error();
  if (send_error_ == NULL) send_error_ = new ::pulsar::proto::CommandSendError;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.send_error)
  return send_error_;
}
inline ::pulsar::proto::CommandSendError* BaseCommand::release_send_error() {
  clear_has_send_error();
  ::pulsar::proto::CommandSendError* temp = send_error_;
  send_error_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_send_error(::pulsar::proto::CommandSendError* send_error) {
  delete send_error_;
  send_error_ = send_error;
  if (send_error) {
    set_has_send_error();
  } else {
    clear_has_send_error();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.send_error)
}

// optional .pulsar.proto.CommandMessage message = 9;
inline bool BaseCommand::has_message() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BaseCommand::set_has_message() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BaseCommand::clear_has_message() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BaseCommand::clear_message() {
  if (message_ != NULL) message_->::pulsar::proto::CommandMessage::Clear();
  clear_has_message();
}
inline const ::pulsar::proto::CommandMessage& BaseCommand::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.message)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_ != NULL ? *message_ : *default_instance().message_;
#else
  return message_ != NULL ? *message_ : *default_instance_->message_;
#endif
}
inline ::pulsar::proto::CommandMessage* BaseCommand::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::pulsar::proto::CommandMessage;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.message)
  return message_;
}
inline ::pulsar::proto::CommandMessage* BaseCommand::release_message() {
  clear_has_message();
  ::pulsar::proto::CommandMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_message(::pulsar::proto::CommandMessage* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.message)
}

// optional .pulsar.proto.CommandAck ack = 10;
inline bool BaseCommand::has_ack() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BaseCommand::set_has_ack() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BaseCommand::clear_has_ack() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BaseCommand::clear_ack() {
  if (ack_ != NULL) ack_->::pulsar::proto::CommandAck::Clear();
  clear_has_ack();
}
inline const ::pulsar::proto::CommandAck& BaseCommand::ack() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.ack)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ack_ != NULL ? *ack_ : *default_instance().ack_;
#else
  return ack_ != NULL ? *ack_ : *default_instance_->ack_;
#endif
}
inline ::pulsar::proto::CommandAck* BaseCommand::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) ack_ = new ::pulsar::proto::CommandAck;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.ack)
  return ack_;
}
inline ::pulsar::proto::CommandAck* BaseCommand::release_ack() {
  clear_has_ack();
  ::pulsar::proto::CommandAck* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_ack(::pulsar::proto::CommandAck* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.ack)
}

// optional .pulsar.proto.CommandFlow flow = 11;
inline bool BaseCommand::has_flow() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BaseCommand::set_has_flow() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BaseCommand::clear_has_flow() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BaseCommand::clear_flow() {
  if (flow_ != NULL) flow_->::pulsar::proto::CommandFlow::Clear();
  clear_has_flow();
}
inline const ::pulsar::proto::CommandFlow& BaseCommand::flow() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.flow)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return flow_ != NULL ? *flow_ : *default_instance().flow_;
#else
  return flow_ != NULL ? *flow_ : *default_instance_->flow_;
#endif
}
inline ::pulsar::proto::CommandFlow* BaseCommand::mutable_flow() {
  set_has_flow();
  if (flow_ == NULL) flow_ = new ::pulsar::proto::CommandFlow;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.flow)
  return flow_;
}
inline ::pulsar::proto::CommandFlow* BaseCommand::release_flow() {
  clear_has_flow();
  ::pulsar::proto::CommandFlow* temp = flow_;
  flow_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_flow(::pulsar::proto::CommandFlow* flow) {
  delete flow_;
  flow_ = flow;
  if (flow) {
    set_has_flow();
  } else {
    clear_has_flow();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.flow)
}

// optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
inline bool BaseCommand::has_unsubscribe() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BaseCommand::set_has_unsubscribe() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BaseCommand::clear_has_unsubscribe() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BaseCommand::clear_unsubscribe() {
  if (unsubscribe_ != NULL) unsubscribe_->::pulsar::proto::CommandUnsubscribe::Clear();
  clear_has_unsubscribe();
}
inline const ::pulsar::proto::CommandUnsubscribe& BaseCommand::unsubscribe() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.unsubscribe)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return unsubscribe_ != NULL ? *unsubscribe_ : *default_instance().unsubscribe_;
#else
  return unsubscribe_ != NULL ? *unsubscribe_ : *default_instance_->unsubscribe_;
#endif
}
inline ::pulsar::proto::CommandUnsubscribe* BaseCommand::mutable_unsubscribe() {
  set_has_unsubscribe();
  if (unsubscribe_ == NULL) unsubscribe_ = new ::pulsar::proto::CommandUnsubscribe;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.unsubscribe)
  return unsubscribe_;
}
inline ::pulsar::proto::CommandUnsubscribe* BaseCommand::release_unsubscribe() {
  clear_has_unsubscribe();
  ::pulsar::proto::CommandUnsubscribe* temp = unsubscribe_;
  unsubscribe_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_unsubscribe(::pulsar::proto::CommandUnsubscribe* unsubscribe) {
  delete unsubscribe_;
  unsubscribe_ = unsubscribe;
  if (unsubscribe) {
    set_has_unsubscribe();
  } else {
    clear_has_unsubscribe();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.unsubscribe)
}

// optional .pulsar.proto.CommandSuccess success = 13;
inline bool BaseCommand::has_success() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BaseCommand::set_has_success() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BaseCommand::clear_has_success() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BaseCommand::clear_success() {
  if (success_ != NULL) success_->::pulsar::proto::CommandSuccess::Clear();
  clear_has_success();
}
inline const ::pulsar::proto::CommandSuccess& BaseCommand::success() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.success)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return success_ != NULL ? *success_ : *default_instance().success_;
#else
  return success_ != NULL ? *success_ : *default_instance_->success_;
#endif
}
inline ::pulsar::proto::CommandSuccess* BaseCommand::mutable_success() {
  set_has_success();
  if (success_ == NULL) success_ = new ::pulsar::proto::CommandSuccess;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.success)
  return success_;
}
inline ::pulsar::proto::CommandSuccess* BaseCommand::release_success() {
  clear_has_success();
  ::pulsar::proto::CommandSuccess* temp = success_;
  success_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_success(::pulsar::proto::CommandSuccess* success) {
  delete success_;
  success_ = success;
  if (success) {
    set_has_success();
  } else {
    clear_has_success();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.success)
}

// optional .pulsar.proto.CommandError error = 14;
inline bool BaseCommand::has_error() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BaseCommand::set_has_error() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BaseCommand::clear_has_error() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BaseCommand::clear_error() {
  if (error_ != NULL) error_->::pulsar::proto::CommandError::Clear();
  clear_has_error();
}
inline const ::pulsar::proto::CommandError& BaseCommand::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.error)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return error_ != NULL ? *error_ : *default_instance().error_;
#else
  return error_ != NULL ? *error_ : *default_instance_->error_;
#endif
}
inline ::pulsar::proto::CommandError* BaseCommand::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::pulsar::proto::CommandError;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.error)
  return error_;
}
inline ::pulsar::proto::CommandError* BaseCommand::release_error() {
  clear_has_error();
  ::pulsar::proto::CommandError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_error(::pulsar::proto::CommandError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.error)
}

// optional .pulsar.proto.CommandCloseProducer close_producer = 15;
inline bool BaseCommand::has_close_producer() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BaseCommand::set_has_close_producer() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BaseCommand::clear_has_close_producer() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BaseCommand::clear_close_producer() {
  if (close_producer_ != NULL) close_producer_->::pulsar::proto::CommandCloseProducer::Clear();
  clear_has_close_producer();
}
inline const ::pulsar::proto::CommandCloseProducer& BaseCommand::close_producer() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.close_producer)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return close_producer_ != NULL ? *close_producer_ : *default_instance().close_producer_;
#else
  return close_producer_ != NULL ? *close_producer_ : *default_instance_->close_producer_;
#endif
}
inline ::pulsar::proto::CommandCloseProducer* BaseCommand::mutable_close_producer() {
  set_has_close_producer();
  if (close_producer_ == NULL) close_producer_ = new ::pulsar::proto::CommandCloseProducer;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.close_producer)
  return close_producer_;
}
inline ::pulsar::proto::CommandCloseProducer* BaseCommand::release_close_producer() {
  clear_has_close_producer();
  ::pulsar::proto::CommandCloseProducer* temp = close_producer_;
  close_producer_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_close_producer(::pulsar::proto::CommandCloseProducer* close_producer) {
  delete close_producer_;
  close_producer_ = close_producer;
  if (close_producer) {
    set_has_close_producer();
  } else {
    clear_has_close_producer();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.close_producer)
}

// optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
inline bool BaseCommand::has_close_consumer() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BaseCommand::set_has_close_consumer() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BaseCommand::clear_has_close_consumer() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BaseCommand::clear_close_consumer() {
  if (close_consumer_ != NULL) close_consumer_->::pulsar::proto::CommandCloseConsumer::Clear();
  clear_has_close_consumer();
}
inline const ::pulsar::proto::CommandCloseConsumer& BaseCommand::close_consumer() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.close_consumer)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return close_consumer_ != NULL ? *close_consumer_ : *default_instance().close_consumer_;
#else
  return close_consumer_ != NULL ? *close_consumer_ : *default_instance_->close_consumer_;
#endif
}
inline ::pulsar::proto::CommandCloseConsumer* BaseCommand::mutable_close_consumer() {
  set_has_close_consumer();
  if (close_consumer_ == NULL) close_consumer_ = new ::pulsar::proto::CommandCloseConsumer;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.close_consumer)
  return close_consumer_;
}
inline ::pulsar::proto::CommandCloseConsumer* BaseCommand::release_close_consumer() {
  clear_has_close_consumer();
  ::pulsar::proto::CommandCloseConsumer* temp = close_consumer_;
  close_consumer_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_close_consumer(::pulsar::proto::CommandCloseConsumer* close_consumer) {
  delete close_consumer_;
  close_consumer_ = close_consumer;
  if (close_consumer) {
    set_has_close_consumer();
  } else {
    clear_has_close_consumer();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.close_consumer)
}

// optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
inline bool BaseCommand::has_producer_success() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BaseCommand::set_has_producer_success() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BaseCommand::clear_has_producer_success() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BaseCommand::clear_producer_success() {
  if (producer_success_ != NULL) producer_success_->::pulsar::proto::CommandProducerSuccess::Clear();
  clear_has_producer_success();
}
inline const ::pulsar::proto::CommandProducerSuccess& BaseCommand::producer_success() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.producer_success)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return producer_success_ != NULL ? *producer_success_ : *default_instance().producer_success_;
#else
  return producer_success_ != NULL ? *producer_success_ : *default_instance_->producer_success_;
#endif
}
inline ::pulsar::proto::CommandProducerSuccess* BaseCommand::mutable_producer_success() {
  set_has_producer_success();
  if (producer_success_ == NULL) producer_success_ = new ::pulsar::proto::CommandProducerSuccess;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.producer_success)
  return producer_success_;
}
inline ::pulsar::proto::CommandProducerSuccess* BaseCommand::release_producer_success() {
  clear_has_producer_success();
  ::pulsar::proto::CommandProducerSuccess* temp = producer_success_;
  producer_success_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_producer_success(::pulsar::proto::CommandProducerSuccess* producer_success) {
  delete producer_success_;
  producer_success_ = producer_success;
  if (producer_success) {
    set_has_producer_success();
  } else {
    clear_has_producer_success();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.producer_success)
}

// optional .pulsar.proto.CommandPing ping = 18;
inline bool BaseCommand::has_ping() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BaseCommand::set_has_ping() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BaseCommand::clear_has_ping() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BaseCommand::clear_ping() {
  if (ping_ != NULL) ping_->::pulsar::proto::CommandPing::Clear();
  clear_has_ping();
}
inline const ::pulsar::proto::CommandPing& BaseCommand::ping() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.ping)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ping_ != NULL ? *ping_ : *default_instance().ping_;
#else
  return ping_ != NULL ? *ping_ : *default_instance_->ping_;
#endif
}
inline ::pulsar::proto::CommandPing* BaseCommand::mutable_ping() {
  set_has_ping();
  if (ping_ == NULL) ping_ = new ::pulsar::proto::CommandPing;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.ping)
  return ping_;
}
inline ::pulsar::proto::CommandPing* BaseCommand::release_ping() {
  clear_has_ping();
  ::pulsar::proto::CommandPing* temp = ping_;
  ping_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_ping(::pulsar::proto::CommandPing* ping) {
  delete ping_;
  ping_ = ping;
  if (ping) {
    set_has_ping();
  } else {
    clear_has_ping();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.ping)
}

// optional .pulsar.proto.CommandPong pong = 19;
inline bool BaseCommand::has_pong() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BaseCommand::set_has_pong() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BaseCommand::clear_has_pong() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BaseCommand::clear_pong() {
  if (pong_ != NULL) pong_->::pulsar::proto::CommandPong::Clear();
  clear_has_pong();
}
inline const ::pulsar::proto::CommandPong& BaseCommand::pong() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.pong)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pong_ != NULL ? *pong_ : *default_instance().pong_;
#else
  return pong_ != NULL ? *pong_ : *default_instance_->pong_;
#endif
}
inline ::pulsar::proto::CommandPong* BaseCommand::mutable_pong() {
  set_has_pong();
  if (pong_ == NULL) pong_ = new ::pulsar::proto::CommandPong;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.pong)
  return pong_;
}
inline ::pulsar::proto::CommandPong* BaseCommand::release_pong() {
  clear_has_pong();
  ::pulsar::proto::CommandPong* temp = pong_;
  pong_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_pong(::pulsar::proto::CommandPong* pong) {
  delete pong_;
  pong_ = pong;
  if (pong) {
    set_has_pong();
  } else {
    clear_has_pong();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.pong)
}

// optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
inline bool BaseCommand::has_redeliverunacknowledgedmessages() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BaseCommand::set_has_redeliverunacknowledgedmessages() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BaseCommand::clear_has_redeliverunacknowledgedmessages() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BaseCommand::clear_redeliverunacknowledgedmessages() {
  if (redeliverunacknowledgedmessages_ != NULL) redeliverunacknowledgedmessages_->::pulsar::proto::CommandRedeliverUnacknowledgedMessages::Clear();
  clear_has_redeliverunacknowledgedmessages();
}
inline const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& BaseCommand::redeliverunacknowledgedmessages() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return redeliverunacknowledgedmessages_ != NULL ? *redeliverunacknowledgedmessages_ : *default_instance().redeliverunacknowledgedmessages_;
#else
  return redeliverunacknowledgedmessages_ != NULL ? *redeliverunacknowledgedmessages_ : *default_instance_->redeliverunacknowledgedmessages_;
#endif
}
inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* BaseCommand::mutable_redeliverunacknowledgedmessages() {
  set_has_redeliverunacknowledgedmessages();
  if (redeliverunacknowledgedmessages_ == NULL) redeliverunacknowledgedmessages_ = new ::pulsar::proto::CommandRedeliverUnacknowledgedMessages;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
  return redeliverunacknowledgedmessages_;
}
inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* BaseCommand::release_redeliverunacknowledgedmessages() {
  clear_has_redeliverunacknowledgedmessages();
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* temp = redeliverunacknowledgedmessages_;
  redeliverunacknowledgedmessages_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_redeliverunacknowledgedmessages(::pulsar::proto::CommandRedeliverUnacknowledgedMessages* redeliverunacknowledgedmessages) {
  delete redeliverunacknowledgedmessages_;
  redeliverunacknowledgedmessages_ = redeliverunacknowledgedmessages;
  if (redeliverunacknowledgedmessages) {
    set_has_redeliverunacknowledgedmessages();
  } else {
    clear_has_redeliverunacknowledgedmessages();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
}

// optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
inline bool BaseCommand::has_partitionmetadata() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BaseCommand::set_has_partitionmetadata() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BaseCommand::clear_has_partitionmetadata() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BaseCommand::clear_partitionmetadata() {
  if (partitionmetadata_ != NULL) partitionmetadata_->::pulsar::proto::CommandPartitionedTopicMetadata::Clear();
  clear_has_partitionmetadata();
}
inline const ::pulsar::proto::CommandPartitionedTopicMetadata& BaseCommand::partitionmetadata() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.partitionMetadata)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return partitionmetadata_ != NULL ? *partitionmetadata_ : *default_instance().partitionmetadata_;
#else
  return partitionmetadata_ != NULL ? *partitionmetadata_ : *default_instance_->partitionmetadata_;
#endif
}
inline ::pulsar::proto::CommandPartitionedTopicMetadata* BaseCommand::mutable_partitionmetadata() {
  set_has_partitionmetadata();
  if (partitionmetadata_ == NULL) partitionmetadata_ = new ::pulsar::proto::CommandPartitionedTopicMetadata;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.partitionMetadata)
  return partitionmetadata_;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadata* BaseCommand::release_partitionmetadata() {
  clear_has_partitionmetadata();
  ::pulsar::proto::CommandPartitionedTopicMetadata* temp = partitionmetadata_;
  partitionmetadata_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_partitionmetadata(::pulsar::proto::CommandPartitionedTopicMetadata* partitionmetadata) {
  delete partitionmetadata_;
  partitionmetadata_ = partitionmetadata;
  if (partitionmetadata) {
    set_has_partitionmetadata();
  } else {
    clear_has_partitionmetadata();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.partitionMetadata)
}

// optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
inline bool BaseCommand::has_partitionmetadataresponse() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BaseCommand::set_has_partitionmetadataresponse() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BaseCommand::clear_has_partitionmetadataresponse() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BaseCommand::clear_partitionmetadataresponse() {
  if (partitionmetadataresponse_ != NULL) partitionmetadataresponse_->::pulsar::proto::CommandPartitionedTopicMetadataResponse::Clear();
  clear_has_partitionmetadataresponse();
}
inline const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& BaseCommand::partitionmetadataresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.partitionMetadataResponse)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return partitionmetadataresponse_ != NULL ? *partitionmetadataresponse_ : *default_instance().partitionmetadataresponse_;
#else
  return partitionmetadataresponse_ != NULL ? *partitionmetadataresponse_ : *default_instance_->partitionmetadataresponse_;
#endif
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* BaseCommand::mutable_partitionmetadataresponse() {
  set_has_partitionmetadataresponse();
  if (partitionmetadataresponse_ == NULL) partitionmetadataresponse_ = new ::pulsar::proto::CommandPartitionedTopicMetadataResponse;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.partitionMetadataResponse)
  return partitionmetadataresponse_;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* BaseCommand::release_partitionmetadataresponse() {
  clear_has_partitionmetadataresponse();
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* temp = partitionmetadataresponse_;
  partitionmetadataresponse_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_partitionmetadataresponse(::pulsar::proto::CommandPartitionedTopicMetadataResponse* partitionmetadataresponse) {
  delete partitionmetadataresponse_;
  partitionmetadataresponse_ = partitionmetadataresponse;
  if (partitionmetadataresponse) {
    set_has_partitionmetadataresponse();
  } else {
    clear_has_partitionmetadataresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.partitionMetadataResponse)
}

// optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
inline bool BaseCommand::has_lookuptopic() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BaseCommand::set_has_lookuptopic() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BaseCommand::clear_has_lookuptopic() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BaseCommand::clear_lookuptopic() {
  if (lookuptopic_ != NULL) lookuptopic_->::pulsar::proto::CommandLookupTopic::Clear();
  clear_has_lookuptopic();
}
inline const ::pulsar::proto::CommandLookupTopic& BaseCommand::lookuptopic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.lookupTopic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return lookuptopic_ != NULL ? *lookuptopic_ : *default_instance().lookuptopic_;
#else
  return lookuptopic_ != NULL ? *lookuptopic_ : *default_instance_->lookuptopic_;
#endif
}
inline ::pulsar::proto::CommandLookupTopic* BaseCommand::mutable_lookuptopic() {
  set_has_lookuptopic();
  if (lookuptopic_ == NULL) lookuptopic_ = new ::pulsar::proto::CommandLookupTopic;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.lookupTopic)
  return lookuptopic_;
}
inline ::pulsar::proto::CommandLookupTopic* BaseCommand::release_lookuptopic() {
  clear_has_lookuptopic();
  ::pulsar::proto::CommandLookupTopic* temp = lookuptopic_;
  lookuptopic_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_lookuptopic(::pulsar::proto::CommandLookupTopic* lookuptopic) {
  delete lookuptopic_;
  lookuptopic_ = lookuptopic;
  if (lookuptopic) {
    set_has_lookuptopic();
  } else {
    clear_has_lookuptopic();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.lookupTopic)
}

// optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
inline bool BaseCommand::has_lookuptopicresponse() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BaseCommand::set_has_lookuptopicresponse() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BaseCommand::clear_has_lookuptopicresponse() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BaseCommand::clear_lookuptopicresponse() {
  if (lookuptopicresponse_ != NULL) lookuptopicresponse_->::pulsar::proto::CommandLookupTopicResponse::Clear();
  clear_has_lookuptopicresponse();
}
inline const ::pulsar::proto::CommandLookupTopicResponse& BaseCommand::lookuptopicresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.lookupTopicResponse)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return lookuptopicresponse_ != NULL ? *lookuptopicresponse_ : *default_instance().lookuptopicresponse_;
#else
  return lookuptopicresponse_ != NULL ? *lookuptopicresponse_ : *default_instance_->lookuptopicresponse_;
#endif
}
inline ::pulsar::proto::CommandLookupTopicResponse* BaseCommand::mutable_lookuptopicresponse() {
  set_has_lookuptopicresponse();
  if (lookuptopicresponse_ == NULL) lookuptopicresponse_ = new ::pulsar::proto::CommandLookupTopicResponse;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.lookupTopicResponse)
  return lookuptopicresponse_;
}
inline ::pulsar::proto::CommandLookupTopicResponse* BaseCommand::release_lookuptopicresponse() {
  clear_has_lookuptopicresponse();
  ::pulsar::proto::CommandLookupTopicResponse* temp = lookuptopicresponse_;
  lookuptopicresponse_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_lookuptopicresponse(::pulsar::proto::CommandLookupTopicResponse* lookuptopicresponse) {
  delete lookuptopicresponse_;
  lookuptopicresponse_ = lookuptopicresponse;
  if (lookuptopicresponse) {
    set_has_lookuptopicresponse();
  } else {
    clear_has_lookuptopicresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.lookupTopicResponse)
}

// optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
inline bool BaseCommand::has_consumerstats() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BaseCommand::set_has_consumerstats() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BaseCommand::clear_has_consumerstats() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BaseCommand::clear_consumerstats() {
  if (consumerstats_ != NULL) consumerstats_->::pulsar::proto::CommandConsumerStats::Clear();
  clear_has_consumerstats();
}
inline const ::pulsar::proto::CommandConsumerStats& BaseCommand::consumerstats() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.consumerStats)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return consumerstats_ != NULL ? *consumerstats_ : *default_instance().consumerstats_;
#else
  return consumerstats_ != NULL ? *consumerstats_ : *default_instance_->consumerstats_;
#endif
}
inline ::pulsar::proto::CommandConsumerStats* BaseCommand::mutable_consumerstats() {
  set_has_consumerstats();
  if (consumerstats_ == NULL) consumerstats_ = new ::pulsar::proto::CommandConsumerStats;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.consumerStats)
  return consumerstats_;
}
inline ::pulsar::proto::CommandConsumerStats* BaseCommand::release_consumerstats() {
  clear_has_consumerstats();
  ::pulsar::proto::CommandConsumerStats* temp = consumerstats_;
  consumerstats_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_consumerstats(::pulsar::proto::CommandConsumerStats* consumerstats) {
  delete consumerstats_;
  consumerstats_ = consumerstats;
  if (consumerstats) {
    set_has_consumerstats();
  } else {
    clear_has_consumerstats();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.consumerStats)
}

// optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
inline bool BaseCommand::has_consumerstatsresponse() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BaseCommand::set_has_consumerstatsresponse() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BaseCommand::clear_has_consumerstatsresponse() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BaseCommand::clear_consumerstatsresponse() {
  if (consumerstatsresponse_ != NULL) consumerstatsresponse_->::pulsar::proto::CommandConsumerStatsResponse::Clear();
  clear_has_consumerstatsresponse();
}
inline const ::pulsar::proto::CommandConsumerStatsResponse& BaseCommand::consumerstatsresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.consumerStatsResponse)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return consumerstatsresponse_ != NULL ? *consumerstatsresponse_ : *default_instance().consumerstatsresponse_;
#else
  return consumerstatsresponse_ != NULL ? *consumerstatsresponse_ : *default_instance_->consumerstatsresponse_;
#endif
}
inline ::pulsar::proto::CommandConsumerStatsResponse* BaseCommand::mutable_consumerstatsresponse() {
  set_has_consumerstatsresponse();
  if (consumerstatsresponse_ == NULL) consumerstatsresponse_ = new ::pulsar::proto::CommandConsumerStatsResponse;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.consumerStatsResponse)
  return consumerstatsresponse_;
}
inline ::pulsar::proto::CommandConsumerStatsResponse* BaseCommand::release_consumerstatsresponse() {
  clear_has_consumerstatsresponse();
  ::pulsar::proto::CommandConsumerStatsResponse* temp = consumerstatsresponse_;
  consumerstatsresponse_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_consumerstatsresponse(::pulsar::proto::CommandConsumerStatsResponse* consumerstatsresponse) {
  delete consumerstatsresponse_;
  consumerstatsresponse_ = consumerstatsresponse;
  if (consumerstatsresponse) {
    set_has_consumerstatsresponse();
  } else {
    clear_has_consumerstatsresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.consumerStatsResponse)
}

// optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
inline bool BaseCommand::has_reachedendoftopic() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BaseCommand::set_has_reachedendoftopic() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BaseCommand::clear_has_reachedendoftopic() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BaseCommand::clear_reachedendoftopic() {
  if (reachedendoftopic_ != NULL) reachedendoftopic_->::pulsar::proto::CommandReachedEndOfTopic::Clear();
  clear_has_reachedendoftopic();
}
inline const ::pulsar::proto::CommandReachedEndOfTopic& BaseCommand::reachedendoftopic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.reachedEndOfTopic)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reachedendoftopic_ != NULL ? *reachedendoftopic_ : *default_instance().reachedendoftopic_;
#else
  return reachedendoftopic_ != NULL ? *reachedendoftopic_ : *default_instance_->reachedendoftopic_;
#endif
}
inline ::pulsar::proto::CommandReachedEndOfTopic* BaseCommand::mutable_reachedendoftopic() {
  set_has_reachedendoftopic();
  if (reachedendoftopic_ == NULL) reachedendoftopic_ = new ::pulsar::proto::CommandReachedEndOfTopic;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.reachedEndOfTopic)
  return reachedendoftopic_;
}
inline ::pulsar::proto::CommandReachedEndOfTopic* BaseCommand::release_reachedendoftopic() {
  clear_has_reachedendoftopic();
  ::pulsar::proto::CommandReachedEndOfTopic* temp = reachedendoftopic_;
  reachedendoftopic_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_reachedendoftopic(::pulsar::proto::CommandReachedEndOfTopic* reachedendoftopic) {
  delete reachedendoftopic_;
  reachedendoftopic_ = reachedendoftopic;
  if (reachedendoftopic) {
    set_has_reachedendoftopic();
  } else {
    clear_has_reachedendoftopic();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.reachedEndOfTopic)
}

// optional .pulsar.proto.CommandSeek seek = 28;
inline bool BaseCommand::has_seek() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BaseCommand::set_has_seek() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BaseCommand::clear_has_seek() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BaseCommand::clear_seek() {
  if (seek_ != NULL) seek_->::pulsar::proto::CommandSeek::Clear();
  clear_has_seek();
}
inline const ::pulsar::proto::CommandSeek& BaseCommand::seek() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.seek)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return seek_ != NULL ? *seek_ : *default_instance().seek_;
#else
  return seek_ != NULL ? *seek_ : *default_instance_->seek_;
#endif
}
inline ::pulsar::proto::CommandSeek* BaseCommand::mutable_seek() {
  set_has_seek();
  if (seek_ == NULL) seek_ = new ::pulsar::proto::CommandSeek;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.seek)
  return seek_;
}
inline ::pulsar::proto::CommandSeek* BaseCommand::release_seek() {
  clear_has_seek();
  ::pulsar::proto::CommandSeek* temp = seek_;
  seek_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_seek(::pulsar::proto::CommandSeek* seek) {
  delete seek_;
  seek_ = seek;
  if (seek) {
    set_has_seek();
  } else {
    clear_has_seek();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.seek)
}

// optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
inline bool BaseCommand::has_getlastmessageid() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void BaseCommand::set_has_getlastmessageid() {
  _has_bits_[0] |= 0x10000000u;
}
inline void BaseCommand::clear_has_getlastmessageid() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void BaseCommand::clear_getlastmessageid() {
  if (getlastmessageid_ != NULL) getlastmessageid_->::pulsar::proto::CommandGetLastMessageId::Clear();
  clear_has_getlastmessageid();
}
inline const ::pulsar::proto::CommandGetLastMessageId& BaseCommand::getlastmessageid() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getLastMessageId)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getlastmessageid_ != NULL ? *getlastmessageid_ : *default_instance().getlastmessageid_;
#else
  return getlastmessageid_ != NULL ? *getlastmessageid_ : *default_instance_->getlastmessageid_;
#endif
}
inline ::pulsar::proto::CommandGetLastMessageId* BaseCommand::mutable_getlastmessageid() {
  set_has_getlastmessageid();
  if (getlastmessageid_ == NULL) getlastmessageid_ = new ::pulsar::proto::CommandGetLastMessageId;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getLastMessageId)
  return getlastmessageid_;
}
inline ::pulsar::proto::CommandGetLastMessageId* BaseCommand::release_getlastmessageid() {
  clear_has_getlastmessageid();
  ::pulsar::proto::CommandGetLastMessageId* temp = getlastmessageid_;
  getlastmessageid_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_getlastmessageid(::pulsar::proto::CommandGetLastMessageId* getlastmessageid) {
  delete getlastmessageid_;
  getlastmessageid_ = getlastmessageid;
  if (getlastmessageid) {
    set_has_getlastmessageid();
  } else {
    clear_has_getlastmessageid();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getLastMessageId)
}

// optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
inline bool BaseCommand::has_getlastmessageidresponse() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void BaseCommand::set_has_getlastmessageidresponse() {
  _has_bits_[0] |= 0x20000000u;
}
inline void BaseCommand::clear_has_getlastmessageidresponse() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void BaseCommand::clear_getlastmessageidresponse() {
  if (getlastmessageidresponse_ != NULL) getlastmessageidresponse_->::pulsar::proto::CommandGetLastMessageIdResponse::Clear();
  clear_has_getlastmessageidresponse();
}
inline const ::pulsar::proto::CommandGetLastMessageIdResponse& BaseCommand::getlastmessageidresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getLastMessageIdResponse)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getlastmessageidresponse_ != NULL ? *getlastmessageidresponse_ : *default_instance().getlastmessageidresponse_;
#else
  return getlastmessageidresponse_ != NULL ? *getlastmessageidresponse_ : *default_instance_->getlastmessageidresponse_;
#endif
}
inline ::pulsar::proto::CommandGetLastMessageIdResponse* BaseCommand::mutable_getlastmessageidresponse() {
  set_has_getlastmessageidresponse();
  if (getlastmessageidresponse_ == NULL) getlastmessageidresponse_ = new ::pulsar::proto::CommandGetLastMessageIdResponse;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getLastMessageIdResponse)
  return getlastmessageidresponse_;
}
inline ::pulsar::proto::CommandGetLastMessageIdResponse* BaseCommand::release_getlastmessageidresponse() {
  clear_has_getlastmessageidresponse();
  ::pulsar::proto::CommandGetLastMessageIdResponse* temp = getlastmessageidresponse_;
  getlastmessageidresponse_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_getlastmessageidresponse(::pulsar::proto::CommandGetLastMessageIdResponse* getlastmessageidresponse) {
  delete getlastmessageidresponse_;
  getlastmessageidresponse_ = getlastmessageidresponse;
  if (getlastmessageidresponse) {
    set_has_getlastmessageidresponse();
  } else {
    clear_has_getlastmessageidresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getLastMessageIdResponse)
}

// optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
inline bool BaseCommand::has_active_consumer_change() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void BaseCommand::set_has_active_consumer_change() {
  _has_bits_[0] |= 0x40000000u;
}
inline void BaseCommand::clear_has_active_consumer_change() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void BaseCommand::clear_active_consumer_change() {
  if (active_consumer_change_ != NULL) active_consumer_change_->::pulsar::proto::CommandActiveConsumerChange::Clear();
  clear_has_active_consumer_change();
}
inline const ::pulsar::proto::CommandActiveConsumerChange& BaseCommand::active_consumer_change() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.active_consumer_change)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return active_consumer_change_ != NULL ? *active_consumer_change_ : *default_instance().active_consumer_change_;
#else
  return active_consumer_change_ != NULL ? *active_consumer_change_ : *default_instance_->active_consumer_change_;
#endif
}
inline ::pulsar::proto::CommandActiveConsumerChange* BaseCommand::mutable_active_consumer_change() {
  set_has_active_consumer_change();
  if (active_consumer_change_ == NULL) active_consumer_change_ = new ::pulsar::proto::CommandActiveConsumerChange;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.active_consumer_change)
  return active_consumer_change_;
}
inline ::pulsar::proto::CommandActiveConsumerChange* BaseCommand::release_active_consumer_change() {
  clear_has_active_consumer_change();
  ::pulsar::proto::CommandActiveConsumerChange* temp = active_consumer_change_;
  active_consumer_change_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_active_consumer_change(::pulsar::proto::CommandActiveConsumerChange* active_consumer_change) {
  delete active_consumer_change_;
  active_consumer_change_ = active_consumer_change;
  if (active_consumer_change) {
    set_has_active_consumer_change();
  } else {
    clear_has_active_consumer_change();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.active_consumer_change)
}

// optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
inline bool BaseCommand::has_gettopicsofnamespace() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void BaseCommand::set_has_gettopicsofnamespace() {
  _has_bits_[0] |= 0x80000000u;
}
inline void BaseCommand::clear_has_gettopicsofnamespace() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void BaseCommand::clear_gettopicsofnamespace() {
  if (gettopicsofnamespace_ != NULL) gettopicsofnamespace_->::pulsar::proto::CommandGetTopicsOfNamespace::Clear();
  clear_has_gettopicsofnamespace();
}
inline const ::pulsar::proto::CommandGetTopicsOfNamespace& BaseCommand::gettopicsofnamespace() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getTopicsOfNamespace)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gettopicsofnamespace_ != NULL ? *gettopicsofnamespace_ : *default_instance().gettopicsofnamespace_;
#else
  return gettopicsofnamespace_ != NULL ? *gettopicsofnamespace_ : *default_instance_->gettopicsofnamespace_;
#endif
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace* BaseCommand::mutable_gettopicsofnamespace() {
  set_has_gettopicsofnamespace();
  if (gettopicsofnamespace_ == NULL) gettopicsofnamespace_ = new ::pulsar::proto::CommandGetTopicsOfNamespace;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getTopicsOfNamespace)
  return gettopicsofnamespace_;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace* BaseCommand::release_gettopicsofnamespace() {
  clear_has_gettopicsofnamespace();
  ::pulsar::proto::CommandGetTopicsOfNamespace* temp = gettopicsofnamespace_;
  gettopicsofnamespace_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_gettopicsofnamespace(::pulsar::proto::CommandGetTopicsOfNamespace* gettopicsofnamespace) {
  delete gettopicsofnamespace_;
  gettopicsofnamespace_ = gettopicsofnamespace;
  if (gettopicsofnamespace) {
    set_has_gettopicsofnamespace();
  } else {
    clear_has_gettopicsofnamespace();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getTopicsOfNamespace)
}

// optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
inline bool BaseCommand::has_gettopicsofnamespaceresponse() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void BaseCommand::set_has_gettopicsofnamespaceresponse() {
  _has_bits_[1] |= 0x00000001u;
}
inline void BaseCommand::clear_has_gettopicsofnamespaceresponse() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void BaseCommand::clear_gettopicsofnamespaceresponse() {
  if (gettopicsofnamespaceresponse_ != NULL) gettopicsofnamespaceresponse_->::pulsar::proto::CommandGetTopicsOfNamespaceResponse::Clear();
  clear_has_gettopicsofnamespaceresponse();
}
inline const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& BaseCommand::gettopicsofnamespaceresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gettopicsofnamespaceresponse_ != NULL ? *gettopicsofnamespaceresponse_ : *default_instance().gettopicsofnamespaceresponse_;
#else
  return gettopicsofnamespaceresponse_ != NULL ? *gettopicsofnamespaceresponse_ : *default_instance_->gettopicsofnamespaceresponse_;
#endif
}
inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* BaseCommand::mutable_gettopicsofnamespaceresponse() {
  set_has_gettopicsofnamespaceresponse();
  if (gettopicsofnamespaceresponse_ == NULL) gettopicsofnamespaceresponse_ = new ::pulsar::proto::CommandGetTopicsOfNamespaceResponse;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
  return gettopicsofnamespaceresponse_;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* BaseCommand::release_gettopicsofnamespaceresponse() {
  clear_has_gettopicsofnamespaceresponse();
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* temp = gettopicsofnamespaceresponse_;
  gettopicsofnamespaceresponse_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_gettopicsofnamespaceresponse(::pulsar::proto::CommandGetTopicsOfNamespaceResponse* gettopicsofnamespaceresponse) {
  delete gettopicsofnamespaceresponse_;
  gettopicsofnamespaceresponse_ = gettopicsofnamespaceresponse;
  if (gettopicsofnamespaceresponse) {
    set_has_gettopicsofnamespaceresponse();
  } else {
    clear_has_gettopicsofnamespaceresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
}

// optional .pulsar.proto.CommandGetSchema getSchema = 34;
inline bool BaseCommand::has_getschema() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void BaseCommand::set_has_getschema() {
  _has_bits_[1] |= 0x00000002u;
}
inline void BaseCommand::clear_has_getschema() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void BaseCommand::clear_getschema() {
  if (getschema_ != NULL) getschema_->::pulsar::proto::CommandGetSchema::Clear();
  clear_has_getschema();
}
inline const ::pulsar::proto::CommandGetSchema& BaseCommand::getschema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getSchema)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getschema_ != NULL ? *getschema_ : *default_instance().getschema_;
#else
  return getschema_ != NULL ? *getschema_ : *default_instance_->getschema_;
#endif
}
inline ::pulsar::proto::CommandGetSchema* BaseCommand::mutable_getschema() {
  set_has_getschema();
  if (getschema_ == NULL) getschema_ = new ::pulsar::proto::CommandGetSchema;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getSchema)
  return getschema_;
}
inline ::pulsar::proto::CommandGetSchema* BaseCommand::release_getschema() {
  clear_has_getschema();
  ::pulsar::proto::CommandGetSchema* temp = getschema_;
  getschema_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_getschema(::pulsar::proto::CommandGetSchema* getschema) {
  delete getschema_;
  getschema_ = getschema;
  if (getschema) {
    set_has_getschema();
  } else {
    clear_has_getschema();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getSchema)
}

// optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
inline bool BaseCommand::has_getschemaresponse() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void BaseCommand::set_has_getschemaresponse() {
  _has_bits_[1] |= 0x00000004u;
}
inline void BaseCommand::clear_has_getschemaresponse() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void BaseCommand::clear_getschemaresponse() {
  if (getschemaresponse_ != NULL) getschemaresponse_->::pulsar::proto::CommandGetSchemaResponse::Clear();
  clear_has_getschemaresponse();
}
inline const ::pulsar::proto::CommandGetSchemaResponse& BaseCommand::getschemaresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getSchemaResponse)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getschemaresponse_ != NULL ? *getschemaresponse_ : *default_instance().getschemaresponse_;
#else
  return getschemaresponse_ != NULL ? *getschemaresponse_ : *default_instance_->getschemaresponse_;
#endif
}
inline ::pulsar::proto::CommandGetSchemaResponse* BaseCommand::mutable_getschemaresponse() {
  set_has_getschemaresponse();
  if (getschemaresponse_ == NULL) getschemaresponse_ = new ::pulsar::proto::CommandGetSchemaResponse;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getSchemaResponse)
  return getschemaresponse_;
}
inline ::pulsar::proto::CommandGetSchemaResponse* BaseCommand::release_getschemaresponse() {
  clear_has_getschemaresponse();
  ::pulsar::proto::CommandGetSchemaResponse* temp = getschemaresponse_;
  getschemaresponse_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_getschemaresponse(::pulsar::proto::CommandGetSchemaResponse* getschemaresponse) {
  delete getschemaresponse_;
  getschemaresponse_ = getschemaresponse;
  if (getschemaresponse) {
    set_has_getschemaresponse();
  } else {
    clear_has_getschemaresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getSchemaResponse)
}

// optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
inline bool BaseCommand::has_authchallenge() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void BaseCommand::set_has_authchallenge() {
  _has_bits_[1] |= 0x00000008u;
}
inline void BaseCommand::clear_has_authchallenge() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void BaseCommand::clear_authchallenge() {
  if (authchallenge_ != NULL) authchallenge_->::pulsar::proto::CommandAuthChallenge::Clear();
  clear_has_authchallenge();
}
inline const ::pulsar::proto::CommandAuthChallenge& BaseCommand::authchallenge() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.authChallenge)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return authchallenge_ != NULL ? *authchallenge_ : *default_instance().authchallenge_;
#else
  return authchallenge_ != NULL ? *authchallenge_ : *default_instance_->authchallenge_;
#endif
}
inline ::pulsar::proto::CommandAuthChallenge* BaseCommand::mutable_authchallenge() {
  set_has_authchallenge();
  if (authchallenge_ == NULL) authchallenge_ = new ::pulsar::proto::CommandAuthChallenge;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.authChallenge)
  return authchallenge_;
}
inline ::pulsar::proto::CommandAuthChallenge* BaseCommand::release_authchallenge() {
  clear_has_authchallenge();
  ::pulsar::proto::CommandAuthChallenge* temp = authchallenge_;
  authchallenge_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_authchallenge(::pulsar::proto::CommandAuthChallenge* authchallenge) {
  delete authchallenge_;
  authchallenge_ = authchallenge;
  if (authchallenge) {
    set_has_authchallenge();
  } else {
    clear_has_authchallenge();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.authChallenge)
}

// optional .pulsar.proto.CommandAuthResponse authResponse = 37;
inline bool BaseCommand::has_authresponse() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void BaseCommand::set_has_authresponse() {
  _has_bits_[1] |= 0x00000010u;
}
inline void BaseCommand::clear_has_authresponse() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void BaseCommand::clear_authresponse() {
  if (authresponse_ != NULL) authresponse_->::pulsar::proto::CommandAuthResponse::Clear();
  clear_has_authresponse();
}
inline const ::pulsar::proto::CommandAuthResponse& BaseCommand::authresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.authResponse)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return authresponse_ != NULL ? *authresponse_ : *default_instance().authresponse_;
#else
  return authresponse_ != NULL ? *authresponse_ : *default_instance_->authresponse_;
#endif
}
inline ::pulsar::proto::CommandAuthResponse* BaseCommand::mutable_authresponse() {
  set_has_authresponse();
  if (authresponse_ == NULL) authresponse_ = new ::pulsar::proto::CommandAuthResponse;
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.authResponse)
  return authresponse_;
}
inline ::pulsar::proto::CommandAuthResponse* BaseCommand::release_authresponse() {
  clear_has_authresponse();
  ::pulsar::proto::CommandAuthResponse* temp = authresponse_;
  authresponse_ = NULL;
  return temp;
}
inline void BaseCommand::set_allocated_authresponse(::pulsar::proto::CommandAuthResponse* authresponse) {
  delete authresponse_;
  authresponse_ = authresponse;
  if (authresponse) {
    set_has_authresponse();
  } else {
    clear_has_authresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.authResponse)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace pulsar

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PulsarApi_2eproto__INCLUDED
